# 배열

이 전 단원들에서 여러가지 타입들에 대해서 학습하였다. C언어에는 뿐만 아니라 여태까지 학습한 타입들로부터 파생되는 타입(derived type)들이 존재한다.  
특히 여태까지 다뤘던 데이터 타입들은 하나의 값을 저장 및 표현하였는데, 이러한 타입을 스칼라 타입(scalar type)이라고 한다.  
반면 한 번에 다수의 값을 저장 및 표현할 수 있는 데이터 타입을 집합 타입(aggregate type)이라고 한다. 이번 단원에서는 집합 타입의 일종인 배열의 기본적인 개념과 사용법에 대해서 알아볼 것이다.  

## 일차원 배열

여태까지 int 타입의 변수 네 개가 필요하다면 다음과 같이 선언하였다.  

```c
int a = 1, b = 2, c = 3, d = 4;
```  

물론 위와 같이 사용해도 상관 없지만, 네 개의 변수가 서로 연관되어 하나의 집합을 형성한다면 배열을 사용하는 것이 훨씬 편하고 자연스럽다. 배열을 사용한다면 다음과 같이 선언할 수 있다.  

```c
int arr[4] = { 1, 2, 3, 4 };
```  

위 예시만 보더라도 대략적인 감이 올 수 있겠지만, 자세한 개념과 사용법에 대해서 알아보자.  

C언어에서 배열의 정의는 동일한 타입의 객체 여러 개를 연속된 메모리에 할당하는 타입이다. 그리고 여기서 각각의 객체를 배열의 요소 혹은 원소(element)라고 한다.  
위 예시에서 arr 라는 이름의 배열은 int 타입의 요소 네 개를 가진다. 즉, 1, 2, 3, 4는 각각 배열 arr의 요소이다.  
배열은 크게 일차원 배열, 다차원 배열, 가변 길이 배열(Variable-Length Array)로 구분할 수 있다. 우선 가장 쉬운 일차원 배열로 시작하여 개념을 확장할 것이다.  

### 배열의 선언

배열의 선언 또한 3단원에서 학습했던 선언과 크게 다르지 않다. 기본적인 선언의 형태가 다음과 같다고 하였다.  
```c
<declaration-specifiers> <init-declarator-list>;
```  

*declaration-specifiers*의 경우 결국 *type-specifier*와 같은 요소가 되어 ```int``` 같은 타입을 지정할 수 있다고 했다.  
*init-declarator-list*는 *declarator* 혹은 *declarator = initializer* 와 같은 형태가 된다. *declarator*가 *identifier*가 되면 ```int arr;``` 와 같이 여태 사용했던 스칼라 오브젝트 선언이 된다.  
*declarator*는 배열을 선언하기 위하여 *array-declarator*가 될 수도 있다. *array-declarator*는 결국 ```identifier[constant-expression]``` 와 같은 형태를 가지게 된다.  

> 정확히는 *array-declarator*가 ```direct-declarator[type-qualifier-list_opt assignment-expression_opt]``` 의 형태가 되지만, 학습의 편의를 위해 일차원 배열 선언시 귀결되는 ```identifier[constant-expression]``` 로 내용을 전개한다.  

그러면 결국 일차원 배열의 가장 기본적인 선언은 다음과 같은 형태가 된다.  

```c
type-specifier identifier[constant-expression];
```  

타입 지정자(type-specifier)는 ```int```와 같이 배열의 요소를 표현할 타입을 지정하고, 식별자(identifier)는 ```arr```와 같이 배열의 이름을 지정하며, 상수식(constant-expression)은 ```4```와 같이 배열의 길이를 지정한다. 결국 길이가 4인 ```int``` 타입의 배열 arr를 다음과 같이 선언할 수 있다.  

```c
int arr[4];
```  

이렇게 생성된 배열의 요소들은 가상 메모리 상에서 연속된 주소 공간을 할당받는다. ```int``` 타입의 크기가 4 byte인 시스템 상에서는 다음과 같이 16 byte를 할당하게 된다. 참고로 아래 숫자는 대략적으로 지정한 메모리 주소이다.  

![basic](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/basic.png?raw=true)  

배열이 주소 1000번에 할당된 경우, 각 요소의 (시작)주소는 1000, 1004, 1008, 1012가 된다. 만약 ```int``` 타입의 크기가 2 byte인 시스템이라면 1000, 1002, 1004, 1006일 것이며, 8 byte인 시스템이라면 1000, 1008, 1016, 1024일 것이다. 배열의 각 요소는 아키텍처별 해당 타입의 표현 방식대로 값을 저장한다.  
배열의 요소를 위한 타입은 ```void```를 포함한 불완전(incomplete) 타입과 함수 타입을 제외한 모든 타입이 올 수 있으며, 배열의 길이를 위한 *constant-expression*는 결과가 0을 초과하는 정수여야 한다.  

> 참고로 함수 타입은 올 수 없지만, 추후에 배울 함수 포인터 타입은 올 수 있다.  

### 배열의 초기화

배열도 이 전 까지의 변수와 같이 선언 시에 초기화를 할 수 있다. 초기화하려는 각 요소의 값을 { 와 } 기호 안에 쉼표(,)로 구분하여 지정할 수 있다.  

```c
int arr[4] = { 1, 2, 3, 4 };
```  

이렇게 중괄호로 묶은 이니셜라이저 리스트를 괄호 이니셜라이저(braced-initializer)라고 한다. 배열의 초기화 외에도 괄호 이니셜라이저가 사용되는 곳들이 있는데, 배열의 초기화에 사용하는 경우 특별히 배열 이니셜라이저(array initializer)라고도 한다.  
괄호 이니셜라이저에 있는 값들은 배열의 첫 번째 요소부터 하나씩 대응하여 초기화한다. 만약 괄호 이니셜라이저에 있는 값이 배열의 길이보다 적다면 배열의 남은 요소는 0으로 초기화된다. (정확히는 static storage duration의 객체와 동일한 방식으로 초기화되는데, 이는 추후에 학습할 것이다.)  

```c
int arr[4] = { 1, 2 };  // 세 번째 요소와 네 번째 요소는 0으로 초기화 된다.
int arr[4] = { 1, 2, 0, 0 };    // 위 선언과 완전히 동일하다
```  

반대로 괄호 이니셜라이저에 있는 값이 배열의 길이보다 많다면 이는 오류다. 컴파일러마다 길이를 초과하는 값은 무시하고 초기화하기도 하지만, 이처럼 사용하면 안 된다.  

```c
int arr[4] = { 1, 2, 3, 4, 5 };     // 오류
```  

괄호 이니셜라이저에 아무런 값이 없다면 어떨까? 즉 ```{ }``` 와 같이 사용하는 경우 C23 표준부터 이를 빈 이니셜라이저(empty initializer)라고 한다. C23 전까지는 이를 표준에서 정의하지 않았기에 오류가 될 수도 있다. (일부 컴파일러에서는 이미 지원하기도 하였다.)  
빈 이니셜라이저를 사용하는 경우 배열의 모든 값은 0으로 초기화된다. (정확히는 위와 마찬가지로 static storage duration 객체와 동일한 방식으로 초기화된다.) 따라서 배열의 모든 값을 0으로 초기화하고 싶다면 빈 이니셜라이저를 사용할 수 있다. 하지만, 이는 C23이라는 특정 표준 이후부터 보장되는 내용이기 때문에 특정한 컴파일러와 표준 버전을 지정할 것이 아니라면 ```{ 0 }``` 와 같이 사용하는 것이 좋다.  

```c
int arr[4] = { };       // 빈 이니셜라이저, C23 이후부터 보장됨
int arr[4] = { 0 };     // 모든 요소가 0으로 초기화되기가 전부터 보장됨
```  

그리고 괄호 이니셜라이저를 사용하는 경우에는 배열의 길이를 생략할 수 있다. 이 때 배열의 길이는 값의 개수가 된다. (정확히는 가장 큰 인덱스 + 1이 되는데, 인덱스는 바로 직후에 학습할 것이다.)  

```c
int arr[] = { 1, 2, 3, 4 };     // 배열의 길이는 4개가 된다.
int arr[4] = { 1, 2, 3, 4 };    // 위 선언과 완전히 동일하다.
```  

마지막으로 괄호 이니셜라이저는 다음과 같이 총 세가지의 형태를 가진다.  

```c
// braced-initializer
{ }     // 빈 이니셜라이저
{ initializer-list }
{ initializer-list , }
```  

따라서 괄호 이니셜라이저의 마지막 요소 뒤에는 쉼표를 추가로 붙일 수 있다. 이는 괄호 이니셜라이저의 길이에는 영향을 주지 않는다. 단지 이러한 문법을 허용함으로써 프로그래머가 괄호 이니셜라이저 내의 값을 좀 더 편하게 수정할 수 있게 도와준다.  

```c
// 모두 동일한 선언 및 초기화
int arr[4] = { 1, 2 };
int arr[4] = { 1, 2, };
int arr[4] = { 1, 2, 0, 0 };
int arr[4] = { 1, 2, 0, 0, };
```  

만약 배열을 괄호 이니셜라이저 없이 선언했다면 요소들은 초기화하지 않은 스칼라 변수와 같이 어떤 값을 가지고 있을지 알 수 없다. 선언한 위치, 아키텍처와 컴파일러 등에 따라 달라지기 때문에 초기화하지 않은 배열의 요소에 있는 값을 사용해서는 안 된다.  

> 괄호 이니셜라이저 내에 쉼표로 구분되는 각 expression들은 비결정적으로 시퀀스된다. 만약 동일한 객체에 대해 side effect가 여러 expression에서 발생한다면 이는 미지정 행위(unspecified behavior)이다.  

### 배열 첨자

배열을 선언 및 초기화했다면, 배열의 각 요소에 접근하여 사용할 차례다. 배열의 각 요소에 접근하는 것을 첨자(subscript) 혹은 색인(index) 연산이라고 한다.  
첨자 연산은 선언과 유사한 방식으로 ```[expression]``` 를 사용한다. *expression* 번째에 있는 배열의 요소를 첨자하는데, *expression*의 결과는 정수여야 한다.  
단 유의할 점이 있는데 인덱스(첨자)의 시작은 1이 아닌 0이다. 즉, 첫 번째 요소를 첨자하기 위해서는 ```arr[1]``` 이 아닌 ```arr[0]``` 이라고 해야 한다. 이에 따라 ```arr[1]``` 은 두 번째 요소를 첨자한다.  

처음 접하면 굉장히 헷갈릴 수 있는 개념이기 때문에 주의가 필요하다. 다시 한 번 상기하는 겸, 앞으로 해당 서적에서 첨자, 색인, 요소를 다음과 같이 사용할 것이다.  
* ```arr[0]```은 배열의 첫 번째 요소이다.  
* ```arr[0]```은 배열의 0번 인덱스이다. (명사)  
* ```arr[0]```은 배열의 0번을 첨자한다. (동사)  

참고로 용어를 위와 같이 사용하기로 정의된 것은 아니다. 표준에서 연산자의 이름을 array subscripting operator, indexed element와 같은 용어를 사용하기 때문에 유사하게 대응시킨 것이다.  

다음은 ```int arr[4] = { 1, 2, 3, 4 };``` 와 같이 초기화 한 경우 각 요소를 시각화한 그림이다.  
![basic](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/subscript.png?raw=true)  

배열에 첨자 연산을 했을 때는 일반적인 변수와 동일하게 사용할 수 있다. 따라서 다음과 같이 lvalue로 사용이 가능하다.  

```c  
int arr[4];
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
arr[3] = 4;
```  

배열의 인덱스는 결과가 정수인 *expression*으로 지정할 수 있다. 이에 대해 굉장히 주의해야 하는데, 배열의 길이를 벗어난 범위에 대해서도 인덱스를 지정하더라도 컴파일 에러가 발생하지 않는다. 하지만 이는 미정의 행위이기 때문에 실행 중에 어떤 일이 발생할지 알 수 없다. 에러가 발생할 수도, 쓰레기 값을 가져올 수도, 엉뚱한 값을 가져올 수도 있기 때문에 꼭 배열의 범위 내에서 인덱스를 지정하도록 유의해야 한다.  

```c
int arr[4] = { 1, 2, 3, 4 };
arr[-1];    // 배열의 범위를 벗어남, 미정의 행위
arr[4];     // 배열의 범위를 벗어남, 미정의 행위
```  

또한 *expression* 이기 때문에 당연히 변수 등이 포함된 수식을 사용할 수 있으며, 사이드 이펙트 또한 발생한다. 이 덕분에 배열은 반복문 등과 함께 사용하여 아주 강력한 제어 능력을 발휘할 수 있다. 추후에 배열 응용 절에서 이러한 내용에 대해 더욱 자세히 알아볼 것이다.  

```c
int i = 0;
while (i < 4)               // i가 4보다 작을 때까지 (i가 0부터 3까지 반복하게 됨)
    printf("%d ", arr[i++]);    // 배열 요소 출력, i++의 평가 값은 i이며, 사이드 이펙트로 1 증가함

for (i = 0; i < 4; i++)     // i가 0부터 3까지
    printf("%d ", arr[i]);      // 배열 요소 출력
```  

### 배열 지정 초기화

여태까지 배열을 초기화하기 위해서는 무조건 첫 번째 요소부터 값을 지정해줘야 했다. 그런데 배열 중 특정 인덱스에만 값을 지정해주고 싶은 경우도 있을 수 있다. 예를 들어, 다음과 같이 길이가 10인 배열에 2번과 7번 인덱스만 특정 값으로 초기화 하고 싶은 경우가 있을 수 있다.  

```c
int arr[10] = { 0, 0, 10, 0, 0, 0, 0, 20, 0, 0 };   // arr[2] = 10, arr[7] = 20
```  

8,9번 인덱스는 생략할 수 있다고 하더라도 꽤나 비효율적으로 표기해야 한다. 만약 배열의 길이가 100이 넘어가는데 90번 인덱스만 특정 값으로 초기화하고 싶다면 더욱 비효율적일 것이다. (물론 모두 0으로 초기화한 다음, ```arr[90] = n;``` 문장을 통해 직접 값을 넣어줄 수 있기는 하다.)  
이런 경우를 대비하여 C99 표준부터 배열의 지정 이니셜라이저(designated initalizer)를 지원한다. 지정 이니셜라이저는 배열 이니셜라이저의 일종으로, 다음과 같이 사용할 수 있다.  

```c
int arr[10] = { [2] = 10, [7] = 20 };
```  

이 때 인덱스를 지정하기 위한 대괄호 내역을 지정자(designator)라고 한다. 지정자는 배열의 인덱스 범위(0 ~ 배열의 길이 - 1)의 정수 값을 가지는 *constant-expression*이어야 한다. 결국 괄호 이니셜라이저에 지정자를 사용하는 경우 다음과 같은 형태가 된다.  

```c
{ [constant-expression] = assignment-expression, }
```  

지정자가 여럿 있는 경우 더 작은 지정자가 앞에 와야할까? 그런 제약은 없기 때문에 다음과 같이 작성할 수도 있다.  

```c
int arr[10] = { [7] = 20, [2] = 10 };
```  

지정 이니셜라이저를 사용하는 경우에 배열의 길이를 지정하지 않으면 어떻게 될까? 이 전에 괄호 이니셜라이저를 사용하는 경우에는 배열의 길이를 생략할 수 있으며, 이 때 배열의 길이는 가장 큰 인덱스 + 1이 된다고 했다. 결국 배열의 길이를 생략하고 지정 이니셜라이저를 사용하면 지정자에는 아무 양의 정수를 쓸 수 있으며, 배열의 길이는 가장 큰 지정자 + 1이 된다. (+ 1을 하는 이유는 인덱스가 0부터 시작하기 때문이다.)  

```c
int arr[] = { [9] = 30, [2] = 10, [7] = 20 };   // 배열의 길이는 10, 가능한 인덱스는 0 ~ 9
```  

그러면 일반적인 초기화 방식과 지정 초기화를 섞어서 사용할 수 있을까? 이 또한 가능하다. 지정자 이 후에 일반 초기화 값이 오면, 지정자가 지정한 인덱스 다음 값부터 초기화를 수행한다.  

```c
int arr[10] = { 1, 2, [4] = 10, 11, 12, [8] = 20, 21 };     // 아래와 동일
int arr[10] = { 1, 2, 0, 0, 10, 11, 12, 0, 20, 21 };        // 위와 동일
```  

그렇다면 지정자로 인하여 초기화하려는 대상 객체의 중복이 발생하면 어떻게 될까? 즉, ```{ 1, 2, 3, [1] = 10, 11, 12 };``` 와 같은 상황은 어떻게 될까?  
얼핏 생각하면 오류이거나, 미정의 행위이거나, 미지정 행위같다고 생각할 수 있다. 하지만 표준에서는 앞쪽의 값을 무시하고 뒤쪽의 값을 사용하여 초기화하는 것을 보장한다.  

```c
int arr[10] = { 1, 2, [4] = 10, 11, 12, 13, [1] = 20, 21, 22, 23, 24, [9] = 30 };
```  

여태까지 설명을 잘 이해했다면 위 예시에서 배열의 값이 ```{ 1, 20, 21, 22, 23, 24, 12, 13, 0, 30 }``` 이 된다는 것을 알 수 있다.  
하지만 위와 같은 코드는 프로그래밍의 대전제인 가독성을 크게 해친다. 따라서 표준에서 이를 보장한다고 하더라도, 굳이 일반적인 초기화 방식과 지정 초기화 방식을 복잡하게 섞어서 사용하는 것은 지양하는 것이 좋다.  

### 배열 응용

## 다차원 배열