# 배열

이 전 단원들에서 여러가지 타입들에 대해서 학습하였다. C언어에는 뿐만 아니라 여태까지 학습한 타입들로부터 파생되는 타입(derived type)들이 존재한다.  
특히 여태까지 다뤘던 데이터 타입들은 하나의 값을 저장 및 표현하였는데, 이러한 타입을 스칼라 타입(scalar type)이라고 한다.  
반면 한 번에 다수의 값을 저장 및 표현할 수 있는 데이터 타입을 집합 타입(aggregate type)이라고 한다. 이번 단원에서는 집합 타입의 일종인 배열의 기본적인 개념과 사용법에 대해서 알아볼 것이다.  

## 일차원 배열

여태까지 int 타입의 변수 네 개가 필요하다면 다음과 같이 선언하였다.  

```c
int a = 1, b = 2, c = 3, d = 4;
```  

물론 위와 같이 사용해도 상관 없지만, 네 개의 변수가 서로 연관되어 하나의 집합을 형성한다면 배열을 사용하는 것이 훨씬 편하고 자연스럽다. 배열을 사용한다면 다음과 같이 선언할 수 있다.  

```c
int arr[4] = { 1, 2, 3, 4 };
```  

위 예시만 보더라도 대략적인 감이 올 수 있겠지만, 자세한 개념과 사용법에 대해서 알아보자.  

C언어에서 배열의 정의는 동일한 타입의 객체 여러 개를 연속된 메모리에 할당하는 타입이다. 그리고 여기서 각각의 객체를 배열의 요소 혹은 원소(element)라고 한다.  
위 예시에서 arr 라는 이름의 배열은 int 타입의 요소 네 개를 가진다. 즉, 1, 2, 3, 4는 각각 배열 arr의 요소이다.  
배열은 크게 일차원 배열, 다차원 배열, 가변 길이 배열(Variable-Length Array)로 구분할 수 있다. 우선 가장 쉬운 일차원 배열로 시작하여 개념을 확장할 것이다.  

### 배열의 선언

배열의 선언 또한 3단원에서 학습했던 선언과 크게 다르지 않다. 기본적인 선언의 형태가 다음과 같다고 하였다.  
```c
<declaration-specifiers> <init-declarator-list>;
```  

*declaration-specifiers*의 경우 결국 *type-specifier*와 같은 요소가 되어 ```int``` 같은 타입을 지정할 수 있다고 했다.  
*init-declarator-list*는 *declarator* 혹은 *declarator = initializer* 와 같은 형태가 된다. *declarator*가 *identifier*가 되면 ```int arr;``` 와 같이 여태 사용했던 스칼라 오브젝트 선언이 된다.  
*declarator*는 배열을 선언하기 위하여 *array-declarator*가 될 수도 있다. *array-declarator*는 결국 ```identifier[constant-expression]``` 와 같은 형태를 가지게 된다.  

> 정확히는 *array-declarator*가 ```direct-declarator[type-qualifier-list_opt assignment-expression_opt]``` 의 형태가 되지만, 학습의 편의를 위해 일차원 배열 선언시 귀결되는 ```identifier[constant-expression]``` 로 내용을 전개한다.  

그러면 결국 일차원 배열의 가장 기본적인 선언은 다음과 같은 형태가 된다.  

```c
type-specifier identifier[constant-expression];
```  

타입 지정자(type-specifier)는 ```int```와 같이 배열의 요소를 표현할 타입을 지정하고, 식별자(identifier)는 ```arr```와 같이 배열의 이름을 지정하며, 상수식(constant-expression)은 ```4```와 같이 배열의 길이를 지정한다. 결국 길이가 4인 ```int``` 타입의 배열 arr를 다음과 같이 선언할 수 있다.  

```c
int arr[4];
```  

이렇게 생성된 배열의 요소들은 가상 메모리 상에서 연속된 주소 공간을 할당받는다. ```int``` 타입의 크기가 4 byte인 시스템 상에서는 다음과 같이 16 byte를 할당하게 된다. 참고로 아래 숫자는 대략적으로 지정한 메모리 주소이다.  

![basic](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/basic.png?raw=true)  

배열이 주소 1000번에 할당된 경우, 각 요소의 (시작)주소는 1000, 1004, 1008, 1012가 된다. 만약 ```int``` 타입의 크기가 2 byte인 시스템이라면 1000, 1002, 1004, 1006일 것이며, 8 byte인 시스템이라면 1000, 1008, 1016, 1024일 것이다. 배열의 각 요소는 아키텍처별 해당 타입의 표현 방식대로 값을 저장한다.  
배열의 요소를 위한 타입에는 ```void```를 포함한 불완전(incomplete) 타입과 함수 타입은 올 수 없다. 그를 제외한 모든 타입이 올 수 있으며, 배열의 길이를 위한 *constant-expression*는 결과가 0을 초과하는 정수여야 한다. (즉, 배열의 크기는 항상 1과 같거나 커야 한다.)  

> 참고로 함수 타입은 올 수 없지만, 추후에 배울 함수 포인터 타입은 올 수 있다.  

### 배열의 초기화

배열도 이 전 까지의 변수와 같이 선언 시에 초기화를 할 수 있다. 초기화하려는 각 요소의 값을 { 와 } 기호 안에 쉼표(,)로 구분하여 지정할 수 있다.  

```c
int arr[4] = { 1, 2, 3, 4 };
```  

이렇게 중괄호로 묶은 이니셜라이저 리스트를 괄호 이니셜라이저(braced-initializer)라고 한다. 배열의 초기화 외에도 괄호 이니셜라이저가 사용되는 곳들이 있는데, 배열의 초기화에 사용하는 경우 특별히 배열 이니셜라이저(array initializer)라고도 한다.  
괄호 이니셜라이저에 있는 값들은 배열의 첫 번째 요소부터 하나씩 대응하여 초기화한다. 만약 괄호 이니셜라이저에 있는 값이 배열의 길이보다 적다면 배열의 남은 요소는 0으로 초기화된다. (정확히는 static storage duration의 객체와 동일한 방식으로 초기화되는데, 이는 추후에 학습할 것이다.)  

```c
int arr[4] = { 1, 2 };  // 세 번째 요소와 네 번째 요소는 0으로 초기화 된다.
int arr[4] = { 1, 2, 0, 0 };    // 위 선언과 완전히 동일하다
```  

반대로 괄호 이니셜라이저에 있는 값이 배열의 길이보다 많다면 이는 미정의 행위다. 컴파일러마다 길이를 초과하는 값은 무시하고 초기화하기도 하지만, 이처럼 사용하면 안 된다.  

```c
int arr[4] = { 1, 2, 3, 4, 5 };     // 미정의 행위
```  

괄호 이니셜라이저에 아무런 값이 없다면 어떨까? 즉 ```{ }``` 와 같이 사용하는 경우 C23 표준부터 이를 빈 이니셜라이저(empty initializer)라고 한다. C23 전까지는 이를 표준에서 정의하지 않았기에 오류가 될 수도 있다. (일부 컴파일러에서는 이미 지원하기도 하였다.)  
빈 이니셜라이저를 사용하는 경우 배열의 모든 값은 0으로 초기화된다. (정확히는 위와 마찬가지로 static storage duration 객체와 동일한 방식으로 초기화된다.) 따라서 배열의 모든 값을 0으로 초기화하고 싶다면 빈 이니셜라이저를 사용할 수 있다. 하지만, 이는 C23이라는 특정 표준 이후부터 보장되는 내용이기 때문에 특정한 컴파일러와 표준 버전을 지정할 것이 아니라면 ```{ 0 }``` 와 같이 사용하는 것이 좋다.  

```c
int arr[4] = { };       // 빈 이니셜라이저, C23 이후부터 보장됨
int arr[4] = { 0 };     // 모든 요소가 0으로 초기화되기가 전부터 보장됨
```  

그리고 괄호 이니셜라이저를 사용하는 경우에는 배열의 길이를 생략할 수 있다. 이 때 배열의 길이는 값의 개수가 된다. (정확히는 가장 큰 인덱스 + 1이 되는데, 인덱스는 바로 직후에 학습할 것이다.)  

```c
int arr[] = { 1, 2, 3, 4 };     // 배열의 길이는 4개가 된다.
int arr[4] = { 1, 2, 3, 4 };    // 위 선언과 완전히 동일하다.
```  

결국 괄호 이니셜라이저는 다음과 같이 총 세가지의 형태를 가진다.  

```c
// braced-initializer
{ }     // 빈 이니셜라이저
{ initializer-list }
{ initializer-list , }
```  

따라서 괄호 이니셜라이저의 마지막 요소 뒤에는 쉼표를 추가로 붙일 수 있다. 이는 괄호 이니셜라이저의 길이에는 영향을 주지 않는다. 단지 이러한 문법을 허용함으로써 프로그래머가 괄호 이니셜라이저 내의 값을 좀 더 편하게 수정할 수 있게 도와준다.  

```c
// 모두 동일한 선언 및 초기화
int arr[4] = { 1, 2 };
int arr[4] = { 1, 2, };
int arr[4] = { 1, 2, 0, 0 };
int arr[4] = { 1, 2, 0, 0, };
```  

만약 배열을 괄호 이니셜라이저 없이 선언했다면 요소들은 초기화하지 않은 스칼라 변수와 같이 어떤 값을 가지고 있을지 알 수 없다. 선언한 위치, 아키텍처와 컴파일러 등에 따라 달라지기 때문에 초기화하지 않은 배열의 요소에 있는 값을 사용해서는 안 된다.  

> 괄호 이니셜라이저 내에 쉼표로 구분되는 각 expression들은 비결정적으로 시퀀스된다. 만약 동일한 객체에 대해 side effect가 여러 expression에서 발생한다면 이는 미지정 행위(unspecified behavior)이다.  

마지막으로 유의할 내용으로, 초기화와 대입은 엄연히 다르다는 것이다. 챕터3에서 언급한 바와 같이 초기화에 사용한 ```=``` 기호는 대입 연산자가 아니라 선언에서 선언자와 이니셜라이저를 구분하기 위한 구두점이다. 따라서, 식문장에서 다음과 같이 대입 연산의 우항으로 괄호 이니셜라이저를 사용할 수 없다. 이니셜라이저는 식문장이 아닌 선언에서만 사용할 수 있다.  

```c
int arr[4];                 // 선언
arr = { 1, 2, 3, 4 };       // 컴파일 에러!
```  

### 배열 첨자

배열을 선언 및 초기화했다면, 배열의 각 요소에 접근하여 사용할 차례다. 배열의 각 요소에 접근하는 것을 첨자(subscript) 혹은 색인(index) 연산이라고 한다.  
첨자 연산은 선언과 유사한 방식으로 ```[expression]``` 를 사용한다. *expression* 번째에 있는 배열의 요소를 첨자하는데, *expression*의 결과는 정수여야 한다.  
단 유의할 점이 있는데 인덱스(첨자)의 시작은 1이 아닌 0이다. 즉, 첫 번째 요소를 첨자하기 위해서는 ```arr[1]``` 이 아닌 ```arr[0]``` 이라고 해야 한다. 이에 따라 ```arr[1]``` 은 두 번째 요소를 첨자한다.  

처음 접하면 굉장히 헷갈릴 수 있는 개념이기 때문에 주의가 필요하다. 다시 한 번 상기하는 겸, 앞으로 해당 서적에서 첨자, 색인, 요소를 다음과 같이 사용할 것이다.  
* ```arr[0]```은 배열의 첫 번째 요소이다.  
* ```arr[0]```은 배열의 0번 인덱스이다. (명사)  
* ```arr[0]```은 배열의 0번을 첨자한다. (동사)  

참고로 용어를 위와 같이 사용하기로 정의된 것은 아니다. 표준에서 연산자의 이름을 array subscripting operator, indexed element와 같은 용어를 사용하기 때문에 유사하게 대응시킨 것이다.  

다음은 ```int arr[4] = { 1, 2, 3, 4 };``` 와 같이 초기화 한 경우 각 요소를 시각화한 그림이다.  
![basic](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/subscript.png?raw=true)  

배열에 첨자 연산을 했을 때는 일반적인 변수와 동일하게 사용할 수 있다. 따라서 다음과 같이 lvalue로 사용이 가능하다.  

```c  
int arr[4];
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
arr[3] = 4;
```  

배열의 인덱스는 결과가 정수인 *expression*으로 지정할 수 있다. 이에 대해 굉장히 주의해야 하는데, 배열의 길이를 벗어난 범위에 대해서도 인덱스를 지정하더라도 컴파일 에러가 발생하지 않는다. 하지만 이는 미정의 행위이기 때문에 실행 중에 어떤 일이 발생할지 알 수 없다. 에러가 발생할 수도, 쓰레기 값을 가져올 수도, 엉뚱한 값을 가져올 수도 있기 때문에 꼭 배열의 범위 내에서 인덱스를 지정하도록 유의해야 한다.  

```c
int arr[4] = { 1, 2, 3, 4 };
arr[-1];    // 배열의 범위를 벗어남, 미정의 행위
arr[4];     // 배열의 범위를 벗어남, 미정의 행위
```  

또한 *expression* 이기 때문에 당연히 변수 등이 포함된 수식을 사용할 수 있으며, 사이드 이펙트 또한 발생한다. 이 덕분에 배열은 반복문 등과 함께 사용하여 아주 강력한 제어 능력을 발휘할 수 있다. 추후에 배열 응용 절에서 이러한 내용에 대해 더욱 자세히 알아볼 것이다.  

```c
int i = 0;
while (i < 4)               // i가 4보다 작을 때까지 (i가 0부터 3까지 반복하게 됨)
    printf("%d ", arr[i++]);    // 배열 요소 출력, i++의 평가 값은 i이며, 사이드 이펙트로 1 증가함

for (i = 0; i < 4; i++)     // i가 0부터 3까지
    printf("%d ", arr[i]);      // 배열 요소 출력
```  

### 배열 지정 초기화

여태까지 배열을 초기화하기 위해서는 무조건 첫 번째 요소부터 값을 지정해줘야 했다. 그런데 배열 중 특정 인덱스에만 값을 지정해주고 싶은 경우도 있을 수 있다. 예를 들어, 다음과 같이 길이가 10인 배열에 2번과 7번 인덱스만 특정 값으로 초기화 하고 싶은 경우가 있을 수 있다.  

```c
int arr[10] = { 0, 0, 10, 0, 0, 0, 0, 20, 0, 0 };   // arr[2] = 10, arr[7] = 20
```  

8,9번 인덱스는 생략할 수 있다고 하더라도 꽤나 비효율적으로 표기해야 한다. 만약 배열의 길이가 100이 넘어가는데 90번 인덱스만 특정 값으로 초기화하고 싶다면 더욱 비효율적일 것이다. (물론 모두 0으로 초기화한 다음, ```arr[90] = n;``` 문장을 통해 직접 값을 넣어줄 수 있기는 하다.)  
이런 경우를 대비하여 C99 표준부터 배열의 지정 이니셜라이저(designated initalizer)를 지원한다. 지정 이니셜라이저는 배열 이니셜라이저의 일종으로, 다음과 같이 사용할 수 있다.  

```c
int arr[10] = { [2] = 10, [7] = 20 };
```  

이 때 인덱스를 지정하기 위한 대괄호 내역을 지정자(designator)라고 한다. 지정자는 배열의 인덱스 범위(0 ~ 배열의 길이 - 1)의 정수 값을 가지는 *constant-expression*이어야 한다. 결국 괄호 이니셜라이저에 지정자를 사용하는 경우 다음과 같은 형태가 된다.  

```c
{ [constant-expression] = assignment-expression, }
```  

지정자가 여럿 있는 경우 더 작은 지정자가 앞에 와야할까? 그런 제약은 없기 때문에 다음과 같이 작성할 수도 있다.  

```c
int arr[10] = { [7] = 20, [2] = 10 };
```  

지정 이니셜라이저를 사용하는 경우에 배열의 길이를 지정하지 않으면 어떻게 될까? 이 전에 괄호 이니셜라이저를 사용하는 경우에는 배열의 길이를 생략할 수 있으며, 이 때 배열의 길이는 가장 큰 인덱스 + 1이 된다고 했다. 결국 배열의 길이를 생략하고 지정 이니셜라이저를 사용하면 지정자에는 아무 양의 정수를 쓸 수 있으며, 배열의 길이는 가장 큰 지정자 + 1이 된다. (+ 1을 하는 이유는 인덱스가 0부터 시작하기 때문이다.)  

```c
int arr[] = { [9] = 30, [2] = 10, [7] = 20 };   // 배열의 길이는 10, 가능한 인덱스는 0 ~ 9
```  

그러면 일반적인 초기화 방식과 지정 초기화를 섞어서 사용할 수 있을까? 이 또한 가능하다. 지정자 이 후에 일반 초기화 값이 오면, 지정자가 지정한 인덱스 다음 값부터 초기화를 수행한다.  

```c
int arr[10] = { 1, 2, [4] = 10, 11, 12, [8] = 20, 21 };     // 아래와 동일
int arr[10] = { 1, 2, 0, 0, 10, 11, 12, 0, 20, 21 };        // 위와 동일
```  

그렇다면 지정자로 인하여 초기화하려는 대상 객체의 중복이 발생하면 어떻게 될까? 즉, ```{ 1, 2, 3, [1] = 10, 11, 12 };``` 와 같은 상황은 어떻게 될까?  
얼핏 생각하면 오류이거나, 미정의 행위이거나, 미지정 행위같다고 생각할 수 있다. 하지만 표준에서는 앞쪽의 값을 무시하고 뒤쪽의 값을 사용하여 초기화하는 것을 보장한다.  

```c
int arr[10] = { 1, 2, [4] = 10, 11, 12, 13, [1] = 20, 21, 22, 23, 24, [9] = 30 };
```  

여태까지 설명을 잘 이해했다면 위 예시에서 배열의 값이 ```{ 1, 20, 21, 22, 23, 24, 12, 13, 0, 30 }``` 이 된다는 것을 알 수 있다.  
하지만 위와 같은 코드는 프로그래밍의 대전제인 가독성을 크게 해친다. 따라서 표준에서 이를 보장한다고 하더라도, 굳이 일반적인 초기화 방식과 지정 초기화 방식을 복잡하게 섞어서 사용하는 것은 지양하는 것이 좋다.  

### 배열 응용

배열을 응용하여 간단한 몇 가지 상황을 예시로 만들어보자.  

Q. 입력 받은 다섯 개의 정수 중 가장 큰 수를 구하는 코드를 작성하시오.  

```bash
# 입출력 예시
다섯 개의 정수를 입력하세요 : 101 24 123 -456 0
가장 큰 정수 : 123
```  

A.

다섯 개의 정수를 입력받을 정수를 선언하여 입력 받은 후, 배열을 순회하며 가장 큰 값을 찾아 별도의 변수에 저장할 것이다.  

```c
// max_integer.c
#include <stdio.h>
#include <limits.h>

int main(void)
{
    int arr[5];
    printf("다섯 개의 정수를 입력하세요 : ");
    for (int i = 0; i < 5; i++)
        scanf("%d", &arr[i]);   // 정수 입력
    
    int max = INT_MIN;      // 가장 작은 정수로 초기화
    for (int i = 0; i < 5; i++) {
        if (arr[i] > max) { // 배열의 값이 max 값보다 크다면
            max = arr[i];   // max 값을 배열의 값으로 갱신
        }
        // 해당 지점에서의 값을 고려
    }
    printf("가장 큰 정수 : %d\n", max);
    return 0;
}
```  

우선 크기 5의 int 타입 배열 arr를 선언했다. 그리고 각 요소(arr[i])의 주소(&)를 ```scanf``` 함수의 인자로 전달하여 다섯 개의 정수를 입력받아 배열에 저장하였다.  
그 다음 입력 받은 수 중 가장 큰 정수를 찾아내어 저장할 변수 max를 선언하고, 표현할 수 있는 가장 작은 수(INT_MIN)으로 초기화하였다. 가장 작은 수로 초기화해두는 이유는 max가 배열에 저장된 모든 수보다 큰 수로 초기화되면 안 되기 때문이다. 배열 중에 가장 큰 수를 찾는 과정을 이해하고 나면, 가장 작은 수로 초기화하는 이유를 더 확실히 이해할 수 있을 것이다.  
for문부터가 본격적인 가장 큰 수를 찾는 과정이다. i를 0부터 4까지 반복하여 배열의 모든 원소를 순회하게 한다. 순회하는 과정에서 배열의 원소가 max에 저장되어있는 수보다 크다면 max에 해당 원소의 값을 저장한다. 순회가 끝나면 max에는 배열의 원소 중 가장 큰 수가 저장되어 있다.  
입력 값을 예시로 하여 순회 별 마지막 문장(값을 고려한다는 주석이 있는 부분)에서의 값을 표현하면 다음과 같다.  

| i | arr[i] | max | 설명 |
|:---:|:---:|:---:|:---:|
| - | - | INT_MIN | for문 시작 전, max는 INT_MIN으로 초기화 |
| 0 | 101 | 101 | 101이 INT_MIN보다 크므로 max에 101 저장 |
| 1 | 24 | 101 | 24는 101보다 크지 않으므로 max는 변하지 않음 |
| 2 | 123 | 123 | 123은 101보다 크므로 max에 123 저장 |
| 3 | -456 | 123 | -456은 123보다 크지 않으므로 max는 변하지 않음 |
| 4 | 0 | 123 | 0은 123보다 크지 않으므로 max는 변하지 않음 |

이러한 과정을 거쳐서 max에는 입력받은 값(배열에 저장된 값) 중 가장 큰 값을 저장하게 된다. 그런데 만약 max가 배열에 있는 모든 값보다 큰 값으로 초기화된다면 어떻게 될까? 예를 들어 max를 0으로 초기화 하고, [ -1, -2, -3, -4, -5 ]를 입력받는 경우를 생각해보자.  
우리가 원하는 정답은 max에 -1이 저장되는 것이다. 하지만 위 과정에서 max는 0에서 -1로 변하지 않는다. 이러한 이유로 max는 처음에 INT_MIN으로 초기화하는 것이다. 사실 max를 INT_MIN이 아닌 배열의 0번 원소 값(arr[0])으로 초기화하고, 반복문을 0번 원소가 아닌 1번 원소부터 순회하는 것이 조금 더 효율적일 것이다.  

위 내용과 예제 코드에 대해 이해했다면 약간의 추가 상황을 가정해보자. 입력 받을 수를 다섯 개에서 열 개로 증가시키려면 코드의 어느 부분을 수정해야 할까?  
우선 배열의 크기를 10으로 수정하기 위해 선언을 ```int arr[10];``` 으로 고쳐야 한다. 그리고 두 개의 for문 모두 i가 0부터 9까지 반복할 수 있도록 ```for (int i = 0; i < 10; i++)``` 으로 제어식을 수정해야 한다. 이 중 하나라도 빼먹는다면 프로그램은 정상적으로 동작하지 않을 것이다.  

이런 상황에서 만약 코드 한 줄만 바꿔도 원하는 내용을 한번에 다 바꿔줄 수 있다면 굉장히 편리할 것이다. C언어에서 지원하는 매크로 기능을 사용하면 그러한 작업이 가능해진다. 매크로에 대한 내용은 전처리 지시자에서 자세히 학습할 것이므로, 지금은 당장 사용할 기능에 대해서만 간단하게 알아볼 것이다. 매크로는 다음과 같이 사용할 수 있다.  

```c
#define identifier replacement
```  

위와 같이 지시하면 컴파일러는 식별자를 만났을 때 대체자로 코드를 대체한다. 예시를 보면 굉장히 간단하다.  

```c
#define PI  3.14    // 이 후부터 PI 라는 식별자는 모두 3.14로 대체됨

double x = 3 * 2 * PI;  // 3 * 3.14 와 동일함
```  

이 매크로를 이용하여 배열의 크기(입력 받을 수의 크기)를 정의하면 위 예시 코드를 다음과 같이 바꿀 수 있다.  

```c
// max_integer.c
#include <stdio.h>
#include <limits.h>

#define INPUT_SIZE  5

int main(void)
{
    int arr[INPUT_SIZE];
    printf("%d 개의 정수를 입력하세요 : ", INPUT_SIZE);
    for (int i = 0; i < INPUT_SIZE; i++)
        scanf("%d", &arr[i]);   // 정수 입력
    
    int max = INT_MIN;      // 가장 작은 정수로 초기화
    for (int i = 0; i < INPUT_SIZE; i++) {
        if (arr[i] > max) { // 배열의 값이 max 값보다 크다면
            max = arr[i];   // max 값을 배열의 값으로 갱신
        }
        // 해당 지점에서의 값을 고려
    }
    printf("가장 큰 정수 : %d\n", max);
    return 0;
}
```  

매크로를 이용하여 INPUT_SIZE를 정의하였다. 이 후 배열의 크기, printf문의 인자, for 문의 제어 식에 있는 INPUT_SIZE는 모두 대체자(5)로 치환될 것이다.  
만약 입력 받을 수의 개수를 다섯 개에서 열 개로 수정하고자 한다면, 지시문만 ```#define INPUT_SIZE 10``` 으로 수정하면 원하는 결과를 얻을 수 있을 것이다.  

이처럼 매크로를 이용하면 좀 더 변경에 유연한 코드를 작성할 수 있다. 앞으로 예제 코드에서도 매크로를 종종 사용할 것이니 참고하자.  

Q. 배열에 다섯 개의 정수를 입력받고, 뒤집어서 저장하여 출력하시오.  

```bash
# 입출력 예시
5 개의 정수를 입력하세요 : 101 24 123 -456 0
뒤집은 정수 : 0 -456 123 24 101
```  

A. 

입력받은 배열의 첫 번째 요소와 마지막 요소, 두 번째 요소와 마지막에서 두 번째 요소, ..., N 번째 요소와 마지막에서 N 번째 요소를 교환한다.  

```c
// reverse_array.c
#include <stdio.h>

#define INPUT_SIZE  5

int main(void)
{
    int arr[INPUT_SIZE];
    printf("%d 개의 정수를 입력하세요 : ", INPUT_SIZE);
    for (int i = 0; i < INPUT_SIZE; i++)
        scanf("%d", &arr[i]);

    int temp;
    for (int i = 0; i < INPUT_SIZE / 2; i++) {      // 배열의 크기 / 2 만큼 반복
        // 앞에서 i번 요소와, 뒤에서 i번 요소를 교환
        // 앞에서 i번 요소는 arr[i]
        // 뒤에서 i번 요소는 arr[INPUT_SIZE - 1 - i]
        temp = arr[i];
        arr[i] = arr[INPUT_SIZE - 1 - i];
        arr[INPUT_SIZE - 1 - i] = temp;
    }
    
    printf("뒤집은 정수 : ");
    for (int i = 0; i < INPUT_SIZE; i++)
        printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
```  

배열 입출력에 관한 내용은 이미 충분히 학습하였고, 임시 변수를 이용한 변수 값의 교환은 4단원의 연습 문제에서 학습하였다. 여기에선 교환 과정에서 for 문의 제어식과 배열의 인덱싱에 대해 살펴볼 것이다. (변수 값의 교환 자체가 헷갈린다면 4단원 연습 문제를 다시 보고 오자.)  

배열의 크기를 반으로 나눠서 앞에서 N번째 요소와 뒤에서 N번째 요소를 교환하면 배열이 뒤집어진다. 배열의 크기가 4라면 인덱스 0 <-> 3, 1 <-> 2 를 교환하면 배열이 뒤집어진다. 배열의 크기가 5라면 인덱스 0 <-> 4, 1 <-> 3 을 교환하면 배열이 뒤집어진다. 인덱스 2는 중앙이 되는 인덱스이므로, 별도의 작업이 필요하지 않다. 결국 배열의 중앙을 중심으로 대칭을 이루며 교환을 수행하면 되는데, 배열의 크기가 짝수일 때와 홀수일 때가 조금 다른 모습을 띄게 된다. 그런데 배열의 크기가 홀수일 때 중앙에 있는 요소는 교환할 필요가 없다. 결국 다음 그림과 같이 중앙을 중심으로 좌측의 크기 / 2개(소숫점 내림)의 요소와 우측의 크기 / 2개의 요소를 교환하면 된다.  

![reverse](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/reverse.png?raw=true)  

이를 수행하기 위해 for 문의 제어식은 i가 0부터 (크기 / 2 - 1)까지 총 (크기 / 2)번 반복하도록 한다. 그리고 앞에서 i번 요소는 ```arr[i]```로 표현할 수 있으며, 뒤에서 i번 요소는 ```arr[INPUT_SIZE - 1 - i]```로 표현할 수 있다. 마지막 요소가 ```arr[INPUT_SIZE - 1]``` 이므로, 여기서 i씩 감소시키는 것이다. 뒤집기 전의 매 순회별 값을 표현하면 다음과 같다.  

| i | INPUT - 1 - i | arr[i] | arr[INPUT - 1 - i] |
|:---:|:---:|:---:|:---:|
| 0 | 4 | 101 | 0 |
| 1 | 3 | 24 | -456 |

INPUT_SIZE의 값을 수정해가며 반복문의 각 단계가 어떻게 변화할지 고려해보면 더욱 잘 이해할 수 있을 것이다.  

사실 해당 문제는 좀 더 직관적으로 해결할 수도 있다. 다음과 같이 여분의 배열을 하나 더 만들어서, 배열을 거꾸로 순회하며 저장할 수도 있다.  

```c
int arr1[INPUT_SIZE], arr2[INPUT_SIZE];
for (int i = 0; i < INPUT_SIZE; i++)
    arr2[i] = arr1[INPUT_SIZE - 1 - i];     // arr2에는 뒤집힌 배열이 저장됨
for (int i = 0; i < INPUT_SIZE; i++)
    arr1[i] = arr2[i];
```  

이런 방식은 문제를 좀 더 쉽게 해결할 수는 있지만, 추가적인 메모리 공간이 필요하고 INPUT_SIZE 만큼의 반복을 한번 더 하게 되는 단점이 있다.  

### 배열의 크기

여태까지 배열의 크기라고 하면 배열이 가지는 원소의 수를 의미하였다. 그렇다면 배열 객체가 메모리에서 차지하는 크기가 몇 바이트인지는 어떻게 알 수 있을까? 배열 원소의 타입 * 배열의 크기로 구할 수도 있겠지만, 훨씬 쉬운 방법이 있다. ```sizeof``` 연산자를 사용하는 것이다.  

집합(aggregate) 타입의 객체를 피연산자로 ```sizeof``` 연산을 수행하면 해당 객체로 인해 할당되는 메모리 전체의 크기를 반환한다. 그 대상이 배열 타입이라면 ```sizeof```의 결과는 해당 배열 타입이 차지하는 바이트 수가 된다. 예를 들어 다음과 같다.  

```c
// int가 4 bytes인 시스템으로 가정
char carr[50];
int iarr[30];

sizeof(carr);   // 50 bytes
sizeof(iarr);   // 120(30 * 4) bytes
```  

그러면 배열의 원소에 ```sizeof``` 연산을 수행하면 어떻게 될까? 해당 원소 타입의 크기를 반환한다. 예를 들어 다음과 같다.  

```c
// int가 4 bytes인 시스템으로 가정
char carr[50];
int iarr[30];

sizeof(carr[0]);   // 1 byte
sizeof(iarr[10]);   // 4 bytes
```  

그렇다면 이제 역으로 배열 객체와 배열 원소의 바이트 크기를 통해 배열의 크기를 구할 수 있다.  

```c
// 각 타입의 크기가 몇 바이트인지 무관
char carr[50];
int iarr[30];

(sizeof(carr) / sizeof(carr[0]));   // 50
(sizeof(iarr) / sizeof(iarr[0]));   // 30
```  

이와 같이 배열의 크기를 구하면, 다양한 상황에서 좀 더 유연한 코드를 작성할 수 있다.  

```c
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    printf("%d ", arr[i]);
```  

이러면 매크로를 사용했을 때와 유사하게 배열 arr의 크기를 수정하는 일이 생기더라도 그에 맞춰 배열의 크기를 계산하여 변경에 유연한 코드가 된다.  

그런데 ```i < sizeof(arr) / sizeof(arr[0])``` 이라는 코드에는 문제가 없을까? ```sizeof(arr[0])```은 언제나 작동하는 코드일까?  
배열의 크기는 항상 1 이상이라고 했으니, 0번 인덱스를 첨자하는 것은 문제가 없을 것이다. 하지만 배열이 초기화되지 않았다면 초기화하지 않은 변수를 사용한 것이 아닐까?  
정답은 ```sizeof``` 연산자 파트를 다시 읽어보면 알 수 있다. ```sizeof``` 연산자는 피연산자를 평가하지 않기 때문에, ```sizeof(arr[0])``` 라는 식은 실제로 arr의 0번째 원소에 접근하지는 않는다. 결국 ```sizeof(arr[0])```는 단순히 배열 원소의 타입이 갖는 크기를 컴파일 시간에 계산하기 때문에, 문제되지 않는다. 마찬가지로 배열 arr의 크기가 5일 때 ```arr[10];```는 미정의 행위이지만, ```sizeof(arr[10]);``` 는 문제 없는 코드가 된다. 따라서 ```sizeof(arr) / sizeof(arr[0])```는 항상 올바른 코드가 된다.  

그런데 ```i < sizeof(arr) / sizeof(arr[0])```는 컴파일러와 옵션에 문제의 소지가 될 수도 있다. ```sizeof``` 연산의 결과는 ```size_t``` 라는 타입을 갖는다. 해당 타입은 크기를 표현하기 위해 사용하는 부호 없는 정수 타입이다. 보통 ```unsigned int``` 타입이나 ```unsigned long```과 같은 타입을 재정의한 타입이다. 우선 ```unsigned long``` 타입이라고 가정해보자.  
그런데 위 식에서 변수 ```i```는 ```int``` 타입이었으므로 ```<``` 연산의 피연산자 타입이 동등하지 않게 되었다. C99 이후의 표준을 지키는 컴파일러라면 ```<``` 연산의 피연산자가 산술 타입일 경우 usual arithmetic conversions를 수행하기 때문에 암시적 형변환이 수행되어 문제가 되지 않지만, 이를 고의적으로 문제 삼는 컴파일러 옵션을 사용하거나 표준을 지키지 않는 컴파일러를 사용한다면 문제가 될 수 있다. 이럴 때는 변수 ```i```를 ```size_t``` 타입으로 선언하거나, 배열의 크기를 구하는 식에 ```(int)(sizeof(arr) / sizeof(arr[0]))```와 같이 명시적 형변환을 추가하는 방법으로 해결할 수 있다. 물론 대다수의 경우 문제가 되지 않기 때문에 크게 신경쓸 일은 없을 것이다.  

## 다차원 배열

여태까지 사용한 배열의 원소들은 ```char```나 ```int```와 같은 스칼라 타입을 가졌다. 그러면 배열에 대한 배열은 만들 수 없을까? 이 또한 가능하다. 다음과 같이 배열의 배열을 만들 수 있다.  

```c
int arr1[2][3];     // 크기 2 배열의 각 원소가 크기 3의 배열
int arr2[3][2];     // 크기 3 배열의 각 원소가 크기 2의 배열
```  

![multi](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/multi.png?raw=true)  

좌측의 점선 박스는 개념의 이해를 위해 표시한 가상의 배열이다. arr1은 우선 크기 2의 배열인데, 각 원소가 크기 3짜리 배열임을 볼 수 있다. 그렇게 우측에 메모리에 실제로 할당되는 크기 6(2 * 3)의 배열 객체를 볼 수 있다.  
이와 마찬가지로 arr2은 크기 3의 배열인데, 각 원소가 크기 2짜리 배열임을 볼 수 있다. 또한 우측에는 메모리에 실제로 할당되는 크기 6(3 * 2)의 배열 객체를 볼 수 있다.  
우리가 이 전 까지 학습한 배열은 단일 차원으로만 선형적으로 증가하여 일차원 배열이라고 이야기했는데, 위와 같이 배열의 배열은 행과 열을 갖는 두 차원으로 증가하여 이차원 배열이라고 한다.  

> 배열의 배열과 다차원 배열을 구분하는 언어도 존재하지만, C에서는 두 개념을 동일하게 취급한다. 구분하는 언어의 경우 보통 ```arr[i, j]``` 와 같은 다차원 인덱싱 문법을 지원하는데, C에서는 이러한 문법은 지원하지 않는다. (단순히 컴마 연산자로 인식하게 된다.) C에서는 다차원 배열 인덱싱을 ```arr[i][j]```와 같이 작성해야 한다.  

결국 이차원 배열은 행렬(matrix)로 표현할 수 있다. 예를 들어 ```int arr[3][5];``` 은 3행(row) 5열(column)짜리 행렬로 표현할 수 있다.  

![matrix](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/matrix.png?raw=true)  

인덱스의 혼동을 방지하기 위하여 0행과 0열부터 시작하였는데, 갯수로는 총 3개의 행과 5개의 열을 갖는 것을 볼 수 있다. 첨자 연산은 일차원 배열과 크게 다르지 않다. 박스 내에 보이는 것처럼, 0행 2열에 접근하려면 ```arr[0][2]``` 라고 첨자하면 되고, 2행 1열에 접근하려면 ```arr[2][1]``` 이라고 하면 된다. 범위를 벗어나면 미정의 행위인 것도 동일하다.  

그런데 하나 주의할 점이 있다. 이차원 배열이 개념적으로 이차원이라고 해서 메모리 상에 정말 이차원의 모양으로 할당되는 것은 아니다. 애초에 배열은 동일한 타입의 객체 여러 개를 연속된 메모리에 할당하는 타입이라고 하였다. 그리고 C에서 이차원 배열은 배열의 배열이라고 했으므로, 여러 개의 배열을 다시 연속된 메모리 할당하게 된다.  
```char arr[3][2];``` 는 크기 3짜리 배열인데, 각 원소가 크기 2짜리 배열이라고 하였다. 이를 다시 말하면 크기 2짜리 배열을 원소로 갖는 크기 3의 배열인 것이다.  
각 원소인 크기 2짜리 배열은, char 타입의 객체 두 개를 연속으로 할당한다. 그리고 크기 2의 배열 객체를 원소로 하는 크기 3의 배열은, 각 원소(크기 2의 배열) 세 개를 연속으로 할당한다. 결국 메모리에는 char 타입 객체 여섯 개가 연속으로 할당되는 것이다. 마찬가지로 ```int arr[3][5];``` 라고 선언한다면 메모리에 int 타입 객체 열다섯 개가 연속으로 할당된다.  

![linear](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/linear.png?raw=true)  

그러면 예제를 통해 이차원 배열의 간단한 사용 방법을 정리하도록 하자.  

```c
// two_dimension.c
#include <stdio.h>

#define N   5

int main(void)
{
    int arr[N][N];
    
    for (int row = 0; row < N; row++) {
        for (int col = 0; col < N; col++) {
            arr[row][col] = row + col;      // 행 값 + 열 값을 저장
        }
    }

    for (int row = 0; row < N; row++) {
        for (int col = 0; col < N; col++) {
            printf("%d ", arr[row][col]);   // 출력
        }
        printf("\n");
    }

    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ make two_dimension
cc     two_dimension.c   -o two_dimension
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ ./two_dimension 
0 1 2 3 4 
1 2 3 4 5 
2 3 4 5 6 
3 4 5 6 7 
4 5 6 7 8 
```  

### 다차원 배열의 선언과 초기화

이차원 배열을 통해 다차원 배열의 기본적인 배경을 알아보았다. C는 이차원 배열을 넘어서 원하는 차원의 다차원 배열을 지원한다. 다차원 배열의 선언은 다음과 같은 형태를 갖는다고 볼 수 있다.  

```c
type-specifier identifier[constant-expression][constant-expression]...[constant-expression];
```  

여기서 ```[constant-expression]```의 갯수 만큼의 차원을 갖는 배열이 만들어진다. 예를 들어 다음은 int 형 삼차원 배열의 선언이다.  

```c
int arr[2][3][4];
```  

위 배열은 int 객체 24개(2 * 3 * 4)를 메모리에 연속으로 저장한다. 해당 배열의 특정 원소에 접근하고 싶다면 ```arr[i][j][k];``` 와 같이 첨자하면 된다.  

그런데 이차원 배열은 행렬이라는 개념으로 충분히 시각적 인지가 가능했다. 삼차원 배열도 3차원 공간 좌표처럼 만들면 시각적 인지가 가능하다. 그런데 사차원부터는 사람이 인지할 수 있도록 시각적으로 표현이 어렵다. 사람의 인지 구조상 사실상 완전한 표현은 불가능하다. 따라서 굳이 다차원 배열을 시각화하여 개념적으로 이해할 필요는 없다. N차원 배열의 원소에 접근하기 위해서는 N번의 첨자를 해야한다고 직접 이해하거나, 배열의 배열이 중첩된 개념으로 이해하면 충분하다.  

![three](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B0%B0%EC%97%B4/three.png?raw=true)  

일차원 배열을 사용할 때마다 굳이 직선 블록을 생각하지 않았던 것처럼 다차원 배열도 익숙해지면 별도의 시각화 없이 이해할 수 있을 것이다.  

다차원 배열의 초기화도 마찬가지로 괄호 이니셜라이저를 사용한다. 위에서 초기화 파트를 학습하였다면, 다음과 같이 선언하였을 때 각 원소가 어떤 값으로 초기화되는지 예측할 수 있을 것이다.  

```c
int arr[2][3] = { 1, 2, 3, 4 };

// arr[0][0] == 1
// arr[0][1] == 2
// arr[0][2] == 3
// arr[1][0] == 4
// arr[1][1] == 0
// arr[1][2] == 0
```  

앞에 네 원소는 차례대로 1, 2, 3, 4로 초기화되고, 나머지 두 원소는 0으로 초기화된다. 그런데 초기화하려는 원소를 각 행 별로 지정할 수는 없을까? 위의 경우에서 0행 앞의 두 원소를 1, 2로 초기화하고 1행 앞의 두 원소를 3, 4로 초기화하려면 어떻게 해야할까? 위에서 학습한 내용에 의하면 지정 초기화를 통해 수행할 수 있다. 하지만 다차원 배열의 경우 다음과 같이 중첩된 괄호 이니셜라이저를 통해 초기화하려는 값들의 차원을 지정할 수 있다.  

```c
int arr[2][3] = {
    { 1, 2 },       // 컴마 구두점 주의
    { 3, 4 }
};

// arr[0][0] == 1
// arr[0][1] == 2
// arr[0][2] == 0
// arr[1][0] == 3
// arr[1][1] == 4
// arr[1][2] == 0
```  

그러면 다음과 같은 경우 어떻게 동작할까?  

```c
int arr[2][3] = {
    { 1, 2, 3, 4 },     // 3개 초과
    { 5 }
};
```  

위 초기화에서 0행은 1, 2, 3으로 초기화되고, 1행은 4, 5, 0으로 초기화되지 않을까 싶기도 하다. 하지만 중첩 괄호 초기화의 경우 지정한 차원에 맞춰 초기화를 수행한다. 따라서 ```{1, 2, 3, 4}```가 0행에 대한 초기화로 지정이 되어, 사실상 ```int a[3] = { 1, 2, 3, 4 };```와 같은 구문이 된다. 결국 이 전에 학습한 것과 같이 배열의 길이를 초과하여 미정의 행위가 되므로, 초기화 시 주의해야 한다.

그리고 이러한 경우엔 어떻게 동작할까?

```c
int arr[4][3][2] = {
    { 1 },
    { 2, 3 },
    { 4, 5, 6 }
};
```  

얼핏 보면 ```{ 4, 5, 6 }```이 마지막 차원의 길이 2를 초과한 것처럼 보인다. 하지만 중첩 괄호는 각 차원에 차례대로 대응하기 때문에, 가장 밖에 있는 괄호는 길이 4의 첫번째 차원에 대응하고 그 안의 괄호는 길이 3의 두 번째 차원에 대응한다. 따라서 위 초기화는 결국 다음과 동일하다.  

```c
int arr[4][3][2] = {
    {
        { 1, 0 },
        { 0, 0 },
        { 0, 0 }
    },
    {
        { 2, 3 },
        { 0, 0 },
        { 0, 0 }
    },
    {
        { 4, 5 },
        { 6, 0 },
        { 0, 0 }
    },
    {
        { 0, 0 },
        { 0, 0 },
        { 0, 0 }
    }
};
```  

이처럼 보면 알겠지만, 다차원 배열의 초기화의 경우 중첩 괄호를 헷갈리지 않도록 완전히 지정된 형태로 만들어 주는 것이 좋다. 위 초기화의 경우 최소한 다음과 같이 지정해야 혼동을 방지할 수 있다.  

```c
int arr[4][3][2] = {
    {
        { 1 },
    },
    {
        { 2, 3 },
    },
    {
        { 4, 5 },
        { 6 },
    }
};
```  

이 외에도 앞서 말한 것과 같이 다차원 배열 또한 다음과 같이 지정 초기화가 가능하다.  

```c
int arr[2][2] = { [0][0] = 1, [1][1] = 2 };         // [0][0] 원소와 [1][1] 원소 지정
int arr[2][2] = { [1] = { 2, 3 }, [0] = { 1 } };    // 1행과 0행 지정
```  

지정 규칙은 이 전과 동일하다.  
어떤 초기화를 사용하던 간에, 한 가지만 명심하면 된다. 해석하는데에 있어 혼란을 주면 안 된다. 일차원 배열이든, 다차원 배열이든 선언과 초기화 시 그 내용을 명확히 알 수 있도록 해야 한다는 것을 명심하자.  

### 다차원 배열의 크기

다차원 배열에 ```sizeof``` 연산을 수행하면 어떤 결과를 볼 수 있을까? 배열의 배열을 생각하면 어렵지 않게 추론할 수 있다. 간단한 예제를 통해 결과를 확인해보자.  

```c
// multi_size.c
#include <stdio.h>

int main(void)
{
    char arr[2][3][4];

    printf("sizeof arr : %ld\n", sizeof(arr));
    printf("sizeof arr[0] : %ld\n", sizeof(arr[0]));
    printf("sizeof arr[0][0] : %ld\n", sizeof(arr[0][0]));
    return 0;
}
```  

결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ make multi_size
cc     multi_size.c   -o multi_size
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ ./multi_size 
sizeof arr : 24
sizeof arr[0] : 12
sizeof arr[0][0] : 4
```  

첨자하는 차원에 해당하는 배열 객체의 크기를 결과로 반환한다.  

그런데 전에 배열을 선언할 때 크기를 생략하면 괄호 이니셜라이저의 원소 수가 배열의 크기가 된다고 하였다. 그러면 다음과 같이 생략할 수 있을까?  

```c
int arr[][] = { 1, 2, 3, 4 };
```  

이렇게는 불가능하다. 해당 배열이 ```int arr[2][2];```가 될 지, ```int arr[4][1];```이 될 지, ```int arr[1][4];```가 될 지 알 수 없다. 그러면 다음과 같은 형태는 가능할까?

```c
int arr[][] = { { 1, 2 }, { 3, 4 } };
```  

얼핏 보면 가능할 것 같지만 이러한 기능은 지원하지 않는다. 다차원 배열의 선언에서는 가장 부모가 되는 한 차원의 크기만 생략이 가능하다. 예를 들어 다음과 같은 선언은 가능하다.  

```c
int arr1[][2] = { 1, 2, 3, 4 };
int arr2[][2] = { { 1, 2 }, { 3, 4 } };
```  

왜 가장 부모 차원만 생략이 가능한걸까? 다음과 같은 상황을 생각해보면 된다.  

```c
int arr1[][2] = { 1, 2, 3, };       // OK
// arr1[0][0] == 1
// arr1[0][1] == 2
// arr1[1][0] == 3
// arr1[1][1] == 0
int arr2[2][] = { 1, 2, 3, };       // NO
// ??
```  

arr1의 경우 배열의 크기와 각 원소를 어떻게 지정해야할지 명확하다. 하지만 arr2의 경우 적절한 크기를 지정할 수 없다. ```int arr2[2][2] = { 1, 2, 3, };```와 같이 지정할 수도 있고, ```int arr2[2][3] = { 1, 2, 3, };```와 같이 지정할 수도 있다. 따라서 다차원 배열의 초기화에서는 가장 부모 차원의 크기만 생략이 가능하다.  

간단한 예시 문제를 통해 여태까지 배운 내용을 정리해보자.  

Q. 이차원 배열 score에는 학생들의 시험 점수들이 저장되어 있다. 행은 학생을, 열은 과목을 나타낸다. 각 학생 별 점수 평균과, 과목 별 점수 평균을 구하여라.

```c
// 주어진 score 배열
const int score[5][5] = {
    { 65, 90, 80, 70, 75 },
    { 80, 70, 75, 90, 65 },
    { 95, 55, 70, 80, 90 },
    { 70, 100, 90, 95, 75 },
    { 90, 80, 70, 60, 50 }
};
```

A.

```c
// exam_average.c
#include <stdio.h>

int main(void)
{
    const int score[5][5] = {
        { 65, 90, 80, 70, 75 },
        { 80, 70, 75, 90, 65 },
        { 95, 55, 70, 80, 90 },
        { 70, 100, 90, 95, 75 },
        { 90, 80, 70, 60, 50 }
    };

    int student_sum[5] = { 0, };
    int subject_sum[5] = { 0, };

    for (int i = 0; i < sizeof(score) / sizeof(score[0]); i++) {
        for (int j = 0; j < sizeof(score[0]) / sizeof(score[0][0]); j++) {
            student_sum[i] += score[i][j];      // 학생 별 점수 합산
            subject_sum[i] += score[j][i];      // 과목 별 점수 합산
        }
    }

    for (int i = 0; i < sizeof(student_sum) / sizeof(student_sum[0]); i++) {
        printf("학생%d 평균 : %f\n", i, (double)student_sum[i] / 5);
    }

    for (int i = 0; i < sizeof(subject_sum) / sizeof(subject_sum[0]); i++) {
        printf("과목%d 평균 : %f\n", i, (double)subject_sum[i] / 5);
    }
    
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ make exam_average
cc     exam_average.c   -o exam_average
pr0gr4m@DESKTOP-IRB9MN5:~/src/array$ ./exam_average 
학생0 평균 : 76.000000
학생1 평균 : 76.000000
학생2 평균 : 78.000000
학생3 평균 : 86.000000
학생4 평균 : 70.000000
과목0 평균 : 80.000000
과목1 평균 : 79.000000
과목2 평균 : 77.000000
과목3 평균 : 79.000000
과목4 평균 : 71.000000
```  

score 배열을 선언할 때 const 한정자를 추가하였다. 배열의 선언 또한 기본적인 선언의 형태를 그대로 가지므로, 타입 지정자 전에 타입 한정자가 올 수 있다. 위와 같이 선언한 배열은 각 원소들이 const 객체가 되어 그 내용을 수정할 수 없게 된다.  

이 후 코드를 보면, 학생 별 점수를 누산할 배열과 과목 별 점수를 누산할 배열을 선언하고 0으로 초기화하였다. 이 후 이차원 배열을 순회하여 점수를 합산하는데, ```j```가 증가함에 따라 ```score[i][j]```는 i행 학생의 점수를 순회하고, ```score[j][i]```는 i열 과목의 점수를 순회하게 된다. 순회하며 접근한 값들을 누산할 배열에 더하고, 최종적으로 학생 및 과목의 수로 나눠서 출력하였다.  
그런데 위 답안에서 몇 가지 애매한 부분이 있다. 만약 학생 수나 과목 수에 변동이 생기면 어느 부분들을 고쳐야 할까? 반복문의 제어식은 문제 없지만, 배열의 선언과 평균 계산 시 나누는 제수는 계속 변할 것이다. 해당 부분을 고쳐보도록 하자.  

## 가변 길이 배열

여태까지 배열을 선언할 때 크기를 지정하기 위하여 ```[constant-expression]```와 같이 상수 식을 사용하였다. 그런데 표준에서 지정한 배열의 선언자는 사실 ```direct-declarator[type-qualifier-list_opt assignment-expression_opt]```이다. 해석하기 어려우니 몇 가지 변환과 생략을 거쳐 알아보기 쉽게 변경하자면 ```identifier[assignment-expression]```이 된다. 즉, 상수 식이 아니라 결과가 0 초과의 정수이기만 하다면 컴마 연산자를 제외한 연산 식을 사용할 수 있다. 다시 말해 크기 지정에 다음과 같이 변수를 사용할 수 있다는 것이다.  

```c
int arr[n + 3];
```  

이러면 배열의 크기를 원하는 대로 입력받아서 선언할 수 있는 것일까? 예를 들어 다음과 같은 코드가 가능할까?

```c
int main(void)
{ 
    int n;
    scanf("%d", &n);
    int arr[n];
    // ...
    return 0;
}
```  

C99 표준부터는 이와 같이 배열의 크기를 지정하는 곳에 변수를 사용하여 크기를 동적으로 지정할 수 있는 가변 길이 배열(Variable-Length Array)를 지원한다.  
간혹가다가 스택 영역을 컴파일 시점에 크기가 정적으로 정해지는 영역으로 오해하여 위와 같은 구현이 불가능한 것으로 착각하는 경우가 있다. 하지만 실상은 추후에 다시 이야기하겠지만, 데이터 영역같은 곳이 정적으로 할당되는 영역이고 스택 영역은 동적으로 할당된다. 추후에 학습할 동적 메모리 할당과 대비되어 스택 영역을 정적 할당으로 착각할 수 있지만, 정적 할당이 아닌 동적 할당 중 자동 할당 영역이다. 따라서 해당 영역에 있는 배열의 크기를 지정하는 곳에 변수가 있다고 하더라도, 해당 값만큼 스택 포인터를 움직이기만 하면 얼마든지 구현 가능하다.  

하지만 가변 길이 배열의 문제는 다른 곳에 있다. 우선 C99부터 표준에 도입되기는 하였지만, 여러가지 논란으로 인해 C11 표준 이후부터는 선택 구현으로 변경되었다. 따라서 특정 환경에서는 가변 길이 배열을 지원하지 않을 수도 있다. (예를 들어 윈도우에서 Visual Studio를 사용하면 가변 길이 배열을 지원하지 않는다.)  
또한 가변 길이 배열로 인하여 표준 문법의 복잡성이 증가하고 예외 상황이 발생한다. 예를 들어 ```sizeof``` 연산의 경우 피연산자를 평가하지 않는다고 하였다. 그런데 만약 피연산자가 가변 길이 배열인 경우, 평가하지 않고 어떻게 객체의 크기를 계산할 수 있을까? 불가능하기 때문에 예외적으로 ```sizeof``` 연산의 피연산자가 가변 길이 배열일 경우 평가를 진행한다. 이런 식으로 다양한 상황에서 문법의 예외 상황이 발생하여 일관성이 깨지고 복잡성이 증가한다. 표준 버전 별로 모든 문법 상황을 암기한다면 문제 없겠지만, 그렇게 사용하기는 어려울 것이다.  

이렇게 이식성과 복잡성의 문제로 가변 길이 배열은 이점보다 단점을 많이 갖게 된다. 따라서 편리해보이더라도 사용을 지양할 것을 권장한다. 만약 크기를 동적으로 할당하고 싶다면 가변 길이 배열보다는 추후에 학습할 동적 메모리 할당을 사용할 것을 추천한다.  

Q. 가변 길이 배열을 전역 변수로 사용할 수 있을까? 