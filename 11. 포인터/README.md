# 포인터

포인터는 C언어 학습 시 가장 어려운 기능으로 자주 불릴 만큼 괴담이 많다. 사실 여태까지 학습해온 내용들 (특히 3, 4, 9 단원)을 잘 이해하고 있다면 그다지 어렵지 않은데, 기존 개념들에 대한 잘못된 이해가 포인터를 이해하는데 방해를 유발한다. 만약 해당 서적의 앞 내용들을 잘 이해했다면, 포인터에 대한 이해는 악명만큼 어렵지 않을 것이므로, 너무 겁먹을 필요는 없다.  
단, 포인터는 C언어에 있어 굉장히 중요한 기능이며 사용 케이스가 방대하기 때문에 학습에 있어 집중을 요하는 것은 맞다. 포인터는 C언어의 여러 다른 기능과 혼합하여 사용하기 때문에 한 단원에서 모든 내용을 다룰 수는 없다. 따라서 해당 단원에서는 기본적인 기능에 중점을 맞추고, 여러 단원을 거쳐가며 마저 학습할 것이다.  

## 포인터 기초

포인터는 **참조하는 타입 정보를 가지고 주소를 저장하는 객체**다. 앞으로 해당 문장에 대해 이해할 수 있도록 설명할테니, 한 줄을 외워두도록 하자.  

우리는 여태까지 다양한 타입과 객체들을 다뤘다. ```int``` 타입의 객체 중, 값을 유동적으로 저장할 수 있는 임시 저장소를 ```int``` 타입 변수라고 했다. ```"Hello World"``` 와 같은 문자열이 메모리 상에 존재하고 있으면 이를 문자열 객체라고 하였다. 그 외에도 const 객체나 배열 객체 같은 것들도 알아보았다.  

이렇게 객체들은 메모리상에 어떤 식으로 저장되고 해석되어야 할지를 결정하는 타입 정보를 갖는다. 프로그램에서 다루는 데이터들은 결국 메모리에 이진수로 나열되어있을 뿐이고, 이들을 나눠서 특정한 방식으로 해석하여 사용하는 것이다.  

그리고 이러한 객체들은 메모리의 어느 위치에 저장되어있는지를 판단하기 위한 주소를 갖는다. 만약 주소가 없다면 변수 a를 메모리에서 찾으려고 할 때 a가 어디에 저장되어 있는지 알 수 없을 것이다. 이 주소는 0부터 시작하는 정수 값이다.  
9단원에서 학습한 것과 같이 현대 대부분 컴퓨터 시스템의 OS 상에서 동작하는 프로그램은 가상 메모리를 바라보고, 추후 물리 메모리로는 OS와 하드웨어들이 특정한 규칙들에 맞춰 매핑해줄 것이다. 어느 경우에는 물리 메모리 주소를 직접 바라보는 특수한 소프트웨어를 작성하는 경우도 있을 것이다. 이러한 내용들을 굳이 다 고려할 필요는 없고, 메모리 상에 데이터들이 주소 값을 가지고 특정한 표현 방식으로 저장된다고 생각하면 된다.  

![object](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%8F%AC%EC%9D%B8%ED%84%B0/object.png?raw=true)

메모리에 위 그림처럼 데이터들이 저장되어 있을 때, 실제로 어떤 값을 의미하는지는 알 수 없다. 8바이트 짜리 정수일까? 혹은 실수일까? 아니면 1바이트 짜리 정수 여덟 개일까? 만약 1바이트 정수 여러 개라면 부호가 있을까 없을까? 경우에 따라 모두 다른 값으로 해석할 수 있다.  
부호 없는 1바이트 정수 여덟 개라면 다음과 같은 값들이 된다. ```0x88 0xa9 0xcb 0xed 0x78 0x56 0x34 0x12```  
부호 있는 4바이트 정수 두 개라면 다음과 같은 값들이 된다. ```-0x12345678 0x12345678```  
부호 있는 8바이트 정수 하나라면 다음과 같은 값이 된다. ```0x12345678edcba988```  
4바이트 정수와 8바이트 정수가 본인이 해석한 값이랑 다른 것 같다면 9단원에서 학습한 리틀 엔디안을 상기하자.  
그런데 과연 이렇게 해석한 값이 올바를까? 알고보니 0x1000, 0x1001, 0x1006, 0x1007 번지에 있는 값들은 의미 없는 값이고, 0x1002번지부터 4바이트 정수 하나가 저장되어 있을 수도 있다. 그렇다면 ```0x5678edcb``` 가 될 것이다.  

이처럼 데이터는 **어느 주소부터 어느 주소까지 어떤 방식으로** 저장되고 해석할지가 중요하다. 여태까지 우리는 C언어와 컴퓨터 시스템을 통해서 이러한 과정을 신경쓰지 않고 객체와 데이터를 사용해온 것이다.  

```int a = 123;``` 이라는 코드를 다시 생각해보자. int가 4바이트인 리틀 엔디안 시스템이라고 가정한다.  
그러면 변수 a는 메모리의 어떠한 주소(ex. 0x1000)에 4바이트만큼 할당(ex. 0x1000 ~ 0x1003)하여 123이라는 값을 부호 있는 4바이트 정수 방식으로 리틀 엔디안에 맞춰 저장할 것이다. 이 후에 ```a + 3``` 와 같이 a에 접근한다면, 할당된 주소(0x1000)로부터 4바이트의 부호 있는 정수 값으로 저장된 데이터를 해석할 것이다. 이것이 여태까지 우리가 데이터와 객체를 사용해온 방식이다.   

여기까지 이해했다면 포인터는 간단하다. 포인터는 여태까지 이야기해온 0x1000 번지와 같은 메모리의 주소 값을 저장하는 객체다. 그런데 주소 값만으로는 의미가 없으니, 해당 주소에 있는 내용을 어떻게 해석할지에 대한 타입 정보를 갖는다. 이를 참조 타입(referenced type)이라고 한다. 포인터는 다음과 같이 선언할 수 있다.  

```c
type-qualifier_opt type-specifier * type-qualifier_opt identifier;
```  

물론 위 내용 또한 선언의 기본 형태인 ```<declaration-specifiers> <init-declarator-list>;```로부터 전개된 내용이다. 우선 옵션인 타입 한정자를 제외하여 예시를 들면 다음과 같다.  

```c
int *p;
unsigned char *q;
double *r;
```  

위와 같이 선언된 p를 포인터 혹은 포인터 객체라고 한다. 해당 경우에는 객체가 변수이므로, 포인터 변수라고도 한다. 포인터 p에는 주소 값을 저장할 수 있고, int 타입을 참조 타입으로 갖는다. 마찬가지로 q와 r 또한 각각 unsigned char 타입과 double 타입을 참조하여 주소 값을 저장하는 포인터이다. 또한 이들을 더 특정하여 각각 int 포인터, unsigned char 포인터, double 포인터라고도 한다. 원어로는 pointer to int, pointer to unsigned char, pointer to double 이라고 한다.  
참고로 모든 타입이 참조 타입이 될 수 있다. 배열 타입을 포함해서 여태까지 배운 모든 타입과, 앞으로 배우게 될 다른 타입들도 모두 포인터의 참조 타입이 될 수 있다. 물론 포인터 타입 또한 참조 타입이 될 수 있다.  

포인터 선언 시 사용하는 ```*```는 이 후에 알아볼 간접 접근 연산자가 아닌 것에 주의해야 한다. 이는 연산자가 아니라 단순히 선언상의 구두점이다. 선언에서의 구두점과 식에서의 연산자를 혼동은 포인터에 대한 오해를 불러일으킬 수 있다.  
포인터 선언에서 구두점 ```*``` 전후에 화이트 스페이스는 0개 이상이 올 수 있다. 다음 선언들은 모두 동일한 선언이다.  

```c
int*p;      // 1번
int *p;     // 2번
int* p;     // 3번
int * p;    // 4번
int    *
p;          // 5번
```  

어느 선언 방식이 가장 좋아보이는가? 일단 5번은 말도 안되고, 1번은 헷갈리니 선택지는 2, 3, 4번이다. 이는 본인이 수행하는 프로젝트의 규칙에 맞춰서 통일하면 된다.  
2번은 객체가 포인터라는 것을 강조할 수 있고, 3번은 타입이 포인터 타입이라는 것을 강조할 수 있다. 4번은 표기상 일관성있어 보일 수 있다. 일반적으로 C언어에서는 2번을, C++언어에서는 3번을 사용한다. 해당 서적에서는 2번을 사용할 것이다. 그 이유로 다음과 같은 상황을 살펴보자.  

```c
int* a, b;
```  

위 선언에서 a와 b 모두 포인터처럼 보이지만, 사실 a만 포인터이고 b는 평범한 int 타입 변수다. 어째서일까? 이유는 조금 복잡한데 ```<declaration-specifiers> <init-declarator-list>;``` 로부터 전개되는 내용을 살펴봐야 한다. 아래 내용이 어렵다면 단순히 규칙으로 암기하고 넘어가도 무방하다.  
declaration-specifiers에는 타입 한정자나 타입 지정자같은 것들이 포함된다. 즉, ```int``` 라는 타입 지정자는 declaration-specifiers에 포함되는 내용이다. 반면 init-declarator-list는 쉼표로 구분되는 여러 선언자(declarator)가 될 수 있다. 즉 위 선언에서 ```* a, b```는 init-declarator-list에 포함된다. 그리고 선언자에는 단순히 식별자가 올 수도 있지만, 그 앞에 포인터 구두점이 올 수도 있고, 배열 선언자같은 것이 올 수도 있다. 결국 ```* a```와 ```b```가 각각 별도의 선언자이며 두 선언자가 쉼표 구두점으로 묶여서 선언자 리스트를 이룬 것이다.  
정리하자면 위 선언에서 ```int```는 타입 지정자, ```* a```는 하나의 선언자, ```b```도 하나의 선언자이다. ```* a```와 ```b```는 각각 별도의 선언자이므로 b는 포인터와 관계 없고, 그저 그 앞에 있는 타입 지정자의 영향을 받아 int 타입의 객체가 된다.  
결국 2번처럼 객체가 포인터라는 것을 강조한다면 이와 같은 규칙을 좀 더 자연스럽게 받아들일 수 있을 것이다.  
```c
int *a, b;      // int는 타입 지정자, *a는 하나의 선언자, b 또한 하나의 선언자 -> a는 int 포인터 객체, b는 int 객체
```  

위 내용을 이해했다면 아래의 선언에서 각각이 어떤 타입을 갖는지 구분할 수 있을 것이다.  

```c
int *a, b[10], c, d, e[20], *f;
```  

a와 f는 int 포인터 객체, b와 e는 int 배열 객체, c와 d는 int 객체임을 알 수 있다.  

## 주소 연산과 간접 접근 연산

C언어에는 주로 포인터와 함께 사용하기 위한 두 가지 단항 연산자가 있다. 주소(address) 연산자와 간접 접근(indirection) 연산자다. 주소 연산자는 ```&``` 기호를 사용하고, 간접 접근 연산자는 ```*``` 기호를 사용한다. 두 연산자에 대해 살펴보자.  

### 주소 연산자

주소(address) 연산자 ```&```는 피연산자의 주소 값을 결과로 반환한다. 피연산자로 다양한 객체가 올 수 있는데, 올 수 없는 경우들은 추후에 천천히 알아볼 것이다. 다음과 같이 사용하면 변수 a의 주소를 구할 수 있다.  

```c
int a;      // 변수 a 선언
printf("%p\n", &a);     // 변수 a의 주소를 출력함
```  

주소 연산자의 피연산자가 T 타입이라면, 그 결과 타입은 T 포인터(pointer to T)다. 위 예시에서 ```&a```의 결과는 변수 a가 저장된 주소이며, 결과 타입은 int 포인터다.  
이제 우리는 선언했던 포인터가 특정한 주소를 참조할 수 있게 되었다.  

```c
int a = 1, *p;      // a는 int 객체, p는 int 포인터 객체
p = &a;         // 포인터 변수 p에 변수 a의 주소를 저장함, 참조 타입은 int
```  

위와 같은 상황을 흔히 다음과 같은 그림으로 표현한다.  

![reference](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%8F%AC%EC%9D%B8%ED%84%B0/reference.png?raw=true)  

각 변수의 주소(0x1000, 0x1004)는 임의로 지정한 것으로 실제로 해당 순서로 연속 할당되지 않을 수 있으니 주소 변위에 대해서는 신경쓰지 않기를 바란다. 포인터 변수 내에 변수 a의 주소 값이 저장되어, 포인터 p가 변수 a를 가리키고 있는 현상에 집중하면 된다.  
이와 같이 포인터가 특정한 객체를 가리키는 경우 참조한다고도 이야기한다. 위 상황에서는 포인터 p가 변수 a를 가리킨다(point)고 하거나 참조한다(reference)고 한다.  
그리고 포인터의 선언도 물론 다음과 같이 초기화를 동반할 수 있다.  

```c
int a = 1;
int *p = &a;    // p가 a를 가리킴/참조함
```  

위 선언에서 다시 이야기 하지만, ```*```와 ```=```는 연산자가 아니고 선언상의 구두점이다. ```&```만 연산자이다.  

### 간접 접근 연산자

간접 접근(indirect) 연산자 ```*```는 피연산자에 간접적으로 접근한다. 피연산자로는 포인터 타입만 올 수 있다. 피연산자가 T 포인터(pointer to T)타입이라면, 연산 결과는 T 타입이다.  
간접 접근이라는 단어가 잘 와닿지 않을 수도 있는데, 참조하는 객체에 접근한다고 생각하면 된다. 예를 들어 다음과 같이 사용한다.  

```c
int a = 1;
int *p = &a;

*p;     // 포인터 p가 참조하던 a에 접근함, 결과는 1
```  

간접 접근 연산자의 결과는 참조하는 객체에 대한 별칭(alias)이 된다. 위 예시에서 ```*p```는 ```a```와 동등해진다. 다시 말해 ```*p = 3```라는 식은 참조하는 객체 a의 값을 실제로 변경시킨다. ```*p```가 ```a```의 별칭처럼 동작하게 된다.  

![alias](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%8F%AC%EC%9D%B8%ED%84%B0/alias.png?raw=true)  

그런데 왜 이름이 접근(access) 연산자가 아니라 간접 접근(indirection) 연산자일까? 우리가 객체가 접근하는 방식을 생각해보자.  

```c
int a = 1;      // 변수 a가 0x1000 번지에 할당되었다고 가정
int *p = &a;    // 포인터 변수 p가 0x1004 번지에 할당되었다고 가정

a + 3;      // a에 접근하여 저장되어 있던 값을 읽음 (read)
a = 3;      // a에 접근하여 새로운 값을 저장 (modify)
```  

접근한다는 것은 **객체에 있는 값을 읽거나 새로운 값으로 수정하는 것**을 의미한다. 전에 계속 언급한 것과 같이 객체에 접근하기 위해서는 객체가 저장된 메모리 주소를 찾아가서 지정된 타입에 맞춰 해석해야 한다.  
```a + 3```은 객체 a가 저장되어 있던 주소(0x1000 번지)에 접근하여 int 타입에 맞춰 저장되어 있던 값을 읽는다. 그 결과 1이라는 값을 얻고, 최종적으로 1 + 3을 수행하여 4라는 결과를 만들어낸다.  
```a = 3```은 객체 a가 저장되어 있던 주소(0x1000 번지)에 접근하여 int 타입에 맞춰 새로운 값 3을 저장한다. (3으로 수정한다.)  

그렇다면 간접 접근은 어떤 차이가 있을까?

```c
int a = 1;      // 변수 a가 0x1000 번지에 할당되었다고 가정
int *p = &a;    // 포인터 변수 p가 0x1004 번지에 할당되었다고 가정 

*p + 3;     // a에 간접 접근하여 저장되어 있던 값을 읽음 (read)
*p = 3;     // a에 간접 접근하여 새로운 값을 저장 (modify)
```  

결국 포인터 객체도 접근하여 그 값을 읽어야 한다. 포인터 객체 내에는 주소 값이 저장되어 있으며, 간접 접근 시 해당 주소를 찾아간다. 찾아간 주소를 참조하고 있는 타입에 맞춰 해석하여 사용하는 것이다.  
```*p + 3```은 우선 포인터 객체가 저장되어 있던 주소(0x1004 번지)에 접근하여 그 값을 읽는다. 읽은 값(0x1000)을 주소로 해석하고, 다시 해당 주소로 접근하여 참조하고 있는 int 타입에 맞춰 저장되어 있는 값을 읽는다. 그 결과 1이라는 값을 얻고, 최종적으로 1 + 3을 수행한다.  
```*p = 3```도 우선 포인터 객체가 저장되어 있던 주소(0x1004 번지)에 접근하여 그 값을 읽는다. 읽은 값(0x1000)을 주소로 해석하고, 다시 해당 주소로 접근하여 참조하고 있는 int 타입에 맞춰 새로운 값 3을 저장한다. 그 결과 변수 a의 값은 3으로 수정된다.  

이처럼 간접 접근의 결과는 참조하고 있던 객체와 동등하지만 동일하게 동작하지는 않는다. 참조하고 있던 객체에 접근하기 위하여 포인터 객체를 한 번 거쳐서 접근하므로 간접 접근이라고 부른다. 간접 접근을 참조의 반대라고 하여 역참조(dereference)라고도 한다.  

> 표준에서 역참조(dereferencing)라는 용어를 사용하기도 하지만, 공식적인 용어는 간접 접근(indirection)이다. 역참조라는 용어는 좀 더 다양한 프로그래밍 언어에서 범용적으로 사용한다. 간접 접근이라는 용어를 주로 사용하되, 역참조 또한 같은 의미로 생각하면 된다.  

그런데 만약 유효하지 않은 값을 참조하고 있는 포인터에 대해 간접 접근을 수행하면 어떻게 될까? 이는 C언어에서 가장 유명한 미정의 행위이다. 예를 들어 다음과 같은 상황들을 생각해보자.  

```c
// case 1
int *p;
*p + 3;
*p = 3;

// case 2
int *p = 0x1000;
*p + 3;
*p = 3;
```  

1번 케이스에서는 포인터가 참조하고 있는 객체가 없다. (0이나 쓰레기 값으로 초기화 될 것으로 예상할 수는 있다.) 2번 케이스에서는 0x1000 이라는 임의의 값을 참조하게 만들었다. 해당 주소가 무엇을 위해 할당된 주소일지 알 수 없다. 어찌되었든 둘 다 유효한 객체를 참조하고 있지 않다. 결국 유효하지 않은 주소에 접근하여 임의로 값을 읽고 수정하려고 하는 행위이며, 이는 굉장히 위험한 행위이다. 만약 프로그램이 사용하던 중요한 데이터가 저장되어있던 주소를 덮어씌우게 된다면 동작에 큰 차질이 생길 것이다. 따라서 현대의 시스템에서는 이러한 행위가 감지되면 명령이 수행되지 않고 에러를 발생하도록 보호하고 있다. 그렇다면 현대 시스템에서는 보호 동작 덕분에 항상 안전하게 사용한 것일까? 안타깝게도 그렇지는 않다. 프로그램 오동작부터 보안 문제까지 여러가지 문제를 야기하는 중대한 미정의 행위이기 때문에 유효하지 않은 주소를 참조한채로 간접 접근을 수행하지 않도록 항상 유의해야 한다.  

> 2번 케이스가 미정의 행위지만, 일부 시스템 프로그래밍 시에는 의도적으로 이와 같은 코드를 작성하기도 한다. 미리 정의되어 있는 특정한 주소가 특정 하드웨어와 연결되어, 해당 주소를 읽거나 쓰는 것으로 하드웨어를 제어하기도 한다. 이 경우에는 시스템이 위 동작을 애초에 에러 처리하지 않는다. 다만, 이러한 경우 작은 실수가 중대한 오류가 될 수 있으므로, 실수를 방지하기 위한 매크로와 함수들을 동반하고 매우 유의하며 코드를 작성한다.  

여태까지 배운 내용들에 대해 간단한 예제를 작성하여 확인해보자.  

```c
// pointer_basic.c
#include <stdio.h>

int main(void)
{
    int n = 1, *p = &n;
    printf("============ 1 =============\n");
    printf("n : %d, &n : %p, p : %p, *p : %d, &p : %p\n", n, &n, p, *p, &p);

    n = 2;
    printf("============ 2 =============\n");
    printf("n : %d, &n : %p, p : %p, *p : %d, &p : %p\n", n, &n, p, *p, &p);

    *p = 3;
    printf("============ 3 =============\n");
    printf("n : %d, &n : %p, p : %p, *p : %d, &p : %p\n", n, &n, p, *p, &p);
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src/pointer$ ./pointer_basic 
============ 1 =============
n : 1, &n : 0x7ffff865ca0c, p : 0x7ffff865ca0c, *p : 1, &p : 0x7ffff865ca10
============ 2 =============
n : 2, &n : 0x7ffff865ca0c, p : 0x7ffff865ca0c, *p : 2, &p : 0x7ffff865ca10
============ 3 =============
n : 3, &n : 0x7ffff865ca0c, p : 0x7ffff865ca0c, *p : 3, &p : 0x7ffff865ca10
```  

n에 직접 접근하던, 포인터 p를 통해 간접 접근하던, 결국 n에 저장된 값이 수정되는 것을 볼 수 있다. 그리고 포인터 변수 또한 그 자체로 객체이므로, 주소 연산을 통해 주소를 구하는 것을 볼 수 있다.  

## 포인터와 const

이번 절에서는 포인터에 const 한정자를 사용하면 어떻게 적용되는지 알아볼 것이다. 해당 절에서 비록 const에 대한 내용만 다루지만, 다른 한정자를 사용하더라도 같은 규칙이 적용된다.  
3단원에서 const 한정자를 사용하면 읽기 전용 객체가 되는 것을 확인했다. 그리고 const 한정자는 다음과 같이 사용할 수 있다는 것도 알아보았다.  

```c
const int a = 3;                // const 한정자가 int 지정자 왼쪽에 옴
const const const int a = 3;    // const 한정자가 int 지정자 왼쪽에 여러 번 옴
int const a = 3;                // const 한정자가 int 지정자 오른쪽에 옴
const int const a = 3;          // const 한정자가 int 지정자 양쪽에 옴, 같은 한정자가 여러번 사용되면 한 번 사용한 것과 같음
```  

이미 학습한 바와 같이, 위 네 선언은 모두 동일한 선언이다. const 한정자는 타입 지정자의 왼쪽이나 오른쪽 어디에나 작성할 수 있고, 여러 번 작성할 수도 있다. 중복되더라도 동일한 효과를 갖는다.  

그리고 포인터는 참조하는 타입을 갖는다고 했다. 우선 포인터 선언에서 구두점 ```*``` 왼쪽에 오는 것이 포인터의 참조 타입이라고 생각하자. 그러면 ```int *p;``` 라고 하면 참조 타입이 ```int```인 것이고, ```const int *p;```라고 하면 참조 타입이 ```const int```이다.  

> 실제로 참조 타입을 결정하는 방법은 조금 더 복잡하지만, 학습 진도와 함께 순차적으로 전개해나갈 것이다.  

그렇다면 아래의 네 선언은 모두 같은 포인터 선언이 된다.  

```c
const int *pa = &a;
const const const int *pa = &a;
int const *pa = &a;
const int const *pa = &a;
```  

참조하는 타입이 ```const int``` 라는 것이 어떤 뜻일까? **간접 접근 연산으로 참조하고 있던 객체를 역참조했을 때, 해당 객체가 읽기 전용**이라는 뜻이다. 즉, 간접 접근하여 해당 객체를 수정할 수 없다.  

```c
const int *pa = &a;
*pa + 3;        // 읽기 가능
*pa = 3;        // error! 수정 불가능
```  

여기까지는 이해하는데 크게 어려움이 없을 것이다. 그런데 포인터 선언을 다시 보면, 한정자가 오는 위치가 하나 더 있다. ```type-qualifier_opt type-specifier * type-qualifier_opt identifier;``` 에서 볼 수 있는 것처럼, ```*``` 구두점의 오른쪽에도 올 수 있다.  
```*``` 구두점의 오른쪽에 const 한정자가 와도 같은 의미일까? 이번에는 전혀 다른 의미를 갖게 된다. 해당 한정자는 참조하는 타입을 한정하는 것이 아니고, 포인터 자체를 한정한다. 해당 위치의 한정자는 선언의 형태인 ```<declaration-specifiers> <init-declarator-list>;``` 에서 declaration-specifiers가 아니라 init-declarator-list에 포함된다. 즉, 선언자에 포함된다.  
선언자에 포함되어 포인터 자체를 한정한다는게 어떤 의미를 가질까? 이는 참조하는 타입이 아닌 포인터 값 자체가 읽기 전용이 된다는 의미다. 예시 상황을 통해 확인해보자.  

```c
// variable pointer to a constant value
const int *p = &a;      // 참조하는 타입 const int, 포인터는 수정 가능
*p + 3;                 // 읽기 가능
*p = 3;                 // error! 수정 불가능
p = &b;                 // 포인터 자체는 수정 가능 (참조하는 대상 수정 가능)

// constant pointer to a variable value
int *const p = &a;     // 참조하는 타입 int, 포인터는 수정 불가능
*p + 3;                 // 읽기 가능
*p = 3;                 // 수정 가능 (참조하는 타입이 const가 아님)
p = &b;                 // error! 포인터 자체를 수정할 수 없음 (참조하는 대상 수정 불가능)
```  

위에서 보는 바와 같이 포인터 자체가 const면, 가리키는(참조하는) 대상을 수정할 수 없다. 단, 참조하는 타입은 const가 아니므로, 간접 접근 시 해당 내용을 수정할 수는 있다.  
여태까지 내용을 이해했다면 다음 두 선언의 차이도 구분할 수 있어야 한다.  

```c
int const *p = &a;
int *const p = &a;
```  

1번은 ```const int *p = &a;```와 완전히 같은 선언이므로, 참조하는 타입이 const int인 것이다. 따라서 간접 접근 시 내용을 수정할 수 없다. 2번은 위에서 언급한 것과 같이 참조 타입은 int 지만, 포인터가 const이다. 따라서 가리키는 대상을 바꿀 수는 없지만, 간접 접근 시 내용을 수정할 수 있다.  

![const](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%8F%AC%EC%9D%B8%ED%84%B0/const.png?raw=true)  

그러면 ```*``` 구두점의 왼쪽과 오른쪽에 const 한정자가 모두 붙으면 어떻게 될까? 이 경우엔 참조 타입도, 포인터도 모두 읽기 전용이 된다. 즉, 간접 접근하여 내용을 수정할 수도 없고, 가리키는 내용도 수정할 수 없다.  

```c
const int *const p = &a;   // 참조하는 타입 const int, 포인터 수정 불가능
*p + 3;                     // 읽기 가능
*p = 3;                     // error! 수정 불가능
p = &b;                     // error! 포인터 자체도 수정할 수 없음
```  

여태까지 내용을 잘 파악했다면, 아래 선언에서 a와 b의 타입은 각각 무엇일까?

```c
const int *const a, b;
```  

a는 const int * const 타입의 포인터이다. 참조 타입은 const int이며, 포인터 또한 const다.  
b는 const int 객체다. 애초에 포인터도 아니다.  
위에서 여러번 반복하여 언급한 바와 같이 ```const int```는 타입을 지정하는 선언 지정자지만, ```* const```는 객체를 선언하는 선언자의 일부이다. 따라서 b가 a와 같은 타입을 가지려면 선언은 다음과 같아야 한다.  

```c
const int *const a, *const b;
```  

물론 이는 프로그래밍의 대전제인 헷갈리지 않는 코드 작성에 위배되기에 실제로 이러한 코드를 작성하는 것은 지양해야 한다. 다만 위 상황을 이해했다면, 선언의 전반적인 규칙을 이해할 수 있을 것이다.  

그런데 여태까지 내용 중 한 가지 의아한게 있다. 포인터의 참조 타입과, 실제 참조하는 객체의 타입이 일치하지 않을 수도 있는 것일까? 예를 들어 ```const int *p = &a;``` 에서 실제 a의 타입은 무조건 const int 였을까? 그렇지는 않다. 다음 절에서 참조 타입에 대한 내용을 살펴보자.  

## 포인터 타입과 대입

우선 포인터가 참조하는 타입이 서로 호환되면(compatible) 포인터 타입 또한 호환된다. 여기서 호환된다(compatible)의 뜻을 어림 짐작하면 명시적 형변환 없이 연산 가능한걸 의미하는가 싶을 수 있지만, 그렇지 않다. 엄밀한 규칙은 별도로 존재하지만, 우선 서로간 표현 방식이 동일한 타입인 경우에 호환 가능한 타입이라고 생각하면 된다. 어렵다면 일단 두 타입이 동일하면 서로 호환되는 타입으로 생각하자.  

그런데 두 포인터 타입이 꼭 호환되어야만 대입 혹은 초기화가 가능한 것은 아니다. 우선 호환되는 타입끼리의 대입 혹은 초기화는 당연히 가능하고, 그 외에도 몇 가지 규칙들이 존재한다. 해당 규칙은 대입과 초기화 모두 동일하게 적용된다.  

왼쪽 피연산자와 오른쪽 피연산자의 타입 지정자가 호환될 때, 왼쪽 피연산자가 오른쪽 피연산자의 타입 한정자를 모두 포함하면 된다. 여태까지 배운 타입 한정자로는 ```const```가 있는데, 예시를 위해 ```volatile``` 이라는 한정자를 추가로 사용할 것이다. ```volatile``` 한정자가 무엇인지는 추후에 학습할 예정이니, 한정자라는 사실만 알고 있자.  

> ```constexpr```은 타입 한정자가 아닌 스토리지 클래스 지정자다.  

```c
int a;
volatile int b;
const int c;
const volatile int d;

int *pa = &a;                       // b, c, d 불가능

volatile int *pa = &a, *pb = &b;    // c, d 불가능

const int *pa = &a, *pc = &c;       // b, d 불가능

const volatile int *pa = &a, *pb = &b, *pc = &c, *pd = &d;
```  

어째서 이런 규칙이 성립할까? ```const int *pa = &a;```의 경우를 생각해보자. 원본 객체 a는 읽기와 쓰기가 모두 가능하도록 만들어졌다. 해당 객체를 참조한 포인터 pa가 간접 접근을 통해 원본 객체 a에 접근하여 읽기만 가능하여도 아무런 문제가 없다. 그런데 반대 상황에서는 문제가 발생한다.  
예를 들어 ```int *pa = &c;```가 가능하다고 가정해보자. 원본 객체 c는 읽기 전용으로 만들어졌다. 해당 객체는 한번 생성된 후로는 수정되어서 안 된다. 그런데, 해당 객체를 참조한 포인터 pa의 참조 타입은 ```const int```가 아닌 ```int```이다. 즉, 간접 접근 시 수정도 가능하다는 이야기다. 수정 불가능한 원본 객체 c를 포인터를 통해 간접 접근을 했더니 수정을 허용하게 되는 불상사가 발생한 것이다.  

```c
const double PI = 3.14;
PI = 2.718;     // 컴파일 에러!

double *p = &PI;
*p = 2.718;     // 컴파일 성공, 미정의 행위!
```  

한정자라는 것은 결국 기능을 한정한다는 의미다. ```int a;```에서 객체 a가 가지고 있는 기능이 A, B 라고 가정한다면, ```const int b;```에서 객체 b가 가지고 있는 기능은 A 하나가 된다. 기능이 하나로 한정된 것이다.  
여기서 ```const int *pa = &a;``` 라고 참조한 후, 포인터를 통해 간접 접근을 하면 기능 A를 사용할 것이다. 기능 A는 원본 객체 a가 가지고 있는 기능이기 때문에 아무런 문제가 없다.  
그런데 ```int *pb = &b;``` 라고 참조한 후, 포인터를 통해 간접 접근을 하면 기능 A, B를 사용할 수 있게 된다. 하지만 기능 B는 원본 객체 b가 가지고 있지 않은 기능이기 때문에 문제가 된다.  

이러한 이유들로 인해 생기는 규칙을 꼭 기억하자. **포인터 대입 혹은 초기화 시 왼쪽 피연산자 타입은 오른쪽 피연산자 타입의 한정자를 모두 포함해야 한다. 그 역은 필수가 아니다.**  

다음 규칙은 배열과 함수의 포인터 타입 변환이다. 배열도 함수도 각자의 고유한 타입이 있다. ```int arr[10];``` 라고 선언했을 때, 배열의 이름 ```arr```은 배열 객체를 의미하며 길이가 10인 int 배열 타입이다. ```int func(char);``` 라고 선언했을 때, 함수의 이름 ```func```는 파라미터가 char이고 int를 반환하는 함수 타입이다. 함수 호출 연산자를 사용하지 않고 함수 이름만 사용하는 경우 이를 함수 지정자(function designator)라고 한다.  
아무튼 배열과 함수는 포인터 타입이 아니다. 그저 배열 타입과 함수 타입일 뿐이다. 그런데 배열과 함수를 식에서 사용하는 경우 일부 경우를 제외하고 포인터 타입으로 암시적 변환이 발생한다. 따라서 이들을 변환된 포인터 타입에 맞춰 대입 연산의 우측 피연산자로 사용할 수 있다.  
배열의 경우 "type 배열(array of type)"은 "lvalue가 아닌 type 포인터(pointer to type)"으로 변환한다. 예를 들어 ```int arr[10];```에서 int 배열 ```arr```은 lvalue가 아닌 ```int *```(pointer to int) 타입으로 변환한다. 함수도 비슷하게 변환하는데, 이는 함수 포인터 단원에서 다시 알아볼 것이다.  

위에서 제외한다고 한 일부는 sizeof, typeof, 단항 &(주소) 연산자의 피연산자로 사용되는 경우다. ```sizeof(arr)```와 같이 사용하면 배열 타입을 유지한다. 그렇기 때문에 sizeof 연산자가 배열 객체의 크기를 구할 수 있었던 것이다. 그런데 만약 ```sizeof(arr + 3)``` 라고 한다면, sizeof 연산자는 배열 객체 arr에 적용되는 것이 아니라 연산 식 ```(arr + 3)``` 에 적용된다. 배열의 이름을 식에 사용하면 어떻게 된다고 했는가? 포인터 타입으로 변환한다. 즉, 이 경우 sizeof 연산자가 포인터 타입을 대상으로 수행되는 것이다. 포인터 타입에 더하기 연산을 수행하면 어떻게 되는지는 추후에 알아보고, 우선 배열 타입이 포인터 타입으로 변환했다는 사실에 집중하자. 다음 예제를 통해 해당 사실을 확인할 것이다.  

```c
// array_pointer_conversion.c
#include <stdio.h>

int main(void)
{
    int arr[10] = { 0, };
    printf("sizeof(arr) : %lu\n", sizeof(arr));     // 배열 객체의 크기
    printf("sizeof(arr + 3) : %lu\n", sizeof(arr + 3));     // 포인터의 크기
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src/pointer$ ./array_pointer_conversion 
sizeof(arr) : 40
sizeof(arr + 3) : 8
```  

sizeof 연산자를 arr에 적용했을 때는 배열 객체의 크기 40이 결과로 반환되었다. 반면 sizeof 연산자를 (arr + 3)에 적용했을 때는 아키텍처에 맞는 포인터의 크기가 결과로 반환되었다.  
그렇다면 배열이 식에서 포인터로 변환했다면, 무엇을 참조할까? 배열 객체의 첫 번째 요소를 가리키는 포인터가 된다. 결국 ```(arr + 3)```은 ```(&arr[0] + 3)```과 마찬가지인 것이다.  
여태까지 내용을 이해했다면 다음 내용을 자연스레 이해할 수 있다. 포인터를 초기화하거나 대입하는데 오른쪽 피연산자로 배열의 이름을 사용할 수 있다.  

```c
int arr[10] = { 0, };

// 선언 시 초기화의 경우
int *p = arr;

// 대입의 경우
int *p;
p = arr;
```  

둘 다 배열이 식에서 사용되어 배열의 첫 번째 요소를 가리키는 포인터가 된 것이다. 결국 위 예시는 아래와 동일한 의미를 갖는다.  

```c
int arr[10] = { 0, };

// 선언 시 초기화의 경우
int *p = &arr[0];

// 대입의 경우
int *p;
p = &arr[0];
```  

지금 당장 완전히 이해가 가지 않아도 상관없다. 배열과 포인터를 같이 사용하는 것은 특히 중요하기 때문에, 다음 챕터에서 집중적으로 다시 학습할 것이다. 지금은 위와 같이 배열을 이용하여 포인터를 초기화 혹은 대입할 수 있다는 사실만 기억하면 된다.  

