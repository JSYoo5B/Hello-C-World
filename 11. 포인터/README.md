# 포인터

포인터는 C언어 학습 시 가장 어려운 기능으로 자주 불릴 만큼 괴담이 많다. 사실 여태까지 학습해온 내용들 (특히 3, 4, 9 단원)을 잘 이해하고 있다면 그다지 어렵지 않은데, 기존 개념들에 대한 잘못된 이해가 포인터를 이해하는데 방해를 유발한다. 만약 해당 서적의 앞 내용들을 잘 이해했다면, 포인터에 대한 이해는 악명만큼 어렵지 않을 것이므로, 너무 겁먹을 필요는 없다.  
단, 포인터는 C언어에 있어 굉장히 중요한 기능이며 사용 케이스가 방대하기 때문에 학습에 있어 집중을 요하는 것은 맞다. 포인터는 C언어의 여러 다른 기능과 혼합하여 사용하기 때문에 한 단원에서 모든 내용을 다룰 수는 없다. 따라서 해당 단원에서는 기본적인 기능에 중점을 맞추고, 여러 단원을 거쳐가며 마저 학습할 것이다.  

## 포인터 기초

포인터는 **참조하는 타입 정보를 가지고 주소를 저장하는 객체**다. 앞으로 해당 문장에 대해 이해할 수 있도록 설명할테니, 한 줄을 외워두도록 하자.  

우리는 여태까지 다양한 타입과 객체들을 다뤘다. ```int``` 타입의 객체 중, 값을 유동적으로 저장할 수 있는 임시 저장소를 ```int``` 타입 변수라고 했다. ```"Hello World"``` 와 같은 문자열이 메모리 상에 존재하고 있으면 이를 문자열 객체라고 하였다. 그 외에도 const 객체나 배열 객체 같은 것들도 알아보았다.  

이렇게 객체들은 메모리상에 어떤 식으로 저장되고 해석되어야 할지를 결정하는 타입 정보를 갖는다. 프로그램에서 다루는 데이터들은 결국 메모리에 이진수로 나열되어있을 뿐이고, 이들을 나눠서 특정한 방식으로 해석하여 사용하는 것이다.  

그리고 이러한 객체들은 메모리의 어느 위치에 저장되어있는지를 판단하기 위한 주소를 갖는다. 만약 주소가 없다면 변수 a를 메모리에서 찾으려고 할 때 a가 어디에 저장되어 있는지 알 수 없을 것이다. 이 주소는 0부터 시작하는 정수 값이다.  
9단원에서 학습한 것과 같이 현대 대부분 컴퓨터 시스템의 OS 상에서 동작하는 프로그램은 가상 메모리를 바라보고, 추후 물리 메모리로는 OS와 하드웨어들이 특정한 규칙들에 맞춰 매핑해줄 것이다. 어느 경우에는 물리 메모리 주소를 직접 바라보는 특수한 소프트웨어를 작성하는 경우도 있을 것이다. 이러한 내용들을 굳이 다 고려할 필요는 없고, 메모리 상에 데이터들이 주소 값을 가지고 특정한 표현 방식으로 저장된다고 생각하면 된다.  

![object](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%8F%AC%EC%9D%B8%ED%84%B0/object.png?raw=true)

메모리에 위 그림처럼 데이터들이 저장되어 있을 때, 실제로 어떤 값을 의미하는지는 알 수 없다. 8바이트 짜리 정수일까? 혹은 실수일까? 아니면 1바이트 짜리 정수 여덟 개일까? 만약 1바이트 정수 여러 개라면 부호가 있을까 없을까? 경우에 따라 모두 다른 값으로 해석할 수 있다.  
부호 없는 1바이트 정수 여덟 개라면 다음과 같은 값들이 된다. ```0x88 0xa9 0xcb 0xed 0x78 0x56 0x34 0x12```  
부호 있는 4바이트 정수 두 개라면 다음과 같은 값들이 된다. ```-0x12345678 0x12345678```  
부호 있는 8바이트 정수 하나라면 다음과 같은 값이 된다. ```0x12345678edcba988```  
4바이트 정수와 8바이트 정수가 본인이 해석한 값이랑 다른 것 같다면 9단원에서 학습한 리틀 엔디안을 상기하자.  
그런데 과연 이렇게 해석한 값이 올바를까? 알고보니 0x1000, 0x1001, 0x1006, 0x1007 번지에 있는 값들은 의미 없는 값이고, 0x1002번지부터 4바이트 정수 하나가 저장되어 있을 수도 있다. 그렇다면 ```0x5678edcb``` 가 될 것이다.  

이처럼 데이터는 **어느 주소부터 어느 주소까지 어떤 방식으로** 저장되고 해석할지가 중요하다. 여태까지 우리는 C언어와 컴퓨터 시스템을 통해서 이러한 과정을 신경쓰지 않고 객체와 데이터를 사용해온 것이다.  

```int a = 123;``` 이라는 코드를 다시 생각해보자. int가 4바이트인 리틀 엔디안 시스템이라고 가정한다.  
그러면 변수 a는 메모리의 어떠한 주소(ex. 0x1000)에 4바이트만큼 할당(ex. 0x1000 ~ 0x1003)하여 123이라는 값을 부호 있는 4바이트 정수 방식으로 리틀 엔디안에 맞춰 저장할 것이다. 이 후에 ```a + 3``` 와 같이 a에 접근한다면, 할당된 주소(0x1000)로부터 4바이트의 부호 있는 정수 값으로 저장된 데이터를 해석할 것이다. 이것이 여태까지 우리가 데이터와 객체를 사용해온 방식이다.   

여기까지 이해했다면 포인터는 간단하다. 포인터는 여태까지 이야기해온 0x1000 번지와 같은 메모리의 주소 값을 저장하는 객체다. 그런데 주소 값만으로는 의미가 없으니, 해당 주소에 있는 내용을 어떻게 해석할지에 대한 타입 정보를 갖는다. 이를 참조 타입(referenced type)이라고 한다. 포인터는 다음과 같이 선언할 수 있다.  

```c
type-qualifier_opt type-specifier * type-qualifier_opt identifier;
```  

물론 위 내용 또한 선언의 기본 형태인 ```<declaration-specifiers> <init-declarator-list>;```로부터 전개된 내용이다. 우선 옵션인 타입 한정자를 제외하여 예시를 들면 다음과 같다.  

```c
int *p;
unsigned char *q;
double *r;
```  

위와 같이 선언된 p를 포인터 혹은 포인터 객체라고 한다. 해당 경우에는 객체가 변수이므로, 포인터 변수라고도 한다. 포인터 p에는 주소 값을 저장할 수 있고, int 타입을 참조 타입으로 갖는다. 마찬가지로 q와 r 또한 각각 unsigned char 타입과 double 타입을 참조하여 주소 값을 저장하는 포인터이다. 또한 이들을 더 특정하여 각각 int 포인터, unsigned char 포인터, double 포인터라고도 한다. 원어로는 pointer to int, pointer to unsigned char, pointer to double 이라고 한다.  
참고로 모든 타입이 참조 타입이 될 수 있다. 배열 타입을 포함해서 여태까지 배운 모든 타입과, 앞으로 배우게 될 다른 타입들도 모두 포인터의 참조 타입이 될 수 있다. 물론 포인터 타입 또한 참조 타입이 될 수 있다.  

포인터 선언 시 사용하는 ```*```는 이 후에 알아볼 인다이렉트(역참조) 연산자가 아닌 것에 주의해야 한다. 이는 연산자가 아니라 단순히 선언상의 구두점이다. 선언에서의 구두점과 식에서의 연산자를 혼동은 포인터에 대한 오해를 불러일으킬 수 있다.  
포인터 선언에서 구두점 ```*``` 전후에 화이트 스페이스는 0개 이상이 올 수 있다. 다음 선언들은 모두 동일한 선언이다.  

```c
int*p;      // 1번
int *p;     // 2번
int* p;     // 3번
int * p;    // 4번
int    *
p;          // 5번
```  

어느 선언 방식이 가장 좋아보이는가? 일단 5번은 말도 안되고, 1번은 헷갈리니 선택지는 2, 3, 4번이다. 이는 본인이 수행하는 프로젝트의 규칙에 맞춰서 통일하면 된다.  
2번은 객체가 포인터라는 것을 강조할 수 있고, 3번은 타입이 포인터 타입이라는 것을 강조할 수 있다. 4번은 표기상 일관성있어 보일 수 있다. 일반적으로 C언어에서는 2번을, C++언어에서는 3번을 사용한다. 해당 서적에서는 2번을 사용할 것이다. 그 이유로 다음과 같은 상황을 살펴보자.  

```c
int* a, b;
```  

위 선언에서 a와 b 모두 포인터처럼 보이지만, 사실 a만 포인터이고 b는 평범한 int 타입 변수다. 어째서일까? 이유는 조금 복잡한데 ```<declaration-specifiers> <init-declarator-list>;``` 로부터 전개되는 내용을 살펴봐야 한다. 아래 내용이 어렵다면 단순히 규칙으로 암기하고 넘어가도 무방하다.  
declaration-specifiers에는 타입 한정자나 타입 지정자같은 것들이 포함된다. 즉, ```int``` 라는 타입 지정자는 declaration-specifiers에 포함되는 내용이다. 반면 init-declarator-list는 쉼표로 구분되는 여러 선언자(declarator)가 될 수 있다. 즉 위 선언에서 ```* a, b```는 init-declarator-list에 포함된다. 그리고 선언자에는 단순히 식별자가 올 수도 있지만, 그 앞에 포인터 구두점이 올 수도 있고, 배열 선언자같은 것이 올 수도 있다. 결국 ```* a```와 ```b```가 각각 별도의 선언자이며 두 선언자가 쉼표 구두점으로 묶여서 선언자 리스트를 이룬 것이다.  
정리하자면 위 선언에서 ```int```는 타입 지정자, ```* a```는 하나의 선언자, ```b```도 하나의 선언자이다. ```* a```와 ```b```는 각각 별도의 선언자이므로 b는 포인터와 관계 없고, 그저 그 앞에 있는 타입 지정자의 영향을 받아 int 타입의 객체가 된다.  
결국 2번처럼 객체가 포인터라는 것을 강조한다면 이와 같은 규칙을 좀 더 자연스럽게 받아들일 수 있을 것이다.  
```c
int *a, b;      // int는 타입 지정자, *a는 하나의 선언자, b 또한 하나의 선언자 -> a는 int 포인터 객체, b는 int 객체
```  

위 내용을 이해했다면 아래의 선언에서 각각이 어떤 타입을 갖는지 구분할 수 있을 것이다.  

```c
int *a, b[10], c, d, e[20], *f;
```  

a와 f는 int 포인터 객체, b와 e는 int 배열 객체, c와 d는 int 객체임을 알 수 있다.  

## 포인터 연산