# 반복문

이번 장에는 반복문(iteration statements)과 점프문(jump statements)을 알아볼 차례다. 컴퓨터로 처리하는 작업들은 사실 비슷한 일들을 반복하는 반복 작업인 경우가 많다.  
예를 들어 1부터 100까지 수의 합을 구하는 경우를 생각해보자. 물론, 어릴적 학교 수학 시간에서 배운 것처럼 규칙을 찾아서 (1 + 100) * 100 / 2 라는 공식을 통해서 굉장히 쉽게 구할 수도 있다. 하지만 여기서는 곱하기라는 연산을 하지 못한다고 가정하자. 그러면 어떤 순서로 더하기를 수행하던, 결국 백번의 더하기를 반복해서 수행해야 한다. 이러한 작업은 사람이 하기에는 굉장히 번거롭지만, 컴퓨터로 처리하기에는 너무나도 쉬운 작업이다. 프로그래머는 반복문을 통해 이를 간단히 구할 수 있다.  
반복문에는 크게 while 문, do-while 문, for 문 세 가지 종류가 있다. 반복문은 이 전 단원들과 비교하여 확실히 재밌으니, 하나씩 차례대로 학습해보도록 하자.  

## while문

while은 보통 '~하는 동안'이라고 해석할 수 있다. while 문은 어떠한 조건이 참인 동안 원하는 구문을 반복하는 가장 기본적인 반복문이다. while 문의 형태는 다음과 같다.  

```c
while (expression)
    statement
```  

> 이 전 장과 마찬가지로 C23부터는 statement 대신 secondary-block으로 정의한다.  

굉장히 형태가 간단하다. 이전 장과 마찬가지로 expression은 제어 식(controlling expression)이라고 부른다. 그리고 statement는 반복문의 몸체(loop body)라고 부른다.  
while문은 위의 형태에서 제어 식이 참인 경우 statement를 반복한다. statement는 이 전 장에서 학습한 것과 같이 식문장, 널문장, 복합문 등 어떤 것이든지 올 수 있다. 심지어 선택문이나 반복문이 올 수도 있다.  
즉, while 문의 실행 흐름은 제어식 평가 -> 참이면 몸체 실행 -> 제어식 평가 -> 참이면 몸체 실행 -> .... -> 제어식 평가 -> 거짓이면 while 문 탈출이 된다.  
참고로 반복문의 제어 식은 모두 4장에서 잠시 언급했던 scalar 타입을 가져야 한다는 것 외에 큰 제약 사항이 없다. 마찬가지로 scalar 타입은 지금 학습할 내용이 아니므로, 간단히 그런게 있구나 하고 넘어가자.  

반복문을 활용하면 다양한 요구 상황을 쉽게 풀어낼 수 있다. 예를 들어 1부터 10까지 정수를 출력하라는 요구 사항을 다음과 같이 while 문으로 굉장히 쉽게 구현할 수 있다.  

```c
int i = 1;          // i는 1로 시작
while (i <= 10) {   // i가 10 이하면 참 (10 이하인 동안 반복)
    printf("%d ", i);   // i 출력
    i++;            // i를 1 증가
}
```  

이 전 같으면 printf 함수를 10번 작성해야 했지만, 반복문을 통해 단 한번만 작성할 수 있게 되었다.  
공식적인 것은 아니지만 반복문은 크게 네 가지 요소로 구성된다. 1) 반복문의 시작을 위한 준비 요소 2) 반복문을 반복하기 위한 조건 3) 반복으로 수행하려는 로직 4) 반복문을 탈출하기 위한 요소 이다.  
이 네 가지 요소 중 일부가 생략되어 있을 수도, 혹은 여러 요소가 한 문장 안에 섞여있을 수도 있다.  
이를 테면 위 while 문의 ```int i = 1;```은 시작 준비 요소, ```i <= 10```은 반복 조건, ```printf("%d ", i);```는 수행 로직, ```i++;```는 탈출 요소라고 할 수 있다.  
while 문이 시작하기 전에 i는 1이었고, 첫 번째 반복에서는 i가 1이므로 i <= 10이 참이어서 함수 몸체를 실행하고, 두 번째 반복에서는 i가 2이므로 i <= 10이 참이어서 함수 몸체를 실행하고, ..., 열 번째 반복에서는 i가 10이므로 i <= 10이 참이어서 함수 몸체를 실행한 후, 열한 번째 반복에서는 i가 11이므로 i <= 10이 거짓이므로 함수 몸체를 실행하지 않고 빠져나간다.  
그리고 해당 while 문을 다음과 같이 함축적으로 줄여서 표현할 수도 있다.  

```c
int i = 1;
while (i <= 10)
    printf("%d ", i++);
```  

반복문의 몸체로 복합문이 아닌 단순한 식문장을 사용하였고, printf 함수의 인자로 후위 증가 연산자를 적용한 i++를 전달하여 원하는 값을 출력하는 동시에 종료를 위한 i 값 증가를 수행했다.  
이처럼 큰 틀에서는 네 가지의 요소가 있다고 하더라도, 해당 요소들이 꼭 별도로 존재해야 할 필요는 없다.  

그러면 해당 챕터 서두에서 이야기했던 1부터 100까지의 합을 while 문을 이용해서 구하는 예제를 작성해보자.  

```c
// while_sum.c
#include <stdio.h>

int main(void)
{
    int i = 1, sum = 0;
    while (i <= 100) {
        sum += i;
        i++;
    }
    // 위 문장은 while (i <= 100) sum += i++; 로 줄일 수 있음
    printf("1부터 100까지의 합 : %d\n", sum);
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make while_sum
cc     while_sum.c   -o while_sum
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./while_sum 
1부터 100까지의 합 : 5050
```  

그런데 만약 while 문의 조건이 계속 참이면 어떻게 될까? 예를 들어 다음과 같은 예제는 어떻게 동작할까?  

```c
// infinite_loop.c
#include <stdio.h>

int main(void)
{
    int i = 1;
    while (i <= 10) {
        printf("i : %d \n", i);
    }
    return 0;
}
```  

실행 하면 다음과 같이 무한히 출력을 반복하는 것을 볼 수 있다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make infinite_loop
cc     infinite_loop.c   -o infinite_loop
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./infinite_loop 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
i : 1 
^C
```  

이 경우 프로그램은 종료하지 않으므로, 외부에서 강제로 프로그램을 종료시켜야 한다.  
터미널에서 키보드로 [Ctrl + C] 키를 조합하여 누르면 인터럽트 시그널이라는 것이 발생하여 프로그램을 강제 종료할 수 있다. (인터럽트 시그널에 대한 내용은 해당 책의 범위를 넘어서므로, 해당 키를 누르면 프로그램이 강제 종료 된다는 것만 알고 있으면 된다.)  

이렇게 제어 식이 항상 참이어서 종료 되지 않는 반복문을 무한 루프라고 한다.  
무한 루프는 프로그래머의 실수로 발생할 수도 있지만, 때때로 종료하지 않고 특정한 루틴을 계속 반복할 프로그램을 작성하는 데에 사용하기도 한다.  
다양한 예제들로 반복 연습하여 원하는 상황을 자유롭게 구현할 수 있도록 하자.  

## do while 문

do-while 문은 while 문과 굉장히 유사하다. 우선 형태는 다음과 같다.  

```c
do
    statement
while (expression);
```  

do-while 문의 가장 큰 특징은 '적어도 한 번은 몸체를 실행한다'는 것이다.  
이 전에 while 문은 제어 식을 먼저 평가하여, 조건이 참이라면 반복문의 몸체를 실행했다.  
do-while 문은 우선 반복문의 몸체를 실행한 후, 제어 식을 평가한다.  
즉, 실행 흐름이 몸체 실행 -> 제어 식 평가 -> 참이면 몸체 실행 -> 제어 식 평가 -> ... -> 몸체 실행 -> 제어 식 평가 -> 거짓이면 반복문 탈출 이 된다.  

참고로 do-while 문의 마지막 제어식 뒤의 세미콜론(;)은 널문장이 아니고, do-while 문법에 포함된 구두점이다. 따라서 모든 do-while 문은 제어 식의 끝에 세미콜론을 붙여야 한다.  

사실 모든 while 문과 do-while 문은 서로 대체 가능하다. 단지 대부분의 경우 while 문을 사용하지만, 적어도 한 번은 실행한다는 의미가 중요한 경우엔 do-while 문을 사용하면 된다.  

이번에는 1부터 100까지의 합을 do-while 문을 이용해서 구하는 예제를 작성해보자.  

```c
// do_while_sum.c
#include <stdio.h>

int main(void)
{
    int i = 1, sum = 0;
    do {
        sum += i;
        i++;
    } while (i <= 100);

    printf("1부터 100까지의 합 : %d\n", sum);
    return 0;
}
```  

## for문

for문은 반복문에 필요한 요소들을 구조적으로 정형화한 반복문이다. 주로 카운팅 변수 혹은 제어 변수라는 것을 이용하여 원하는 횟수만큼의 반복 루틴을 작성하기 위하여 사용한다. 여러 언어들에서 for 반복문을 지원하는데, C언어에서 제공하는 for문의 형태는 다음과 같이 두 가지가 있다.  

```c
// 형태 1번
for (expression; expression; expression)
    statement

// 형태 2번 (C99부터 지원)
for (declaration expression; expression)
    statement
```  

조금 복잡해보이지만 사용 예시를 확인하면 굉장히 명료하다는 것을 알 수 있다.  
1부터 100까지 정수의 합을 구하는 예시를 1번 형태로 표현하면 다음과 같다.  

```c
int i = 1, sum = 0;
for (i = 1; i <= 100; i++)
    sum += i;
```  

같은 예시를 2번 형태로 표현하면 다음과 같다.  

```c
int sum = 0;
for (int i = 1; i <= 100; i++)
    sum += i;
```  

이렇게 두 가지 형태를 일반화하면 다음과 같이 표현할 수 있다.  

```c
for (clause-1; expression-2; expression-3)
    statement
```  

예시를 보고 각 요소들이 어떤 역할을 하는지 추론해볼 수 있을 것이다. 한 번 생각해보고, 각 요소들에 대해 알아보자.

* clause-1 : 해당 절에는 선언이나 식이 올 수 있으며, 반복문이 시작할때 가장 먼저 딱 한 번만 실행된다. 해당 절이 선언인 경우, 여기에서 선언한 변수(식별자)는 해당 반복문 내에서 유효 범위를 갖는다.  
* expression-2 : 반복문의 반복 여부를 결정하는 제어 식이다. 반복문의 몸체를 실행하기 전에 평가하여 참이면 몸체를 실행한다. 
* expression-3 : 반복문의 몸체를 실행한 후 수행하는 식이다. 해당 영역에서 주로 제어 변수를 증감한다.
* statement : 반복문의 몸체를 정의하는 문장이다.  

위 요소에서 ```clause-1```, ```expression-2```, ```expression-3```은 생략할 수 있다. ```clause-1```와 ```expression-3```는 생략하면 별도의 동작을 하지 않으며, ```expression-2```은 생략하면 항상 참으로 평가한다.  

그러면 위의 1부터 100까지의 합을 for 문을 이용하여 작성한 예시를 다시 살펴보자.

```c
int sum = 0;
for (int i = 1; i <= 100; i++)
    sum += i;
```  

위 예제의 실행 흐름은 다음과 같다.  
1. for문에서 사용할 수 있는 변수 i를 선언하며 1로 초기화
2. 제어식 ```i <= 100```을 평가 (i가 100보다 작거나 같은 경우 참)
3. 제어식이 참인 경우 몸체인 ```sum += i```를 실행
4. 몸체가 종료된 후 ```i++```를 수행하여 변수 i의 값을 1 증가
5. 2번으로 돌아가서 제어식을 평가
6. 제어식이 거짓인 경우 함수 몸체와 ```i++```를 수행하지 않고 for문을 탈출

그리고 해당 예제는 다음과 같이 작성해도 동일한 결과를 얻을 수 있다. (변수 i의 유효 범위 등은 달라질 수 있다.)  

```c
// 재작성 1번
int i, sum = 0;
for (i = 1; i <= 100; i++)
    sum += i;

// 재작성 2번
int i = 1, sum = 0;
for (; i <= 100; i++)
    sum += i;

// 재작성 3번
int i = 1, sum = 0;
for ( ; i <= 100; ) {
    sum += i;
    i++;
}

// 재작성 4번
int i = 1, sum = 0;
for (;;) {
    if (i > 100)
        break;
    sum += i;
    i++;
}
```  

1번에서는 변수 i를 for 문이 시작하기 전에 선언하고, ```clause-1```에 선언이 아닌 식을 사용했다. for 문이 시작할 때 처음 한 번 실행되는 식을 통해 변수 i에 1을 대입하고 for 문을 수행하였다.  
2번에서는 변수 i를 for 문이 시작하기 전에 선언하면서 1로 초기화 하였다. 카운팅 변수 i가 이미 초기화되어 있으므로 굳이 ```clause-1```를 사용하지 않고 생략하였다.  
3번에서는 나머지는 2번과 동일한데, ```expression-3```을 생략하였다. 그리고 기존 ```expression-3```에서 수행하던 변수 i값 증가를 반복문의 몸체에서 수행하였다.  
4번에서는 ```clause-1```, ```expression-2```, ```expression-3```을 모두 생략하고 처음 보는 문장이 추가되었다. 제어 식인 ```expression-2```을 생략하면 반복 조건은 항상 참이 되므로, 무한 루프가 된다. 따라서 탈출 조건을 만들어줘야 하는데, ```if(i > 100) break;``` 이 그 역할을 한다. 여기서 break는 점프문으로, 이번 장의 후반부에서 자세히 살펴볼 것이다.  

