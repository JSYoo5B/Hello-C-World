# 선택문

문장(statement)은 C언어에서 식과 함께 가장 중요한 요소 중 하나이다. 문장의 종류는 크게 선택문(selection statements), 반복문(iteration statements), 식문장(expression statement), 널문장(null statements), 점프문(jump statements), 레이블문(labeled statements), 복합문(compound statements)이 있는데 식문장과 널문장은 챕터 4에서 이미 살펴보았다. 반복문의 흐름 제어에서 주로 사용되는 점프문은 다음 챕터에서 살펴보고, 나머지 문장들에 대해서는 해당 챕터에서 살펴보겠다.  
참고로 이런 제어문이나 함수 호출 등을 이용해서 프로그램에서 실행되는 구문이나 명령어 등이 호출되는 순서의 흐름을 제어하는 것을 제어 흐름(control flow)라고 한다. 솔직히 이 전까지의 내용은 매우 지루한 문법 학습의 연속이었을 것이다. 하지만 제어 흐름부터는 프로그래밍의 매력을 조금씩 느낄 수 있을 것이니 여기까지 포기하지 않고 달려온 독자분들에게 심심찮은 감사와 격려를 전하고 싶다.  

## if 문

if문은 특정한 조건이 참이라면 원하는 문장을 실행시키기 위해 사용한다. if문의 형태는 다음과 같다.  

```c
if (expression) statement
```

> C23부터는 ```if (expression) secondary-block``` 의 형태로 정의하지만, ```secondary-block```이 ```statement```와 동치이므로 위와 같은 형태를 갖는다.  

위와 같은 형태에서 식이 참으로 평가되면 문장을 실행한다. 예를 들어 다음과 같다.  

```c
if (a == 3)
    printf("a는 3이다.\n");
```

위와 같은 코드에서 변수 ```a```에 저장되어 있는 값이 3이라면 ```printf``` 함수가 호출될 것이고, 3이 아니라면 호출되지 않을 것이다.  
여기서 각 요소 ```if```, ```(expression)```, ```statement```는 0개 이상의 화이트 스페이스로 구분된다. 화이트 스페이스는 출력했을 때 공백으로 보이는 스페이스, 탭, 엔터와 같은 문자를 말한다. 즉, 다음 코드들은 모두 같은 문장으로 해석된다.  

```c
// 각 요소들이 스페이스로 구분
if (a == 3) printf("a는 3이다.\n");

// if와 (a == 3)은 스페이스로 구분, (a == 3)와  printf()는 엔터 + 탭으로 구분
if (a == 3)
    printf("a는 3이다.\n");

// 각 요소들이 0개의 화이트스페이스로 구분
if(a==3)printf("a는 3이다.\n");

// 각 요소들을 모두 엔터로 구분
if
(a == 3)
printf("a는 3이다.\n");

// 각 요소들을 난잡하게 구분
if            (a == 3)
    printf("a는 3이다.\n");
```

모두 같은 문장으로 해석된다고 해서 아무거나 사용해도 되는 것은 아니다. 위 문장들 중 몇번째 문장이 가장 읽기 쉬운가? 그렇다, 2번의 표기가 가장 읽기 쉽다. 그렇지 않다고 생각하는 독자는 자기 자신에게 두 번째 문장이 가장 읽기 쉽다고 최면을 걸자. 대부분의 개발자들은 보편적으로 두 번째 형태로 표기하고 있으며, 모든 개발자들은 다른 개발자들과 협업을 하기 위하여 대중적인 규약을 지켜야 한다. 따라서 여러분들도 꼭 두 번째와 같은 표기법을 지키기 바란다.  

### 제어 식

그러면 if문의 ```(expression)``` 부분에는 어떤 식이든지 들어갈 수 있을까? 그렇다. 우리가 4장에서 공부했던 모든 식을 쓸 수 있다. 그게 어떠한 식이든간에 결과 값이 0이면 거짓이고 0 외의 값이면 참으로 평가할 수 있기 때문이다. 그렇다면 다음 코드의 실행 결과를 예측해보자.  

```c
int a = 3, b = 5;

if (a)
    printf("1\n");

if (a != 3)
    printf("2\n");

if (a - 3)
    printf("3\n");

if (a == 3 && b == 4)
    printf("4\n");

if (a == 3 || b == 4)
    printf("5\n");

if (a += 2)
    printf("6\n");

if (a = 1)
    printf("7\n");
```

결과는 다음과 같다.

```bash
1
5
6
7
```

이유는 다음과 같다.  
1. 변수 ```a```는 3으로 평가되므로 참이라서 첫 번째 printf 함수는 호출된다.
2. a가 3이 아니다라는 식 ```a != 3```는 결과 값이 0이고 이는 거짓이므로 두 번째 printf 함수는 호출되지 않는다.
3. ```a - 3```는 결과 값이 0이고 이는 거짓이므로 세 번째 printf 함수는 호출되지 않는다.
4. a는 3이고 b는 4이다 라는 식 ```a == 3 && b == 4```는 b의 값이 5이므로 결과 값이 0이고 이는 거짓이므로 네 번째 printf 함수는 호출되지 않는다.
5. a가 3이거나 b가 4이다 라는 식 ```a == 3 || b == 4```는 a의 값이 3이므로 결과 값이 1이고 이는 참이므로 다섯 번째 printf 함수는 호출된다.
6. ```a += 2``` 의 결과 값은 5이고 사이드 이펙트로 변수 a에 저장된 값이 2 증가한다. 결과 값 5는 참이므로 여섯 번째 printf 함수는 호출된다.
7. ```a = 1```의 결과 값은 1이고 사이드 이펙트로 변수 a에 저장된 값이 1이 된다. 결과 값 1은 참이므로 일곱 번째 printf 함수는 호출된다.

> 변수와 같은 식별자, 상수, 문자열 리터럴과 같은 요소들을 단독으로 사용하는 식을 기본식(primary expression)이라고 한다.

여기서 일곱 번째 문장을 유의 깊게 볼 필요가 있다. 언뜻 보면 변수 ```a```의 값이 1인지 비교하는 것만 같다. 하지만 실상은 변수 ```a```에 1을 대입하는 연산을 수행한 후, 그 결과 값이 1로 평가되는 식이다. 따라서 a의 값 5(여섯 번째 문장에서 a가 2 증가되었으므로)와 1을 비교해서 거짓이므로 printf가 호출되지 않는 것을 기대했다면 엉뚱한 결과가 나오게 되는 것이다.  
이렇게 제어문의 흐름 제어 식에서 대입 연산자와 동등 연산자를 누가 혼동할까 싶지만, 의외로 이런 실수는 오타로 인해 자주 발생한다. 연속된 야근으로 몸과 마음이 지치고 눈도 침침한 상태에서 = 키를 두 번 누르려고 했으나 힘이 부족하여 한 번밖에 누르지 못하고 눈도 잘 보이지 않아서 그냥 넘어가는 경우가 생길 수도 있다. 심지어 이런 오류는 문법적으로 잘못된 것도 아니기 때문에 컴파일러가 오류를 반환하지도 않는다. 즉, 실행 파일은 만들어졌는데 실행하던 도중에 의도한 것과 다른 엉뚱한 결과를 볼 수 있는 것이다.  
이러한 오류는 찾기가 굉장히 어렵기 때문에 특별히 주의가 필요하다. 어떠한 사람들은 이런 실수를 방지하기 위해 제어 식에서 동등 비교를 다음과 같은 스타일로 작성하기도 한다.  
```c
if (3 == a)         // 실수로 3 = a와 같이 작성하면 컴파일 에러
    statement;
```  
위와 같이 작성한 경우 =를 하나 빠트린 경우 ```3 = a```라는 식에서 3이 lvalue가 아니므로 컴파일 오류가 나서 실수를 미리 인지할 수 있다.  
하지만 이러한 방식으로는 동등 연산자의 피연산자가 모두 변수인 경우 실수를 막지 못한다. 예를 들어,  
```c
if (b = a)          // 원래 의도는 b == a 인데, 실수하는 경우 컴파일 타임에 검출 불가능
    statement;
```
와 같은 경우를 예방할 수 없다. 따라서, 제어 식에서는 최대한 실수를 하지 않도록 주의하는 수밖에 없다.  

그런데 간혹가다가 위와 같이 제어식에서 ```if (a = 3)```와 같이 사용하는 것을 의도하는 사람도 있다. 이러한 행위는 동료에게 칼을 들이미는 것과 같은 아주 나쁜 행위이므로 독자분들은 절대로 이러면 안된다는 것을 명심하자.  
다음 챕터에서 학습할 반복문의 제어식에서는 사이드 이펙트가 발생하는 식을 사용하기도 하지만, 선택문의 제어식에서는 사이드 이펙트가 발생하는 식은 되도록 지양하자.  
선택문의 제어식에서는 되도록 기본 식, 동등 연산자, 관계 연산자, 논리 연산자들을 조합한 식만 사용하기를 권장한다. 물론 언제나 예외는 존재한다. 함수 호출의 결과를 특정한 변수에 저장하며 해당 값을 특정 값과 비교하는 경우가 대표적인데, 이런 경우는 괄호 표기를 통해 의도를 명확히 한다.  

## 복합문(Compound Statement)

만약 if 문의 제어 식이 참인 경우 여러 문장을 실행하고 싶으면 어떻게 해야 할까? 다음 코드의 실행 결과를 예측해보자.  
```c
int a = 3;
if (a == 1)
    printf("a는\n");
    printf("1이다\n");
printf("완료\n");
```  
언뜻 보면 ```완료``` 라는 문장만 출력이 될 것 같다. 하지만 결과는 다음과 같다.  
```bash
1이다
완료
```  

```printf("a는\n");```와 ```printf("1이다\n");```는 별도의 문장이다. 따라서 개행과는 무관하게 if문의 형태에 따라 첫 번째 문장인 ```printf("a는\n");```만 if 문에 귀속된다.  
그렇다면 의도한 대로 두 개의 printf 호출을 모두 ```a == 1```이라는 조건에 귀속하려면 어떻게 해야 할까? 단순히 다음과 같은 방법을 생각해볼 수 있다.  
```c
if (a == 1)
    printf("a는\n");
if (a == 1)
    printf("1이다\n");
```  
위와 같은 코드는 의도한대로 잘 동작한다. 하지만 너무나도 비효율적이다. a와 1을 비교하는 연산을 괜히 두 번 수행해야 한다. 또한, 프로그래머가 똑같은 코드를 반복해서 입력하는 것이 너무나도 귀찮다. 거기에 더해 다음과 같은 상황이 발생할 수도 있다.  
```c
int a = 1;
// a가 1이라면 a를 1 더하고 a의 값을 출력하려는 의도
if (a == 1)
    a += 1;
if (a == 1)
    printf("a는 %d이다\n", a);
```  
주석에 적힌 의도와는 달리 ```a += 1```라는 식의 사이드 이펙트로 a가 2가 되었기 때문에 두 번째 if 문은 실행되지 않았다.  

결국 여러 개의 문장을 하나의 단위로 묶어주는 장치가 필요하다. 그것이 바로 복합문이다. 복합문은 0개 이상의 선언이나 문장을 중괄호로 묶어서 구성한다. 이를 표현하면 다음과 같다.  

```c
// compound statement
{
    declaration
    statement
}
```

위 표현은 쉬운 이해를 위해 엄밀하지 않게 표현한 것이다. 선언이나 문장은 0개 이상으로 없을 수도 있고 여러 개가 올 수도 있다. 또한 순서가 서로 섞일 수도 있다. 예를 들어 다음과 같다.  

```c
{
    int a = 3;  // a 선언
    a += 5;     // 식 문장
    int b = 5;  // b 선언
    a = b - 2;  // 식 문장

    // 아래와 같이 사용은 불가능
    c = a + b;  // c가 아직 선언되지 않았음
    int c;      // c를 사용하기 전에 선언해야 함
}
```  
C언어 컴파일러는 기본적으로 문장들을 위에서 아래로 읽으며 소스 코드를 분석하기 때문에 변수와 같은 식별자들은 사용하기 전에 선언해야 한다.  

그런데 위와 같은 복합문의 형태를 어디선가 많이 봤던거 같다. 그렇다, 우리가 여태까지 두고두고 사용했던 main 함수를 어떻게 정의했는지 다시 살펴보자.  

```c
#include <stdio.h>

int main(void)
{
    int a = 5;
    printf("a는 %d이다.\n", a);
    return 0;
}
```

여기에서도 중괄호로 main 함수의 몸체를 감싸주었다. 혹시 이것도 복합문이 아닐까? 바로 맞췄다. 추후에 함수 챕터에서 학습하겠지만, 함수의 몸체는 복합문으로 정의한다. 여태까지 몇번이고 써왔던 main 함수의 몸체가 바로 복합문이다.  

복합문은 문장 중 하나이므로 하나의 문장처럼 사용할 수 있다. 따라서 위에서 이야기한 if 문에서 여러 문장을 실행하고 싶은 경우 다음과 같이 복합문을 사용하면 된다.  

```c
int a = 3;
if (a == 1) {
    printf("a는\n");
    printf("1이다\n");
}
printf("완료\n");
```

복합문은 0개 이상의 선언과 문장의 조합이라고 하였다. 따라서 다음과 같은 문장들도 모두 가능하다.

```c
if (expression) {
    int a = 1;      // 선언
    a++;            // 식 문장
    a += 3;         // 식 문장
    int b = 5;      // 선언
    b += a;         // 식 문장
}

if (expression) {
    // 0개의 선언과 문장 (expression이 참이라면 아무 것도 하지 않음)
}

if (expression) {
    int a = 1;      // 선언
    a++;            // 식 문장
    {               // 복합문도 문장
        int b = 3;  // 선언
        b++;        // 식 문장
    }
}
```  

두 번째 if문의 경우 복합문 내에 아무런 선언이나 문장이 없다. 이 경우 복합문은 널문장과 마찬가지로 아무 것도 수행하지 않는 문법적인 요소가 된다.  
따라서 두 번째 if 문은 ```if (expression);``` 와 완전히 동일하다.  

세 번째 if문의 경우 복합문 내에 복합문이 사용되었다. 조금 생소해보일 수 있으나 문제는 없다. 복합문도 일종의 문장이기 떄문에, 문장이 올 수 있는 곳에는 어디나 복합문이 올 수 있다. (반대로 복합문이 와야할 곳에는 복합문이 아닌 문장이 올 수 없다.)  
사실 지금 사용하고 있는 if 문의 복합문도, 함수 몸체 정의를 위한 복합문의 일부일 뿐이다. 즉, 이미 복합문 내에 복합문을 사용하고 있었다. 다만 이런 경우 내부에 사용된 변수들의 스코프에 대해 고려해야 하는데, 이는 추후에 알아볼 예정이다.  

마지막으로 복합문의 시작과 끝을 의미하는 중괄호는 다른 요소들과 0개 이상의 화이트 스페이스로 구분된다. 즉, 다음 문장들은 모두 같은 코드이다.  

```c
// 0개의 화이트 스페이스로 구분
if(a==3){printf("a는 3이다.\n");}

// 시작 중괄호는 스페이스로, 끝 중괄호는 엔터로 구분
if (a == 3) {
    printf("a는 3이다.\n");
}

// 시작과 끝 모두 엔터로 구분
if (a == 3)
{
    printf("a는 3이다.\n");
}

// 시작과 끝 모두 두 개의 엔터로 구분
if (a == 3)

{

    printf("a는 3이다.\n");

}
```

첫 번째와 네 번째는 어떻게 봐도 이상하다. 하지만 두 번째와 세 번째는 둘 다 괜찮은 것 같다.  
실제로 두 번째와 세 번째 스타일은 어느 것을 사용해도 괜찮다. 이것은 프로그래머의 취향 차이다.  
하지만 두 번째 스타일을 선호하는 사람과 세 번째 스타일을 선호하는 사람이 만나면 전쟁이 시작된다. 이는 실제로 프로그래밍 업계에서 유명한 성전(Holy-War)중 하나이다.  
어느 스타일도 괜찮다고는 했지만 하나의 프로젝트 내에서는 스타일을 통일하는 것이 좋다. 그렇기 때문에 실제 개발시에는 프로젝트가 시작되기 전에 이러한 스타일을 어떤 식으로 통일할지 결정하고는 한다. 이를 두고 코드 컨벤션을 정한다고 한다. 프로젝트에 컨벤션이 한 번 정해졌다면, 본인이 다른 스타일을 선호한다고 하더라도 팀의 규칙에 따라야 한다는 것을 명심하자.  
해당 서적에서는 복합문을 사용할 때 함수 몸체의 정의를 위한 복합문은 3번 스타일로, 그 외에는 2번 스타일로 작성할 것이다. 독자분들이 특별히 선호하는 컨벤션이 있다면 예제들을 원하는 스타일로 바꿔서 작성하는 것은 상관 없다. 단지, 코드를 한 눈에 파악하기 쉽고 통일된 스타일로 작성하도록 하자.  

다음 예제는 여태까지 학습한 내용을 기반으로 두 정수와 하나의 문자를 입력받아 더하기 혹은 빼기를 수행한다.  

```c
// if_basic.c

#include <stdio.h>

int main(void)
{
    int num1, num2;
    char op;

    printf("두 정수를 입력하세요 : ");
    scanf("%d %d", &num1, &num2);
    printf("+ 와 - 중에 원하는 연산자를 입력하세요 : ");
    scanf(" %c", &op);      // 버퍼에서 엔터 지우기 위한 스페이스

    if (op == '+') {
        printf("%d + %d = %d\n", num1, num2, num1 + num2);
    }

    if (op == '-') {
        printf("%d - %d = %d\n", num1, num2, num1 - num2);
    }

    return 0;
}
```  

실행 결과는 입력한 값에 따라 달라진다. 예를 들어 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make if_basic
cc     if_basic.c   -o if_basic
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./if_basic 
두 정수를 입력하세요 : 3 5
+ 와 - 중에 원하는 연산자를 입력하세요 : -
3 - 5 = -2
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./if_basic 
두 정수를 입력하세요 : 7 2
+ 와 - 중에 원하는 연산자를 입력하세요 : +
7 + 2 = 9
```

입력한 값에 따라 더하기를 수행할지 빼기를 수행할지 실행의 흐름을 제어해냈다. 드디어 뭔가 의미있는 프로그램을 만들어낸듯 하다. 앞으로 더욱 의미 있는 프로그램을 만들게 될 것이다.  

> 선택문 챕터에서 복합문을 소개했다고 해서 복합문이 선택문의 일종인 것은 아니다. 복합문은 선택문과 마찬가지로 문장의 일종이다. 단지 선택문이나 반복문과 조합해서 자주 사용하므로 이 곳에서 소개했을 뿐이다.  

## if else 문

기존에 if 문에서 식이 참이라면 문장을 실행했다. 하지만 현실에 있는 요구 사항 중에는 '조건이 참이라면 A를 하자'에서 끝나지 않고, '조건이 참이라면 A를 하고 거짓이라면 B를 하자' 의 경우도 비일비재하다. 이런 경우를 위해 if문에 조합하여 사용할 수 있는 else문이 있다. if else문의 형태는 다음과 같다.  

```c
if (expression)
    statement
else
    statement
```  

식과 문장은 이 전 절에서 학습한 것과 다를 바가 없다. 그저 if 문 다음에 ```else``` 라는 키워드가 따라 붙고 그 후에 식이 거짓이라면 실행할 문장이 따라올 뿐이다. 사용 예시는 다음과 같다.  

```c
if (num1 > num2)
    max = num1;
else
    max = num2;
```  

변수 num1이 num2보다 크다면 max에 num1 값을 저장하고, 아니라면 max에 num2 값을 저장하고 있다. 이렇게 두 변수 중 더 큰 값을 찾을 수 있다.  
물론 statement에는 다음과 같이 복합문이 올 수 있다. 아래 예시는 위의 예시와 완전히 같다.  

```c
if (num1 > num2) {
    max = num1;
} else {
    max = num2;
}
```  

else 문은 if 문에 종속된 문법이므로 단독으로 사용할 수 없고 항상 if 문과 함께 사용해야 한다는 것만 주의하자. 그래서 이번 장의 소제목도 else 문이 아닌 if else 문이다.  

그러면 이를 응용하여 세 변수 중 가장 큰 값을 찾으려면 어떻게 해야할까? 한 번 생각해본 후, 다음 예제를 통해 알아보자.

```c
// maxval_in_three.c
#include <stdio.h>

int main(void)
{
    int num1, num2, num3;
    int max;

    printf("세 정수를 입력하세요 : ");
    scanf("%d %d %d", &num1, &num2, &num3);

    if (num1 > num2) {
        // num1이 num2보다 크므로 num2는 후보 탈락
        if (num1 > num3) {
            max = num1;
        } else {
            max = num3;
        }
    } else {
        // num1이 num2보다 작거나 같으므로 num1은 후보 탈락해도 됨
        if (num2 > num3) {
            max = num2;
        } else {
            max = num3;
        }
    }

    printf("가장 큰 값은 %d 입니다.\n", max);
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make maxval_in_three
cc     maxval_in_three.c   -o maxval_in_three
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./maxval_in_three 
세 정수를 입력하세요 : 8 3 5
가장 큰 값은 8 입니다.
```  

### 중첩 if else 문

if 문에 대한 기본적인 문법은 위의 내용이 전부다. 이를 잘 조합하면 원하는 조건들을 중첩시킬 수 있다.  
선택문도 문장 중 하나이며, if문과 if else문은 선택문 중 하나이다.  
따라서 if 문에서 문장이 오는 곳에 다시 if 문이 올 수 있다. ```if (expression) statement``` 혹은 ```if (expression) statement else statement```가 통째로 하나의 문장이므로, statement가 오는 곳에 if문을 다시 넣으면 중첩된 if문을 만들 수 있다.  
if else 문도 마찬가지이며, if문과 if else문을 섞어서 중첩할 수도 있다.  

```c
// if 중첩
if (expression)
    if (expression)
        statement

// if문의 statement에 if else문 사용
if (expression)
    if (expression)
        statement
    else
        statement

// if else 중첩
if (expression)
    if (expression)
        statement
    else
        statement
else
    if (expression)
        statement
    else
        statement

// if else 문의 else 문에만 if else문 중첩
if (expression)
    statement
else
    if (expression)
        statement
    else
        statement
```  

예시로 다음 두 가지 중첩 조건에 대해 생각해보자.  

```c
if (a == 3)
    if (b == 3)
        printf("a와 b는 3이다.\n");

if (a > 0)
    printf("a는 0보다 크다.\n");
else    // a는 0보다 작거나 같음
    if (a < 0)
        printf("a는 0보다 작다.\n");
    else
        printf("a는 0이다.\n");
```  

첫 번째 중첩 if 문은 사실 ```if (a == 3 && b == 3) printf("a와 b는 3이다.\n")```와 같은 효과를 갖는다. 이렇게 단순한 조건의 나열은 논리 연산자로 하나의 if문 내에 묶는 것이 나은 선택이지만, 경우에 따라서는 조건과 경우의 수가 굉장히 복잡해져서 위와 같이 중첩된 if 문을 사용하는 것이 나은 경우도 있다. 지금은 여러 조건을 위와 같이 중첩할 수 있다는 것만 알아두자.  

두 번째 중첩 케이스는 굉장히 많은 경우에 사용하게 된다. '조건1의 경우엔 A를 하고, 조건2의 경우엔 B를 하고, 조건3의 경우엔 C를 하고, ..., 위 조건에 모두 만족하지 않는 경우 Z를 한다' 와 같은 의미를 가진다. 만약 마지막 else 문이 빠진다면 '위 조건에 모두 만족하지 않는 경우 Z를 한다'만 빼서 해석하면 된다. 즉, 여러 조건을 나열하는 경우 두 번째 예시와 같이 중첩을 사용할 수 있다.  
그런데 if else 문의 각 요소는 화이트 스페이스로 구분한다고 했다. 결국 두 번째 예시를 다음과 같이 작성해도 완전히 동일한 문장이 된다.  

```c
if (a > 0)      // a가 0보다 큰 경우
    printf("a는 0보다 크다.\n");
else if (a < 0) // a가 0보다 작은 경우
    printf("a는 0보다 작다.\n");
else            // a가 0보다 크지도 작지도 않은 경우 (같은 경우)
    printf("a는 0이다.\n");
```  

조건식과 그에 따른 실행 문장을 한 눈에 파악하기 굉장히 쉬워졌다. 여기에 더해 문장을 복합문으로 작성해서 중첩 if else 문은 아래와 같은 형태로 사용하는 경우가 많다.  

```c
if (조건식1) {
    조건식1이 참일 경우 실행할 문장;
} else if (조건식2) {
    조건식2이 참일 경우 실행할 문장;
} else if (조건식3) {
    조건식3이 참일 경우 실행할 문장;
} else if (...) {
    ...
} else {
    위 조건식이 모두 거짓일 경우 실행할 문장;
}
```  

여기까지 학습하였다면 중첩 if문에 대한 내용은 거의 다 숙지한 것이다. 다만 한 가지 주의할 내용이 있다. 다음 코드의 실행 결과를 예측해보자.  

```c
int a = 1, b = 0;

if (a == 0)
    if (b == 0)
        printf("a는 0이고 b는 0이다.\n");
else
    printf("a는 0이 아니다.\n");
```  

얼핏 보면 ```a는 0이 아니다.``` 가 출력될 것 같다. 하지만 else 문은 언제나 바로 직전 if 문에 종속된다. 따라서 개행을 어떻게 하던간에 위 코드는 아래와 완전히 동일한 코드이다.  

```c
if (a == 0)
    if (b == 0)
        printf("a는 0이고 b는 0이다.\n");
    else
        printf("a는 0이 아니다.\n");        // 의도와 달리 if (b == 0) 에 종속됨
```  

그렇다면 의도와 같이 else 문을 ```if (a == 0)```에 종속시키려면 어떻게 해야 할까? 내부에 있는 if 문을 복합문으로 묶어서 다음과 같이 문장 요소를 종료시키면 된다.  

```c
int a = 1, b = 0;

if (a == 0) {
    // 복합문이 시작됨
    if (b == 0)
        printf("a는 0이고 b는 0이다.\n");
    // 복합문이 종료됨
} else  // 해당 else 문은 if (a == 0)에 종속됨
    printf("a는 0이 아니다.\n");
```  

위와 같이 작성한 코드에서는 결과로 ```a는 0이 아니다.```가 출력된다. 물론, else 문도 복합문으로 묶는 것이 훨씬 가독성이 좋을 것이다.  

---

Quiz. 복합문을 사용하지 않고 위와 완전히 같은 동작을 하는 코드를 작성

Answer

```c
int a = 1, b = 0;

if (a == 0)
    if (b == 0)
        printf("a는 0이고 b는 0이다.\n");
    else    // else문은 항상 직전의 if 문에 종속됨
        ;   // 널 문장으로 if (b == 0)에 종속되는 else 문을 bypass
else
    printf("a는 0이 아니다.\n");
```  

---

마지막으로 여태까지 학습한 내용을 기반으로 입력받은 점수가 90점 이상이라면 A, 80점 이상 90점 미만이라면 B, 70점 이상 80점 미만이라면 C, 60점 이상 70점 미만이라면 D, 그 미만이라면 F를 출력하는 예제를 작성해보자.  

```c
// if_grade.c
#include <stdio.h>

int main(void)
{
    int score;
    printf("점수를 입력하세요 : ");
    scanf("%d", &score);

    if (score >= 90) {
        printf("A");
    } else if (score >= 80 && score < 90) {
        printf("B");
    } else if (score >= 70 && score < 80) {
        printf("C");
    } else if (score >= 60 && score < 70) {
        printf("D");
    } else {
        printf("F");
    }
    printf("등급입니다.\n");
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make if_grade
cc     if_grade.c   -o if_grade
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./if_grade 
점수를 입력하세요 : 100
A등급입니다.
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./if_grade 
점수를 입력하세요 : 75
C등급입니다.
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./if_grade 
점수를 입력하세요 : 50
F등급입니다.
```  

---

Quiz. 위 예제에서 필요없는 조건을 생략

Quiz. ~가 아니라면? 조건

---

## switch 문

