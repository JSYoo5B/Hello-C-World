# 변수와 상수

이번 챕터에서는 C언어에서 사용하는 변수와 상수에 대해 공부하고, 이들이 가질 수 있는 타입에 대해 알아 볼 것입니다.  
그런데 변수와 상수에 대해 자세히 이해하려면 컴퓨터가 어떻게 숫자를 표현하고 데이터를 저장하는지를 알아야 합니다.  
따라서 이번 챕터의 앞 부분에서는 이러한 선행 내용을 먼저 다루도록 하겠습니다.  

## 데이터와 이진수

데이터라는 용어는 처음에 저장하거나 전달할 수 있는 컴퓨터 정보(information)라는 의미로 사용되었습니다.  
시간이 지나고 용어의 의미가 가공되면서 사람들은 문자나 숫자와 같은 것들을 컴퓨터가 처리할 수 있는 형태로 만든 자료를 데이터라고 부르게 되었습니다. 그리고 이 데이터를 가공하여 정보(information)를 얻는다고 이야기를 하고는 합니다.  
여기에 더해 데이터에 대한 학술적인 의미를 살펴보면 '정보를 전달하거나 수량이나 통계 등을 묘사하기 위한 이산(discrete) 값들을 컴퓨터로 처리하거나 해석하기 위하여 순서를 가지고 나열된 기호(Symbol)의 모음'이라고 합니다.  
이러한 사전적 의미들은 항상 너무 딱딱하고 어렵습니다. 우선은 우리가 사용하는 컴퓨터나 스마트폰에 저장되어 있는 텍스트 파일, 사진 파일, 동영상 파일같은 것들을 데이터라고 한다고 추상적으로 생각해봅시다.  
그리고 컴퓨터는 이 데이터를 항상 이진법으로 저장하고 해석합니다.  

이진법은 0과 1 두 개의 숫자만을 사용하는 수 체계입니다.  
우리는 평소에 0부터 9까지 총 열 개의 숫자를 사용하는 십진법을 사용하고 있습니다.  
십진법으로 0부터 차례대로 정수를 써내려가면 0, 1, 2, 3, 4, ..., 9, 10, 11, 12, ..., 19, 20, ..., 99, 100, 101, ... 와 같이 쓸 수 있습니다.  
그러면 이진법으로 0부터 차례대로 숫자를 써내려가면 어떻게 될까요?  
0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, ... 와 같이 쓸 수 있습니다.  
십진수와 이진수의 나열을 일부 비교하면 다음과 같습니다.  

| 십진수 | 이진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |
| 9 | 1001 |
| 10 | 1010 |

이진수를 좀 더 와닿게 하도록 평소에 사용하는 십진수의 자릿값을 생각해보겠습니다.  
563 이라는 숫자는 일의 자리가 3, 십의 자리가 6, 백의 자리가 5인 수입니다.  
1234 라는 숫자는 일의 자리가 4, 십의 자리가 3, 백의 자리가 2, 천의 자리가 1인 수입니다.  
이렇게 자릿값을 계산할 때 각 자리는 10을 영(0)번 곱한 일( $10^0$ )의 자리, 10을 한(1)번 곱한 십( $10^1$ )의 자리, 10을 두(2)번 곱한 백( $10^2$ )의 자리, 10을 세(3)번 곱한 천( $10^3$ )의 자리, ... 와 같이 증가합니다.  
이진수도 이와 다를바가 없습니다. 여기서 10 대신에 2를 사용하여 자릿값을 구하면 됩니다.  
즉, 2를 영(0)번 곱한 일( $2^0$ )의 자리, 2를 한번 곱한 이( $2^1$ )의 자리, 2를 두번 곱한 사( $2^2$ )의 자리, 2를 세번 곱한 팔( $2^3$ )의 자리, 2를 네번 곱한 십육( $2^4$ )의 자리, .. 와 같이 증가합니다.  

그리고 각 숫자가 어떤 진법을 사용하고 있는지는 숫자의 다음과 같이 우측 아래에 진법을 통해 표기하고는 합니다.  
$563_{10}$  $1010_{2}$  
좌측은 10진법으로 563을 뜻하고 우측은 2진법으로 1010을 뜻합니다.  
$1010_{2}$ 와 같은 표기를 프로그래밍 언어에서는 보통 숫자 앞에 접두사로 ```0b```를 붙여 ```0b1010```과 같이 표현하기도 합니다. (여기서 b는 이진법의 영어인 Binary에서 따온 글자입니다.)  
앞으로 해당 서적에서도 어떤 숫자 앞에 ```0b```가 붙는다면 이진수를 뜻한다고 생각해주시면 됩니다.  

이제 이진수를 십진수로 변환하는 방법에 대해서 살펴보겠습니다.  
우선 십진수 563의 각각의 자릿수를 펼쳐서 써보면 다음과 같습니다.  
$5 * 10^2 + 6 * 10^1 + 3 * 10^0  = 500 + 60 + 3 = 563$  
이와 마찬가지로 ```0b1010```이라는 이진수의 각각의 자릿수를 펼쳐서 써보면 다음과 같습니다.  
$1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$  
이를 계산하면 다음과 같습니다.  
$1 * 8 + 0 * 4 + 1 * 2 + 0 * 1 = 8 + 2 = 10$  

해보니 어렵지 않습니다. ```0b10101```이라는 수로 한번만 더 연습해보겠습니다.  
$1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1 * 16 + 0 * 8 + 1 * 4 + 0 * 2 + 1 * 1 = 16 + 4 + 1 = 21$  

이렇게 자꾸 연습하다 보면 이진수를 대충 보고도 바로바로 십진수로 변환할 수 있게 됩니다.  

그렇다면 십진수를 이진수로 변환하는건 어떻게 하면 될까요?  
십진수를 몫이 0이 될 때까지 2로 계속 나누어서 그 나머지를 거꾸로 모아주면 됩니다.  
위의 10과 21을 예로 들어서 변환해보겠습니다.  

$10 / 2 = 5 ... 0$  
$5 / 2 = 2 ... 1$  
$2 / 2 = 1 ... 0$  
$1 / 2 = 0 ... 1$  
10을 2로 나눈 몫은 5이고, 나머지는 0입니다.  
그 몫을 다시 2로 나눈 몫은 2이며, 나머지는 1입니다.  
이런식으로 몫이 0이 될 때까지 계속 나누고, 그로 인해 생긴 나머지들을 거꾸로 읽어주시면 이진수가 됩니다.  
위의 나눔 연산의 나머지들을 거꾸로 모아보면 10을 이진수로 표현한 ```0b1010```이 되는걸 볼 수 있습니다.  

21에 대해서도 한번만 더 연습해보도록 하겠습니다.  
$21 / 2 = 10 ... 1$  
$10 / 2 = 5 ... 0$  
$5 / 2 = 2 ... 1$  
$2 / 2 = 1 ... 0$  
$1 / 2 = 0 ... 1$  
마찬가지로 나머지들만 거꾸로 모아보면 ```0b10101```이 되는 것을 볼 수 있습니다.  

이제 숫자를 어떻게 이진법으로 표현하는지는 충분히 이해가 되었을 겁니다.  
일반적으로 컴퓨터는 MOSFET이라는 트랜지스터들이 모여서 회로를 구성하며, 트랜지스터에 전기가 흐르면 1, 흐르지 않으면 0과 같이 표현하여 이진 데이터를 해석하거나 저장할 수 있습니다. (이에 대해 더 자세한 내용은 디지털 논리라는 과목을 공부하면 알 수 있습니다.)  
컴퓨터는 수십, 수백억개의 트랜지스터가 들어가기 때문에 이진수를 굉장히 잘 사용할 수 있습니다.  
그리고 프로그래머는 컴퓨터와 대화를 하기 위해 이진수를 열심히 사용하려고 합니다.  
하지만 프로그래머도 사람입니다. 이진수의 숫자가 커지면 점점 보기가 힘들어집니다.  
숫자 1000만 하더라도 이진수로 하면 ```0b1111101000```이 됩니다.  
프로그래밍을 하다보면 수억을 넘어가는 굉장히 큰 수를 다루게 되는데 이를 이진수로 표현하기엔 너무 숫자의 배열이 길어집니다.  
그래서 프로그래머들은 이진수와 호환이 좋으면서도 큰 수를 짧게 표현할 수 있는 십육진법을 많이 사용합니다.  
십육진법에서는 9 이후로 로마 문자를 사용하여 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 16개의 숫자를 사용합니다.  
십진수와 십육진수를 대강 비교하면 다음과 같습니다.  

| 십진수 | 십육진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| ... | ... |
| 9 | 9 |
| 10 | A |
| 11 | B |
| 12 | C |
| 13 | D |
| 14 | E |
| 15 | F |
| 16 | 10 |
| 17 | 11 |
| ... | ... |
| 25 | 19 |
| 26 | 1A |
| 27 | 1B |
| ... | ... |
| 31 | 1F |
| 32 | 20 |

십진수와 십육진수를 서로 변환하는건 이진수와 십진수를 서로 변환하는 것과 근본적인 원리에 큰 차이는 없습니다.  
하지만 십육진수는 주로 이진수와의 호환을 위해 사용하고는 합니다.  
따라서 십진수와 십육진수를 변환하는 것보다는 이진수와 십육진수를 변환하는 것을 살펴보는 것이 좋습니다.  
그 전에 참고로, 이진수를 프로그래밍 언어에서 표현할 때 숫자 앞에 ```0b```를 붙인 것처럼, 십육진수를 프로그래밍 언어에서 표현할 때 숫자 앞에 ```0x```를 붙입니다.  
예를 들어, 십육진수 $3F_{16}$ 를 ```0x3F```와 같이 표현하고는 합니다.  
마찬가지로 해당 서적에서 어떤 숫자 앞에 ```0x```를 붙인다면 십육진수를 표현한다고 생각해주시면 됩니다.  
돌아와서 이진수와 십육진수를 대강 비교하면 다음과 같습니다.  

| 이진수 | 십육진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| ... | ... |
| 1110 | E |
| 1111 | F |
| 10000 | 10 |
| 10001 | 11 |
| 10010 | 12 |
| ... | ... |
| 11110 | 1E |
| 11111 | 1F |
| 100000 | 20 |
| ... | ... |
| 11111111 | FF |
| 100000000 | 100 |

눈치가 빠른 분은 어느정도 규칙을 발견할 수도 있었을 겁니다.  
$16 = 2^4$ 이기 때문에 이진수 네 자리와 십육진수 한 자리가 대응되는걸 볼 수 있습니다.  
예를 들어 십육진수 ```0x4B27``` 의 각 자리는 이진수의 네 자리에 대응되어 열여섯 자리의 이진수가 됩니다.  
```0x4 = 0b0100```  
```0xB = 0b1011```  
```0x2 = 0b0010```  
```0x7 = 0b0111```  
이므로 각 자리들을 모으면  
```0x4B27 = 0b0100101100100111``` 이 됩니다.  
이처럼 이진수와 십육진수는 서로 굉장히 잘 호환되는 것을 볼 수 있습니다.  

## 변수

C언어에서 변수(variable)는 값을 저장하는 임시 저장소입니다.  
컴퓨터는 연산을 하기 위해 다양한 데이터들을 주기억장치(Main Memory)에 저장하고 불러와서 사용합니다.  
예를 들어 즐겨하는 게임에서 내 캐릭터의 HP같은 것이 있다고 가정하면, 공격을 맞았을 때 HP는 감소하고 아이템을 사용하거나 회복하면 HP가 증가하게 됩니다. 컴퓨터는 이런 HP와 같은 값들을 주기억장치에 저장해두고, 해당 값을 더하거나 빼거나 하는 등의 연산을 수행합니다.  
그러면 우리가 플레이하는 게임 프로그램은 주기억장치의 어느 위치에 HP에 해당하는 값이 저장되어 있는지를 찾아야 합니다. 이 때 사용하는 것이 바로 변수입니다. HP라는 변수를 만들면 이 변수가 주기억장치의 어딘가에 위치하게 되고(위치를 결정하는건 운영체제가 결정합니다.) 프로그램에서 이 HP라는 변수를 사용하게 되면 알아서 HP가 저장되어있는 위치를 찾아갑니다. 그리고 해당 값을 읽는다던지, 새로운 값을 써넣는다던지, 기존 값에서 특정 값을 더하고 빼는 작업을 수행할 수 있게 됩니다.  

컴퓨터에서 보통 주기억장치라고 하면 RAM(Random Access Memory)을 의미합니다. 주기억장치(Main Memory) 혹은 1차 기억장치(Primary Memory)는 CPU가 직접 접근하는 메모리로 RAM, ROM 등이 존재합니다. 지금부터는 그 중 자주 사용하는 RAM에 집중하여 이야기해보겠습니다.  

컴퓨터나 스마트폰을 구매할 때 RAM이 4GB니 16GB이니 하는 이야기를 많이 들어보셨을 겁니다. 이게 RAM의 크기를 나타낸다는 것은 이제 많은 사람들에게 익숙한 이야기입니다. 그렇다면 이 크기가 얼마나 큰 것일까요?  
위에서 트랜지스터 하나가 전기가 흐르면 1, 흐르지 않으면 0을 표현할 수 있다고 했습니다. 이 트랜지스터 하나가 표현할 수 있는 이진수 한 자리가 1 비트(bit) 입니다. 그리고 8개의 비트가 모여서 1 바이트(byte)가 됩니다. (사실 1 바이트가 몇 비트인지는 컴퓨터 아키텍처와 구현에 따라 달라질 수도 있지만 보편적으로 8 비트를 사용합니다.)  
한 자리의 이진수로 표현할 수 있는 수는 0과 1 두 개 ( $2^1$ ) 입니다.  
두 자리의 이진수로 표현할 수 있는 수는 00, 01, 10, 11 네 개 ( $2^2$ ) 입니다.
이런 식으로 N 자리의 이진수로 표현할 수 있는 수는 $2^N$ 개 입니다.  
그러면 여덟 자리의 이진수로 표현할 수 있는 수, 다시 말해 1바이트(8비트)로 표현할 수 있는 수는 $2^8 = 256$ 개이며 0부터 255까지 표현할 수 있습니다.  
이에 더해 4바이트(32비트)로 표현할 수 있는 수는 $2^{32} = 4294967296$ 개이며 0부터 4294967295(0xFFFFFFFF)까지 표현할 수 있습니다.  

그리고 바이트는 약 천 단위로 새로운 저장 단위를 갖습니다.  
1024( $2^{10}$ ) 바이트는 1 킬로바이트이며, 다시 1024 킬로바이트는 1 메가바이트이고, 1024 메가바이트는 1 기가바이트가 됩니다.  
즉, 1 기가바이트는 $2^{10} * 2^{10} * 2^{10} = 2^{30}$ 바이트가 되는 것이고, 4 기가바이트는 여기에 4를 곱하여 $2^{30} * 4 = 2^{30} * 2^2 = 2^{32}$ 바이트가 되는 것입니다.  
RAM의 크기가 4 기가바이트다 라고 한다면, $2^{32}$ 바이트의 데이터를 RAM에 동시에 저장할 수 있다는 의미가 되는것이죠.  
이 4 기가바이트 RAM의 각 바이트 저장 공간에는 주소라는 것이 있습니다. 저희가 사는 집주소를 프로시 그램구 씨동 1024번지와 같이 표현하는 것처럼 말이죠.  
4 기가바이트 RAM에서 주소는 0번지부터 $2^{32} - 1$ 번지까지 존재합니다. 시작 주소가 1번지가 아닌 0번지인 것에 유의합시다. 따라서 끝 주소는 $2^{32}$ 번지가 아닌 $2^{32} - 1$ 번지가 됩니다. 그리고 앞으로 RAM의 주소를 이야기할 때는 항상 십육진법으로 표기를 하겠습니다.  
그리하여 보통 RAM을 그림으로 나타낼 때 다음과 같이 그리고는 합니다.  
![ram](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B3%80%EC%88%98%EC%99%80%20%EC%83%81%EC%88%98/memory.png?raw=true)  
위 그림에서 네모 한 칸에 1바이트(8비트)를 저장할 수 있습니다.  
자, 그러면 0x0 번지에 HP라는 변수가 저장된다고 가정하고 HP를 1만(10,000)으로 설정해봅시다. 어라? 1만은 2진수로 ```0b10011100010000``` 인데 (십육진수로 0x2710), 한 바이트로 해당 수를 다 표현할 수가 없습니다! 애초에, 1바이트로 표현할 수 있는 수는 0부터 255까지밖에 없다고 했습니다. 그러면 이보다 큰 수는 어떻게 해야 할까요?  
정답은 0x0번지부터 0x1번지까지 이어서 값을 저장하고 0x0번지와 0x1번지를 합쳐서 HP라고 지정하면 됩니다. 이렇게 2바이트를 사용하면 위에서 했던 계산에 의해 최대 65535(0xFFFF)까지 표현할 수 있습니다.  
그러면 65535보다 큰 수는 또 어떻게 해야 할까요? 3바이트를 사용하면 되는 걸까요? 그래도 되지만, 현대 컴퓨터에서는 효율과 편의를 위하여 2의 거듭제곱 수만큼 증가해 사용합니다. 즉, 그보다 큰 수는 4바이트를 사용해 표현합니다. 그리고 4바이트로 표현할 수 없는 수는 8바이트로 표현하고는 하죠.  
그러면 8바이트로도 표현할 수 없는 수는 16바이트로 표현할까요? 보통 그렇지는 않습니다. 현재는 효율의 문제로 8바이트로 표현할 수 있는 크기의 숫자까지만 취급하고 있습니다. (물론 이는 정해진 내용이 아니기 때문에 얼마든지 변경될 수 있습니다. 그렇다 해도 언제나 한 번에 처리할 수 있는 크기의 한계는 존재할 것입니다.) 하지만 8바이트만으로도 최대 18,446,744,073,709,551,615 라는 엄청난 크기의 숫자까지 표현할 수 있으므로 큰 걱정을 하지는 않으셔도 됩니다.  

> 그러면 현재 사용 중인 컴퓨터는 정말로 18,446,744,073,709,551,615 보다 큰 정수를 저장하지 못하는 걸까요?
> 꼭 그런 것만은 아닙니다. 해당 숫자보다 큰 수를 어떻게 저장할 수 있을지에 대한 것은 책의 중반정도까지 공부하고 나면 알 수 있을 겁니다.  

서론이 정말 길었습니다. 이제 위에서 이야기한 HP라는 변수를 C언어에서 어떻게 사용하는지 알아보도록 하겠습니다.  

### 변수 선언

C언어에서 변수를 사용하기 위해서는 변수를 선언(declaration)해야 합니다.  
다음 예제를 따라서 변수를 사용해봅시다.  
```c
// variable.c
#include <stdio.h>

int main(void)
{
    /* 변수를 선언함
     * int는 변수가 정수형이라는 것을 지정함
     * hp는 변수의 이름을 식별함
     * =는 변수에 초기값을 설정하겠다는 것을 알림
     * 100은 변수의 초기값을 나타냄
     */
    int hp = 100;
    printf("%d \n", hp);
    return 0;
}
```  
실행하면 다음과 같은 결과를 볼 수 있습니다.  
```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make variable
cc     variable.c   -o variable
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./variable 
100 
```  

너무나도 장대했던 서론에 비하여 굉장히 간단한 사용이었습니다.  
C언어에서 선언의 형태는 다음과 같습니다.  
```c
<선언 지정자> <초기화 선언자 리스트>;
```  
선언 지정자(declaration-specifier)에는 타입 지정자(type-specifier)같은 것들이 올 수 있습니다. (다시 말해 타입 지정자가 아닌 내용도 추가될 수 있다는 것인데, 이는 이 후 챕터들에서 천천히 다루겠습니다.) 위에서 사용한 ```int``` 같은 것들이지요. 타입 지정자는 변수가 메모리에 어떻게 저장될지를 지정합니다. 즉, 1바이트 공간을 사용하여 저장할지, 4바이트 공간을 사용하여 저장할지, 정수의 형태로 저장할지, 실수의 형태로 저장할지 등을 정하는 것인데 타입에 대한 내용은 바로 후에 조금 더 자세히 이야기하겠습니다.  
초기화 선언자 리스트(init-declarator-list)에는 선언자(declarator)와 이니셜라이저(initializer)가 올 수 있습니다. 선언자는 변수의 이름을 나타내기 위한 식별자(identifier)와 같은 요소고, 이니셜라이저란 변수에 초기 값을 지정해주기 위한 요소입니다. 그리고 이니셜라이저 앞에는 항상 ```=``` 라는 구두점을 사용하여 선언자와 구분해야 하며, 이니셜라이저는 등장하지 않을 수도 있습니다. 이론은 다소 복잡한데, 지금 당장 쉽게 이야기하면 변수 이름과 변수에 처음 할당해줄 값을 쓸 수 있다는 겁니다. 그리고 초기화 선언자 리스트는 ```,```(쉼표) 구두점을 통해 여러 개가 나올 수 있습니다. 즉, 한 번에 여러 변수를 선언할 수 있습니다.  
말로 설명하니 굉장히 어렵게 느껴집니다. 위 내용을 예시를 통해 쉽게 살펴보도록 하겠습니다.  

```c
// variable_declaration.c
#include <stdio.h>

int main(void)
{
    // int는 변수의 타입을 지정하는 선언 지정자
    int a;          // 이니셜라이저 없이 변수 이름 a를 식별하기 위한 선언자만 사용
    int b = 10;     // 변수 이름을 식별하기 위한 b라는 선언자, = 라는 구두점, 10이라는 이니셜라이저
    int c = 1, d = 2, e = 3;    // 쉼표를 통해 초기화 선언자 리스트를 여러 개 나열
    int f, g = 4, h, i = 100;   // 쉼표를 통해 초기화 선언자 리스트 여러 개 나열, 이니셜라이저는 포함할 수도 포함하지 않을 수도 있음
    // 변수 선언 이 후 별도의 작업 없이 프로그램 종료
    return 0;
}
```

보시면 아시겠지만 코드는 간단한데 오히려 주석이 더 복잡합니다. 예제 코드만 보면 대충 감으로 이해할 수 있겠는데, 부가 설명이 혼란을 가중시킵니다. 지금은 우선 변수를 사용하기 위해서는 이름을 지어줘야 하며, 해당 변수가 처음 가질 수 있는 값을 지정해 줄 수도 있고, 쉼표를 통해 한 번에 여러 개의 변수를 선언할 수도 있다고 이해하시면 됩니다. 다른 부연 설명들은 책의 후반부에 나오는 내용들을 보고 나면 좀 더 쉽게 이해할 수 있습니다.  

### 타입 지정자

위에서 사용한 ```int```와 같은 것들을 타입 지정자라고 합니다. 이 외에도 C11를 기준으로 타입 지정자는 다음과 같은 것들이 있습니다.  
* void
* __char__
* __short__
* __int__
* __long__
* __float__
* __double__
* __signed__
* __unsigned__
* _BitInt
* bool
* _Bool
* _Complex
* _Decimal32
* _Decimal64
* _Decimal128
* _atomic-type-specifier_
* _struct-or-union-specifier_
* _enum-specifier_
* _typedef-name_
* _typeof-specifier_

이 중에서 볼드체로 작성하지 않은 타입 지정자는 책의 후반부에서 마저 공부할 것입니다. 우선은 볼드체로 작성한 여덟 개의 타입 지정자에 대해 알아보도록 하겠습니다.  

위 타입 지정자 중 정수형 데이터를 저장하기 위한 타입은 char, short, int, long, signed, unsigned가 있고 실수형 데이터를 저장하기 위한 타입은 float, double이 있습니다.  
왜 정수형 데이터를 나타내는 데에만 네 가지 타입이나 존재하고 실수형 데이터를 나타내는 데에 두 가지 타입이 존재하는 걸까요?  
그것은 각 타입마다 크기가 다르기 때문입니다. 그렇기 때문에 표현할 수 있는 수의 범위도 달라지고 용도도 조금씩 달라지게 됩니다.  
추가로 사실 타입 지정자는 위에 있는 것들 중 하나만 사용할 수 있는 것이 아니라 여러 개를 조합해서 사용할 수도 있습니다. 이러한 점들을 고려하며 예제를 하나 작성해본 후, 각 타입 지정자들을 좀 더 상세히 알아보도록 하겠습니다.  

```c
// type_specifier.c
#include <stdio.h>

int main(void)
{
    int positive = 3;       // 양수 저장
    int negative = -2;      // 음수 저장
    double average = 0.5;   // 실수 저장
    char last = 'z';        // 문자 코드 저장
    unsigned long long int big_num = 18446744073709551615ULL;       // 큰 수 저장
    // 숫자 뒤에 붙은 ULL은 상수 챕터에서 알아볼 정수 접미사

    // int 타입 기본 정수 출력 서식 문자는 %d
    printf("%d is positive number\n", positive);
    printf("%d is negative number\n", negative);
    // double 타입 기본 실수 출력 서식 문자는 %f
    printf("Average is %f\n", average);
    // char 타입의 문자 출력 서식 문자는 %c
    printf("Last alphabet is %c\n", last);
    // unsigned long long int 타입 정수 출력 서식 문자는 %llu
    printf("Big size number %llu\n", big_num);
    return 0;
}
```

위 예제를 실행하면 다음과 같은 결과를 볼 수 있습니다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make type_specifier
cc     type_specifier.c   -o type_specifier
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./type_specifier 
3 is positive number
-2 is negative number
Average is 0.500000
Last alphabet is z
Big size number 18446744073709551615
```

예제 내용을 이해할 수 있도록 세부 내용을 천천히 학습해보도록 하겠습니다.

#### 정수 타입 지정자

우선 ```signed```는 부호가 있는 정수(음수를 표현할 수 있음)를 표현하는데 사용하고, ```unsigned```는 부호가 없는 정수(음수를 표현할 수 없음)를 표현하는데 사용한다는 것을 염두합시다. 조합 가능한 정수 타입들에 대한 설명은 다음과 같습니다.  

* ```char``` : __basic execution character set을 저장할 수 있도록 크기가 보장__ 됩니다. 보통 아스키코드 문자 인코딩을 사용하는 정수값을 통해 문자를 표현할 때 사용합니다. ```signed```나 ```unsigned```와 조합하여 사용하지 않으면 __부호가 있는 타입인지 부호가 없는 타입인지 보장할 수 없습니다.__ (둘 중 어떤 타입이 되더라도 basic execution character set은 저장할 수 있습니다.)
    * basic execution character set : 알파벳 대문자, 알파벳 소문자, 10개의 숫자 문자에 더해 다음 29개의 특수 문자의 집합; ```! " # % & ' ( ) * + , - . / : ; < = > ? [ \ ] ^ _ { | } ~```
    * basic execution character set이 아닌 문자를 char에 저장하는 것은 implementation-defined 입니다. 하지만 보통 char 타입이 가질 수 있는 범위 내의 문자 인코딩은 표현 가능합니다.
    * 사실 1 바이트의 엄밀한 의미는 이 basic character set을 저장할 수 있는 크기의 저장 유닛입니다. 따라서, char 타입의 크기는 1 바이트임이 보장됩니다.
* ```signed char``` : ```char```와 동일한 크기를 가지고, ```signed```임을 보장합니다.
* ```unsigned char``` : ```char```와 동일한 크기를 가지고, ```unsigned```임을 보장합니다.
* ```short```, ```signed short```, ```short int```, ```signed short int``` : 부호 있는 정수를 표현하는데 사용하며 ```int```보다 작거나 같은 크기임을 보장합니다.
* ```unsigned short```, ```unsigned short int``` : 부호 없는 정수를 표현하는데 사용하며 ```unsigned int```보다 작거나 같은 크기임을 보장합니다.
* ```int```, ```signed```, ```signed int``` : 부호 있는 정수를 표현하는데 사용합니다. ```int``` 타입은 특히 __컴퓨터 아키텍처가 연산을 수행하기 가장 좋은 타입__ 입니다.
* ```unsigned```, ```unsigned int``` : 부호 없는 정수를 표현하는데 사용하며 ```int``` 타입과 같은 크기를 갖습니다.
* ```long```, ```signed long```, ```long int```, ```signed long int``` : 부호 있는 정수를 표현하는데 사용하며 ```int```보다 크거나 같고, ```long long int```보다 작거나 같은 크기를 보장합니다.
* ```unsigned long```, ```unsigned long int``` : 부호 없는 정수를 표현하는데 사용하며, ```long int```와 같은 크기를 갖습니다.
* ```long long```, ```signed long long```, ```long long int```, ```signed long long int``` : 부호 있는 정수를 표현하는데 사용하며, ```long```보다 크거나 같은 크기를 보장합니다. 보통 최소 64비트의 크기를 보장해줍니다. (그렇지 않을 수도 있습니다.)
* ```unsigned long long```, ```unsigned long long int``` : 부호 없는 정수를 표현하는데 사용하며, ```long long int```와 같은 크기를 갖습니다.

설명이 조금 복잡해 보입니다. 우선은 문자 표현을 위해서 ```char```, 일반적인 부호 있는 정수 표현에는 ```int```, 일반적인 부호 없는 정수 표현에는 ```unsigned int```, 부호 있는 큰 정수에는 ```long long```, 부호 없는 큰 정수에는 ```unsigned long long``` 을 사용한다고 생각해주셔도 좋습니다. 그 외의 타입이 필요한 상황이 오면 이미 C언어를 어느정도 익숙하게 구사할 것이므로, 당장은 해당 다섯 개의 타입을 주로 익혀주시면 됩니다.  

> 간혹가다 char는 1바이트, short는 2바이트, int는 4바이트, long long은 8바이트와 같이 타입의 크기를 설명하는 자료들이 있습니다. 하지만 표준에서는 char가 basic execution character set을 충분히 저장할 수 있는 크기이다 (다시 말해 1바이트) 외에 크기에 대한 명시를 하고 있지 않습니다. 더군다나 과거에는 int 타입이 주로 2바이트였고, 추후에는 int가 8바이트인 시스템을 사용할 수도 있습니다. 해당 타입들의 크기를 고정해서 설명하는 자료들은 모두 틀린 자료들이니 참고하시기 바랍니다.

> 만약 크기가 고정된 타입을 사용하고 싶다면 추후에 설명할 정확히 고정된 크기의 정수 타입(Exact-width integer type)을 사용해야 합니다.

#### 음의 정수 표현

그런데 부호 있는 정수와 부호 없는 정수는 무엇이 다를까요? 그리고 컴퓨터는 어떻게 음수를 표현할까요? 독자분들께서 컴퓨터를 설계한다고 했을 때 어떻게 음수를 표현할지 한번 생각해보시기 바랍니다.  

필자는 이 질문을 받았을 때 다른 내용은 그대로 두고, 정수를 표현하는 비트 중 하나를 음수와 양수를 구분하는 데 사용하면 되지 않을까 생각했습니다. 예를 들어 부호 있는 1바이트 변수에 3이라는 값이 ```0b00000011```이라고 표현된다면, 음수는 ```0b10000011```로 표현하는 것이죠. 이런 방법을 생각하셨다면 이것도 크게 틀린 것은 아닙니다.  

하지만 더하기의 성질을 생각해보면 좀 더 나은 방법을 고안할 수도 있습니다. 절대값이 같은 양수와 음수를 더하면 0이 된다는 성질을 말이죠.  
예를들어 1바이트 signed char에 있는 2진수 ```0b01010101```에 무엇을 더하면 0이 될까요? ```0b10101011```을 더하면 어떻게 될까요? 자리 올림을 하다가 결국 1바이트로 표현할 수 있는 범위를 벗어나게 됩니다. ```0b100000000```이 되고, 8비트 범위를 벗어난 1은 버려져서 결과적으로 ```0b00000000```이 되는 것이죠.

그렇다면 더해서 0이 되는 수를 어떻게 쉽게 구할 수 있을까요? 이는 역사에 길이 남을 천재 존 폰 노이만이 제안한 2의 보수(Two's complement)로 쉽게 구할 수 있습니다.  
보수(complement)란 두 수의 합이 진법의 밑수가 되게 하는 수 입니다. 예를 들어 십진수 3의 10의 보수는 7 입니다. 보수의 성질은 디지털 논리 과목에서 더욱 자세하게 공부하도록 하고, 이진수 2의 보수 구하는 방법을 살펴보겠습니다.  
정말 쉽습니다. 먼저 이진수의 모든 자리가 1인 수에서 주어진 수를 빼면 1의 보수를 얻을 수 있습니다. 이를 더 쉽게 이야기하면 이진수의 모든 자릿수를 1은 0으로, 0은 1로 뒤집으면 1의 보수가 됩니다. 그리고 1의 보수에 1을 더하면 2의 보수가 됩니다.  
위에서 예시로 든 ```0b01010101```의 경우 모든 자릿수를 뒤집어서 1의 보수를 구하면 ```0b10101010```이 됩니다. 여기에 1을 더하면 2의 보수인 ```0b10101011```이 되죠.  
하나만 더 예시로 들어서 ```0b00000011```의 1의 보수는 ```0b11111100```입니다. 여기에 1을 더해서 2의 보수를 구하면 ```0b11111101``` 입니다.  
원래 수와 구한 2의 보수를 더해봅시다. 항상 표현 가능한 범위 내의 모든 자리가 0이 될 것입니다. 심지어 0에 대한 2의 보수를 구해보면 이조차 0이 되는 것을 볼 수 있습니다.  
또한, 0을 제외한 정수들을 양수와 음수 상관 없이 2의 보수를 구하면 그 결과 가장 큰 비트(가장 왼쪽의 비트)가 뒤집어지며, 2의 보수로 표현한 음수들은 가장 큰 비트가 1인 것을 확인할 수 있습니다.
이 외에도 2의 보수로 음의 정수를 나타냄으로써 빼기 연산을 음수에 대한 더하기 연산으로 효율적으로 대체할 수도 있습니다. (예를 들어 5 - 3이라는 식을 5 + (-3)이라는 식으로 계산할 수 있습니다.)

> Q. 부호 비트를 사용해서 음의 정수를 나타내는 방법은 2의 보수를 사용해서 음의 정수를 나타내는 것보다 좋지 않은 것이 더하기/빼기 연산의 효율 외에 무엇이 더 있을까요?

> A. 부호 비트를 사용해서 음의 정수를 나타내면 양의 0과 음의 0이 따로 존재하게 됩니다. (0b00000000도 0b10000000도 0을 나타냅니다.) 서로 다른 비트 배열이 같은 수를 표현하는 것은 데이터의 낭비입니다.

> Q. 부호 있는 타입이 2의 보수로 음수를 나타내는 경우, 표현할 수 있는 양수의 절대값 범위와 음수의 절대값 범위가 동일한가요?

> A. 2의 보수에서는 음의 0 대신 음수 하나를 더 표현할 수 있습니다. 예를 들어, signed char가 표현할 수 있는 (0을 제외한) 양수의 범위가 1 ~ 127이라면 음수는 -128 ~ -1 입니다. 음의 0을 표현했던 0b10000000을 -128을 표현하는 데에 사용할 수 있습니다.

이렇게 저희는 컴퓨터가 음의 정수를 표현하는 방법을 잘 숙지할 수 있었습니다. 서론에서 했던 이야기를 다시 하면, 부호 있는 정수 타입은 가장 큰 비트(가장 왼쪽 비트)를 부호 비트로 표현하고, 2의 보수를 통해 음수를 표현하고 있습니다. 그리고 부호 없는 정수 타입은 가장 큰 비트도 양수의 값을 표현하는데 사용하여 0부터 해당 비트 크기로 표현할 수 있는 최대 수까지 표현할 수 있습니다. (예를 들어 unsigned char는 0 ~ 255까지 표현할 수 있습니다.)

#### 정수 오버플로우

그런데 가만 생각해보니 변수는 값이 변할 수 있는 임시 저장소이므로, 변수에 있는 값을 더하거나 빼거나 수정할 수 있다고 했습니다. 그리고 signed char 타입은 -128 ~ 127 까지 값을 표현할 수 있다고 하였습니다. 그렇다면 signed char 변수에 127을 저장한 후, 변수에 저장된 값을 1 더하면 어떻게 될까요? 그리고 애초에 signed char 변수에 128 이라는 값을 저장하려고 하면 어떻게 될까요? 예제를 통해 확인해보겠습니다.

```c
// integer_overflow.c
#include <stdio.h>

int main(void)
{
    signed char num = 127;              // 표현할 수 있는 가장 큰 수 저장
    signed char out_of_range = 128;     // 범위를 벗어난 수 저장

    // num 출력
    printf("%d \n", num);
    
    // num에 있는 값을 1 증가시킴
    num = num + 1;

    // num 다시 출력
    printf("%d \n", num);
    
    // 애시당초 범위 벗어난 수 출력
    printf("%d \n", out_of_range);
    return 0;
}
```

```num = num + 1``` 이라는 식은 바로 다음 챕터에서 자세히 설명하겠지만, 변수 ```num```에 있는 값을 1 증가시키는 식입니다.  
그러면 어떤 결과가 나올까요? 실행하기 전에 한번 예상해보시기 바랍니다. 결과는 다음과 같습니다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make integer_overflow
cc     integer_overflow.c   -o integer_overflow
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./integer_overflow 
127 
-128 
-128 
```

실로 놀라운 결과이지만 어찌보면 당연한 결과입니다. 기존에 ```num```에는 ```0b01111111```이 저장되어 있었습니다. 여기에 1을 더하면 ```0b10000000```이 됩니다. 그런데 signed char에서 ```0b10000000```는 음수 -128이기 때문에 의도했던 128이 아닌 음수 -128을 출력했습니다. ```out_of_range``` 변수에 저장한 128도 마찬가지로 ```0b10000000```을 해당 변수에 저장했지만, signed char에서 -128로 해석하기 때문에 음수 -128을 출력한 것입니다.  
이렇게 정수와 관련된 산술 연산에서 표현할 수 있는 수의 범위를 벗어나 의도하지 않은 결과를 만들어 내는 것을 정수 오버플로우(Integer Overflow)라고 합니다.  

그리고 보니 부호가 없는 ```unsigned``` 변수들은 어떻게 될까요? 그리고 표현할 수 있는 가장 작은 수 보다 더 작은 수가 만들어지는 경우는 어떻게 될까요? 이것도 예제로 확인해보도록 하겠습니다.  

```c
// integer_overflow2.c
#include <stdio.h>
#include <limits.h>     // XXX_MIN과 XXX_MAX를 사용하기 위한 헤더 파일

int main(void)
{
    unsigned int unum_max = UINT_MAX;   // unsigned int 타입으로 표현할 수 있는 가장 큰 수
    unsigned int unum_min = 0;          // unsigned int 타입으로 표현할 수 있는 가장 작은 수
    int num_max = INT_MAX;              // int 타입으로 표현할 수 있는 가장 큰 수
    int num_min = INT_MIN;              // int 타입으로 표현할 수 있는 가장 작은 수
    
    // unsigned int 타입 정수 출력 서식 문자는 %u, unum_max 변경 전 출력
    printf("[before] unum_max : %u \n", unum_max);
    // unum_max에 있는 값 1 증가
    unum_max = unum_max + 1;
    // unum_max 변경 후 출력
    printf("[after] unum_max : %u \n", unum_max);

    // unum_min 변경 전 출력
    printf("[before] unum_min : %u \n", unum_min);
    // unum_min에 있는 값 1 감소
    unum_min = unum_min - 1;
    // unum_min 변경 후 출력
    printf("[after] unum_min : %u \n", unum_min);

    // num_max 변경 전 출력
    printf("[before] num_max : %d \n", num_max);
    // num에 있는 값 1 증가
    num_max = num_max + 1;
    // num_max 변경 후 출력
    printf("[after] num_max : %d \n", num_max);

    // num_min 변경 전 출력
    printf("[before] num_min: %d \n", num_min);
    // num에 있는 값 1 감소
    num_min = num_min - 1;
    // num_max 변경 후 출력
    printf("[after] num_min : %d \n", num_min);

    return 0;
}
```

이번 예제에서는 ```#include <limits.h>``` 라는 처음 보는 헤더 파일과 ```UINT_MAX```, ```INT_MAX```, ```INT_MIN``` 라는 처음 보는 값을 사용했습니다. (대소문자가 틀리면 안됩니다.)  
타입 지정자에 대해 설명할 때 각 타입이 갖는 크기가 고정되어 있지 않다고 했습니다. 그러다보니 환경에 따라 특정 타입이 표현할 수 있는 수의 범위가 달라지게 되었습니다. 따라서 어떤 환경에서든지 특정 타입이 가질 수 있는 최대값과 최소값을 ```limits.h``` 라는 헤더 파일에 정의하고 있습니다. 이러한 값은 소스코드를 컴파일 하기 전에(컴퓨터가 해석하고 실행 가능한 기계어로 번역하기 전에) 전처리라는 단계에서 미리 정해진 값으로 치환됩니다. 예를 들어 ```int``` 타입이 4바이트인 시스템인 현재 실습 환경에서 ```INT_MAX```는 2147483647 라는 정수로 치환되고, ```INT_MIN```은 -2147483648으로 치환됩니다. ```int``` 타입이 2바이트인 시스템에서는 ```INT_MAX```가 32767으로 치환되고 ```INT_MIN```이 –32768으로 치환되는 것이죠. 이러한 정수로 표현 가능한 최소값과 최대값은 바로 다음에 표로 정리해두겠습니다. (참고로 부호 없는 타입이 가질 수 있는 최소 값은 공통적으로 0이기 때문에 UINT_MIN과 같은 것은 정의되어 있지 않습니다.)

그럼 이제 예제를 실행해보겠습니다. 결과는 다음과 같습니다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make integer_overflow2
cc     integer_overflow2.c   -o integer_overflow2
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./integer_overflow2
[before] unum_max : 4294967295 
[after] unum_max : 0 
[before] unum_min : 0 
[after] unum_min : 4294967295 
[before] num_max : 2147483647 
[after] num_max : -2147483648 
[before] num_min: -2147483648 
[after] num_min : 2147483647 
```

마찬가지로 표현할 수 있는 가장 큰 수에서 1이 증가하면 표현할 수 있는 가장 수가 되었고, 표현할 수 있는 가장 작은 수에서 1이 감소하면 표현할 수 있는 가장 작은 수가 되었습니다. 즉, 부호 없는 정수는 가장 큰 수와 0간의 변경이 일어나고, 부호 있는 정수는 절대값이 가장 큰 양수와 절대값이 가장 큰 음수 간 변경이 일어났습니다.  

정수로 표현할 수 있는 가장 큰 수의 범위보다 커지는 경우 정수 오버플로우라고 했습니다. 그러면 정수로 표현할 수 있는 가장 작은 수의 범위보다 작아진 경우는 뭐라고 할까요? 이 또한 마찬가지로 정수 오버플로우라고 합니다. 정수가 가장 큰 수보다 커지든 가장 작은 수 보다 작아지든 표현할 수 있는 범위를 벗어나는 경우 모두 정수 오버플로우라고 합니다.

> 간혹가다 정수로 표현할 수 있는 갖아 작은 수보다 작아지는 경우 언더플로우라고 설명하는 자료들이 있습니다. 이는 모두 틀린 자료이니 유의하시기 바랍니다. (언더플로우는 실수에서만 일어납니다.)

그러면 ```limits.h``` 헤더 파일에서 제공하는 각 타입별 표현할 수 있는 최소값과 최대값을 정리하고 정수에 대한 이야기를 마무리하겠습니다. (참고로 이러한 값들을 매크로 값이라고 합니다.)  

| 타입 | 최소값 | 최대값 |
|:-----:|:-----:|:-----:|
| ```char``` | ```CHAR_MIN``` | ```CHAR_MAX``` |
| ```signed char``` | ```SCHAR_MIN``` | ```SCHAR_MAX``` |
| ```unsigned char``` | ```0``` | ```UCHAR_MAX``` |
| ```short``` <br> ```signed short``` <br> ```short int``` <br> ```signed short int``` | ```SHRT_MIN``` | ```SHRT_MAX``` |
| ```unsigned short``` <br> ```unsigned short int``` | ```0``` | ```USHRT_MAX``` |
| ```int``` <br> ```signed``` <br> ```signed int``` | ```INT_MIN``` | ```INT_MAX``` |
| ```unsigned``` <br> ```unsigned int``` | ```0``` | ```UINT_MAX``` |
| ```long``` <br> ```signed long``` <br> ```long int``` <br> ```signed long int``` | ```LONG_MIN``` | ```LONG_MAX``` |
| ```unsigned long``` <br> ```unsigned long int``` | ```0``` | ```ULONG_MAX``` |
| ```long long``` <br> ```signed long long``` <br> ```long long int``` <br> ```signed long long int``` | ```LLONG_MIN``` | ```LLONG_MAX``` |
| ```unsigned long long``` <br> ```unsigned long long int``` | ```0``` | ```ULLONG_MAX``` |
 
#### 실수 타입 지정자

실수형은 다행히도 정수형보다 가능한 조합이 적습니다. 사용할 수 있는 실수 타입 지정자는 다음과 같습니다.

* float : 단정밀도(Single Precision)를 갖는 부동 소수점 실수 타입입니다.
* double : 배정밀도(Double Precision)를 갖는 부동 소수점 실수 타입입니다. float 타입보다 크거나 같은 정밀도를 갖습니다.
* long double : 확장 정밀도(Extended Precision)를 갖는 부동 소수점 실수 타입입니다. double 타입보다 크거나 같은 정밀도를 갖습니다.
* _Decimal32 : 32비트로 표현하는 고정 소수점 실수 타입입니다.
* _Decimal64 : 64비트로 표현하는 고정 소수점 실수 타입입니다.
* _Decimal128 : 128비트로 표현하는 고정 소수점 실수 타입입니다.
* float _Complex : float 타입 복소수와 허수 표현을 위한 실수 타입입니다.
* double _Complex : double 타입 복소수와 허수 표현을 위한 실수 타입입니다.
* long double _Complex : long double 타입 복소수와 허수 표현을 위한 실수 타입입니다.

여기서 중요한건 고정 소수점 실수 타입과 복소수 표현을 위한 _Complex 실수 타입은 선택 표준이기 때문에 컴파일러가 제공하지 않을 수도 있다는 것입니다. 따라서 해당 서적에서는 위 세 타입에 대해 주로 다룰 것입니다.  

> 아래 여섯 개의 타입은 _IEC 60559_ 표준에 맞춰 구현한 타입으로, C 컴파일러는 이를 선택적으로 구현할 수 있습니다.

각 타입의 설명에서 부동 소수점 실수와 고정 소수점 실수라는 이야기를 했습니다. 이는 컴퓨터가 실수를 표현하는 방식을 정의합니다. 부동 소수점 실수는 소수점 자릿수가 정해지지 않고 굉장히 넓은 범위의 실수를 표현할 수 있습니다. 하지만 수를 표현할 때 가수와 지수라는 것을 이용하여 근사하여 표현하기 때문에 대부분의 수에 대해 정확한 값을 표현할 수 없고 연산 속도가 느립니다. 반면 고정 소수점 실수는 고정된 자릿수의 소수점 표현을 통해 정확한 실수 값을 나타낼 수 있습니다. 해당 방식은 부동 소수점에 비해 굉장히 좁은 범위의 수만 표현할 수 있습니다.  

컴퓨터에서 실수를 사용할 때는 넓은 표현 범위를 요구하는 경우가 많기 때문에 부동 소수점 방식을 주로 사용합니다. 고정 소수점 방식은 주로 정확한 실수 값 계산이 필요한 경우 사용하는데, 사실 이는 부동 소수점 실수를 정수로 변환하여 계산하는 것으로도 해결할 수 있습니다.  
부동 소수점 실수를 사용할 때 중요한 사실은 표현하는 값이 대부분 참값이 아닌 근삿값이라는 것입니다. 즉, ```123.456789``` 라는 값을 저장하면 그게 정말로 해당 값이 아닌 부동 소수점으로 표현 가능한 ```123.456789```와 가까운 근삿값이 저장된다는 것입니다. 좀 더 와닿을 수 있도록 예제를 통해 확인해보도록 하겠습니다.

```c
// float_precision.c
#include <stdio.h>

int main(void)
{
    float float_number = 123.456789;
    double double_number = 123.456789;
    printf("%f %f\n", float_number, double_number);
    return 0;
}
```

실행 결과는 다음과 같습니다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make float_precision
cc     float_precision.c   -o float_precision
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./float_precision 
123.456787 123.456789
```

둘 다 ```123.456789``` 라는 실수를 저장하고 출력했는데, 결과는 하나만 정확하게 나왔습니다. 이는 부동 소수점 표현 방식을 이용하여 근삿값을 저장하는 와중에, ```float``` 타입과 ```double``` 타입의 정밀도(precision)가 다르기 때문입니다. 정밀도란 근삿값 표현에서 위와 같은 오차(정보 손실) 없이 나타낼 수 있는 자릿수를 의미합니다. C 표준에서는 부동 소수점 타입들의 정밀도를 따로 정의하고 있지는 않습니다. ```double``` 타입으로 표현 가능한 실수는 ```long double``` 타입으로 표현 가능한 실수의 부분집합이고, ```float``` 타입으로 표현 가능한 실수는 ```double``` 타입으로 표현 가능한 실수의 부분집합이라는 것만 정의하고 있죠. 다만 대다수의 시스템이 부동 소수점 표현은 _IEEE 754_ 표준에 맞춰서 구현하고 있으므로, 다음과 같은 특성을 갖습니다. (다시 말해, _IEEE 754_ 표준을 따르지 않는 일부 시스템에서는 아래 특성이 맞지 않을 수 있습니다.)

| 타입 | 표현 가능한 가장 작은 양수 | 표현 가능한 가장 큰 양수 | 정밀도 | 크기 |
|:-----:|:-----------------------:|:----------------------:|:-----:|:----:|
| ```float``` | $1.17549 * 10^{-38}$ | $3.40282 * 10^{38}$ | 6자리 | 4바이트 |
| ```double``` | $2.22507 * 10^{-308}$ | $1.79679 * 10^{308}$ | 15자리 | 8바이트 |

```long double```은 구현에 따라 잦은 차이를 보이므로, ```double``` 타입보다 크거나 같은 표현 범위, 정밀도, 크기를 갖는다고만 알아두시면 됩니다. 독자분들께서는 정밀도가 중요하지 않은 경우엔 ```float```을 사용하고, 그 외에는 대부분 ```double```을 사용한다고 생각해주시면 되겠습니다.

> _IEEE 754_ 표준에 맞춰 구현한 부동 소수점 실수 타입은 항상 부호가 있습니다. (음수를 표현할 수 있습니다.)

> 위에서 언급한 바와 같이 부동 소수점 실수 연산은 정수 연산에 비하여 굉장히 수행 속도가 느립니다. 따라서 실수 연산을 수행할땐 정말 실수가 필요한 상황인가, 정수로 변환하여 계산할 수는 없는가 등의 고민을 하고 꼭 필요한 경우에만 사용하는 것이 좋습니다.

#### 실수 표현

이번 절에서는 부동 소수점 실수 표현 방식에 대해 조금 더 자세히 살펴볼 것입니다. 부동 소수점 표현 방식에 대해 궁금하지 않은 독자분들께서는 이번 절은 과감하게 넘긴 후, 필요할 때 다시 보셔도 괜찮습니다.

TODO : IEEE 754에 따른 부동 소수점 표현 방식 설명하기, 실수 언더플로우 설명하기

### 변수 작명하기

이제 저희는 원하는 타입의 변수를 선언할 수 있게 됐습니다. 남은 것은 변수의 이름을 어떻게 지어야할 지 입니다. 장난스럽게 하는 이야기 중에, 프로그래머가 가장 힘들어 하는 일에 대한 설문 중 1위가 이름 짓기일 정도로 이름 짓기(네이밍)은 까다로운 일입니다.  

![naming](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B3%80%EC%88%98%EC%99%80%20%EC%83%81%EC%88%98/difficult.png?raw=true)  

변수의 이름과 같은 것을 식별자(identifier)라고 합니다. 참고로 식별자는 다음과 같은 것을 나타냅니다.  
* 속성(attribute)
* 오브젝트, 함수
    * 오브젝트는 값을 나타낼 수 있는 데이터 저장 영역을 의미합니다. 대표적인 오브젝트로 변수가 있습니다.
* 태그(tag)나 구조체, 공용체, 열거형의 멤버
* typedef 이름
* 레이블 이름
* 매크로 이름
* 매크로 인자(parameter)

우리는 이 식별자를 통해서 변수를 식별하고 나타낼 수 있습니다. 쉽게 말해 변수에 식별자라는 이름을 지어주고 사용할 수 있습니다. 식별자를 짓는 데에는 다음과 같은 규칙이 있습니다.  
* 식별자의 시작 문자는 _(언더바), 알파벳 소문자, 알파벳 대문자 중 하나이다.
* 식별자의 나머지 문자는 _(언더바), 알파벳 소문자, 알파벳 대문자, 숫자 중 하나이다.
* 식별자로 키워드를 사용하면 안된다.
* _(언더바) 혹은 중첩 언더바(__) 이 후에 영어 대문자를 사용할 수 없다.
* _(언더바)로 시작하는 식별자는 파일 범위를 가져야 한다.

> 파일 범위에 대한 내용은 파일 분할 챕터와 스토리지 클래스 챕터에서 다시 알아보겠습니다.

> 추후에 다시 언급하겠지만, Include Guard를 위한 매크로 식별자를 ```_MY_HEADER_H_``` 와 같이 정의하는 경우를 더러 볼 수 있습니다. 이는 충돌을 일으킬 수 있는 잘못된 행위이며, ```MY_HEADER_H``` 와 같이 정의하는 것이 옳습니다.

여기서 키워드란 C언어에서 구문으로 사용하기 위해 미리 정의된 예약어입니다. 우리는 이미 ```int```, ```long```, ```void```, ```return``` 등의 키워드를 접한 적이 있습니다. 이러한 키워드는 소스 코드 내에서 특수한 목적으로 사용하기 때문에 식별자로 사용할 수 없습니다. C23에서 정의한 키워드 목록은 다음과 같습니다.

```c
// 추후 편집 필요

alignas
alignof
auto
bool
break
case
char
const
constexpr
continue
default
do
double
else
enum
extern
false
float
for
goto
if
inline
int
long
nullptr
register
restrict
return
short
signed
sizeof
static
static_assert
struct
switch
thread_local
true
typedef
typeof
typeof_unqual
union
unsigned
void
volatile
while
_Atomic
_BitInt
_Complex
_Decimal128
_Decimal32
_Decimal64
_Generic
_Imaginary
_Noreturn
```

위 내용들을 조금 더 알기 쉽게 예제를 통해서 식별자의 특성을 알아보도록 하겠습니다.  

```c
// variable_naming.c
#include <stdio.h>

int main(void)
{
    /* 정상적인 식별자들 */
    int foo, bar;   // 영어 소문자로 이루어진 변수
    int Foo, Bar;   // 영어 대문자로 시작하는 변수, 식별자는 대소문자를 구분하기 때문에 위의 foo, bar와 서로 다른 변수
    int FOO, BAR;   // 영어 대문자로 이루어진 변수, 식별자는 대소문자를 구분하기 때문에 위의 foo, bar, Foo, Bar와 서로 다른 변수
    int _inner;     // 언더바로 시작하는 변수, 파일 범위를 가져야 함
    int foo_bar;    // 알파벳과 언더바로 이루어진 변수
    int hello_world;    // 스페이스바 대신 언더바를 사용한 변수
    int var1, var2; // 알파벳과 숫자로 이루어진 변수
    
    /* 비정상적인 식별자들 */
    int 6to9;       // 숫자로 시작할 수 없음
    int 한글변수;    // 영어, 숫자, 언더바 외의 문자가 올 수 없음
    int hello world;    // 변수 이름에 스페이스바가 올 수 없음
    int __Hello;    // 언더바로 시작한 후 대문자가 올 수 없음
    int return, int, struct, auto, nullptr, for, true;  // 변수 이름으로 키워드를 사용할 수 없음

    return 0;
}
```

예제에서 특히 주의해야 할 점은, 식별자에서 대소문자가 구분된다는 것입니다. 이를 case-sensitive 하다 라고 합니다. 그리고 변수 이름 내에 스페이스가 포함될 수 없고, 대신 언더바를 사용하는 것을 볼 수 있습니다.  

#### 좋은 식별자 만들기

위 규책대로라면 모든 변수 이름을 ```a```, ```aa```, ```aaa``` 혹은 ```a1```, ```a2```, ```a3``` 등과 같이 지을 수도 있습니다. 하지만 식별자의 이름을 아무렇게나 지으면 소스 코드를 보는 사람이 해당 변수가 어떤 의도를 가지고 쓰였는지 알 수가 없습니다. 따라서 식별자는 규칙을 지키는 것 만큼이나 __의도를 나타내는 것__ 이 중요합니다. 예를 들어 다음과 같이 말이죠.  

```c
int hp, mp;
int max_damage;
```

위와 같이 작성하면 해당 변수가 HP나 MP를 사용하는데 사용하는구나, 데미지의 최대값을 나타내는데 사용하는구나 라는 것을 쉽게 알 수 있습니다. 그리고 또 중요한 것은 이렇게 정의한 변수를 다른 용도로 사용하면 안 된다는 것입니다. 예를 들어 ```hp``` 변수를 갑자기 레벨을 나타내는데 사용한다던지 하는 것은 금기입니다.

이 외에도 표준 라이브러리에서 제공하는 함수 이름 등의 식별자를 사용하는 것도 권장하지 않습니다. 예를 들어 ```printf``` 라는 이름의 변수를 정의하는 것은 좋지 않습니다. 이는 추후에 이야기할 식별자 범위(scope)와 관련된 문제를 야기합니다.  

그런데 식별자를 만들다보면 여러 단어들을 띄어쓰기로 조합해야 하는 경우가 종종 생깁니다. 위의 예시에서 ```max_damage```는 max라는 단어와 damage라는 단어를 조합했습니다. 추후에 이야기할 함수의 식별자를 정의할 때는 특히나 여러 단어들을 조합하게 됩니다. 예를 들어 'find my unit' 와 같이 동사를 포함한 행위를 의도하는 경우가 많습니다. 이렇게 여러 단어를 조합하여 식별자를 정의해야 하는 경우 많은 경우 네 가지 표기법 중 하나를 사용합니다.

* snake_case : 띄어쓰기를 언더바 문자로 사용하고, 시작 문자는 항상 소문자이며, 대부분 소문자로 표기한다.
* SCREAMING_SNAKE_CASE : 띄어쓰기를 언더바 문자로 사용하고, 모든 문자를 대문자로 표기한다.
    * 대부분의 경우 상수나 매크로 정의에 사용합니다.
* camelCase : 띄어쓰기를 사용하지 않고, 시작 문자는 소문자이며, 합성어의 첫 글자만 대문자로 표기한다.
    * 시작 문자의 대소문자 제약을 두지 않고 아래 PascalCase와 구분하지 않는 경우도 있습니다.
* PascalCase : 띄어쓰기를 사용하지 않고, 시작 문자는 대문자이며, 합성어의 첫 글자를 대문자로 표기한다.

식별자의 예를 들면 다음과 같습니다.

```c
max_damage, find_my_unit, is_error      // snake_case

maxDamage, findMyUnit, isError          // camelCase

MaxDamage, FindMyUnit, IsError          // PascalCase
```

그리고 이러한 명명 규칙들을 네이밍 컨벤션이라고 합니다. 그리고 위 컨벤션 중 어느 것을 사용해도 상관 없지만, 정해진 컨벤션을 고수하는 것이 좋습니다. 예를 들어 변수를 위한 식별자는 모두 camelCase를 사용하고 함수를 위한 식별자는 모두 PascalCase를 사용한다던지, 변수나 함수나 모두 snake_case를 사용한다던지 등 한 프로그램을 작성하는 데에는 컨벤션을 통일해야 합니다. 참고로 UNIX 계열과 C언어에서는 snake_case를 주로 사용하기 때문에 앞으로 해당 서적에서는 일부를 제외하고 snake_case로 통일하겠습니다.

### 변수 갖고 놀기

여태까지 지루한 이론 공부를 이어오느냐고 고생 많으셨습니다. 이번 절에서는 독자분들의 흥미를 돋을 수 있도록 연산자 챕터나 반복문 챕터에서 배울 내용을 조금 당겨와서 재밌는 예제를 만들어보겠습니다.  

우선 변수 없이 구구단을 출력한다고 생각해봅시다.
```c
printf("2 * 1 = 2\n");
printf("2 * 2 = 4\n");
printf("2 * 3 = 6\n");
...
```
2단부터 9단까지 출력하려면 72번의 printf문을 사용해야 합니다. 문자열 하나안에 개행 문자를 여러번 사용하는 꼼수를 사용하더라도 작성해야 하는 코드가 너무 길어집니다.

이를 변수와 반복문을 사용하여 마법같이 줄여보도록 하겠습니다.

```c
// mul_table.c
#include <stdio.h>

int main(void)
{
    int i;      // 변수 i 선언
    for (i = 2; i < 10; i++) {      // i를 2부터 9까지 1씩 증가시키며 반복
        int j;      // 변수 j 선언, C99 이 전에는 해당 위치에 선언할 수 없었음
        for (j = 1; j < 10; j++) {      // j를 1부터 9까지 1씩 증가시키며 반복
            printf("%d * %d = %d\n", i, j, i * j);
        }
    }
    return 0;
}
```

위 예제를 실행한 결과는 다음과 같습니다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make mul_table
cc     mul_table.c   -o mul_table
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./mul_table 
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14
2 * 8 = 16
2 * 9 = 18
3 * 1 = 3
3 * 2 = 6
3 * 3 = 9
...
```

정말 놀라운 일이 아닐 수 없습니다. 그토록 힘들었던 일을 단 몇 줄 만으로 줄여버렸습니다. 이것이 바로 프로그래밍의 묘미입니다.  

위 예제에서 ```for``` 키워드는 반복문을 만들 때 사용합니다. 사용법은 반복문 챕터에서 설명할 예정이니, 지금은 ```i```의 값을 2부터 1씩 증가시키며 10보다 작을 때까지 반복하고, ```j```의 값을 1부터 1씩 증가시키며 10보다 작을 때까지 반복한다고 생각해주시면 됩니다.  

그런데 예제에서 변수 선언에 대한 중요한 사실이 하나 더 있습니다. 바로 변수 선언 위치입니다.  
C99 표준이 제정되기 전까지(C89 등) C언어에서 모든 변수는 복합 문장(Compound Statement)의 최상단에 위치했어야 합니다. 즉, 위 예제에서 변수 ```j```의 선언이 변수 ```i```와 함께 ```main``` 함수의 상단에 있어야 했습니다. 그런데 C99 표준부터는 선언이 복합 문장의 상단에 위치하지 않아도 되도록 변경되었습니다. 따라서 변수 ```j```를 ```for``` 문 내에서 사용 직전에 선언할 수 있었습니다. (사실 ```for``` 문은 좀 더 간결하게 사용할 수 있지만, 이는 반복문 챕터에서 다시 알아보도록 하겠습니다.)

따라서 C99 이 후 표준을 사용한다면 이번 챕터에서 작성했던 ```type_specifier.c``` 예제를 다음과 같이 작성할 수도 있습니다.

```c
// type_specifier2.c
#include <stdio.h>

int main(void)
{
    int positive = 3;
    printf("%d is positive number\n", positive);

    int negative = -2;
    printf("%d is negative number\n", negative);

    double average = 0.5;
    printf("Average is %f\n", average);

    char last = 'z';
    printf("Last alphabet is %c\n", last);

    unsigned long long int big_num = 18446744073709551615ULL;
    printf("Big size number %llu\n", big_num);
    return 0;
}
```

이 때 주의할 점은, C언어에서 변수는 적어도 사용되기 전에는 선언되어야 한다는 것입니다. 다음과 같이 사용할 수는 없다는 것을 유의해야 합니다. (당장의 에러를 넘어, scope 문제가 동반된 예상치 못한 상황을 야기할 수도 있습니다.)

```c
printf("%d is positive number\n", positive);    // 먼저 사용
int positive = 3;       // 추후 선언
```

### 변수 타입 추론하기

독자분들께서 다양한 변수 타입을 공부하면서 어떤 생각이 드셨나요? 공부해야 할 타입이 너무 많고, 각 타입들에 대해 신경써야 할 내용이 너무 많다고 느끼시지는 않으셨나요?  
학습 능력이 유별나게 좋은 독자분들께서는 할만하다고 느끼셨을 수도 있습니다. 하지만 배열, 포인터, 구조체 등 타입이 복잡해질수록 신경쓸 내용이 더욱 많아지고 복잡함을 가중시킬 수도 있습니다.  

C++에서는 C++11 표준부터 프로그래머에게 편의를 제공하기 위하여 다음 예제와 같이 ```auto``` 키워드에 타입 추론이라는 추가 기능을 제공하기 시작했습니다.  
```cpp
auto r = 3.5;       // 변수 r은 double 타입으로 추론됨
```  

원래 ```auto```는 스토리지 클래스라는 것을 지정하는데 사용하는 키워드였습니다. 스토리지 클래스는 책의 후반부에서 설명할 예정인데, ```auto``` 지정자가 사용된 변수는 함수와 같이 중괄호 블록으로 구성된 복합 문장 내에서 자동으로 할당되었다가 블록에서 빠져나갈 때 자동으로 해제된다는 의미입니다. 사실 여태까지 저희가 ```main``` 함수 내에서 선언한 모든 변수가 이 ```auto``` 스토리지 클래스 변수입니다. (해당 변수들은 ```main``` 함수가 시작되면 자동으로 할당되어서, ```main``` 함수가 종료될 때 자동으로 해제됩니다.) 스토리지 클래스 지정자는 경우에 따라 생략할 수 있기 때문에 여태까지 따로 지정하지 않은 것입니다. 여태까지 선언한 변수들에 ```auto``` 지정자를 사용하여 다음과 같이 선언할 수도 있습니다.

```c
auto int positive = 3;      // auto 스토리지 클래스 지정자
printf("%d is positive number\n", positive);
```

원래 변수 선언 시에 타입 지정자가 필요합니다. 그런데 ```auto``` 지정자 뒤에 타입 지정자를 생략하면, ```auto``` 스토리지 클래스 변수의 타입을 컴파일러가 알아서 추론해주도록 한 것입니다.

C언어 서적에서 왜 갑자기 C++의 내용을 설명하냐구요? C23 표준에도 이 타입 추론 기능이 추가되었기 때문입니다.  
사실 C 표준에 타입 추론 기능이 추가되었어도, C 프로그래머들이 해당 기능을 이용할지는 미지수입니다. 타입 추론을 사용하는데에도 따로 신경써야 할 문제들이 생깁니다. 예를 들어 다음과 같은 문제가 생길 수 있습니다. (해당 예제는 단순히 문제 상황 제기를 위한 것이므로 지금 당장 이해하실 필요는 없습니다.)  

```c
int main(void)
{
    double a = 3, b = 5;
    {
        auto a = a * 2;     // 유효하지 않음 (초기화 하는데 사용한 a가 블록 내의 a가 되었음)
    }
    {
        auto a = b * 2;     // 유효함
    }
    return 0;
}
```

이 밖에도 타입 추론 과정에서 생기는 혼란스러움 등으로 타입 추론 기능은 잘 사용되지 않을 수도 있습니다. 독자분들께는 C++에서 사용하던 타입 추론 기능이 C23에도 편입되었다는 것만 인지하고 있다가 C 프로그램에도 ```auto``` 타입 추론이 사용되기 시작되었다는 소식이 들리면 그 때부터 천천히 사용하시는 것을 추천드립니다.

## 상수

상수란 __그 자체로 표현되는 값__ 을 의미한다. 상수는 변수와 달리 실행 도중에 변경할 수 없다. 그리고 그 자체로 표현되는 값이기 때문에 메모리에 따로 저장되지 않고, 기계어로 번역되었을 때 바로 표현된다. C23에서 정의한 상수의 종류는 크게 다음과 같은 다섯가지가 있다.  

* 정수 상수 (integer-constant)
* 실수 상수 (floating-constant)
* 열거 상수 (enumeration-constant)
* 문자 상수 (character-constant)
* 미리 정의된 상수 (predefined-constant)

엄밀히 말해서 C23 표준에서 정의한 상수는 위 다섯 가지가 전부이다. (이 중 열거 상수는 추후에 알아볼 것이다.) 하지만 C언어를 떠나 프로그래밍 언어론적으로 상수를 __실행 도중에 변경되지 않는 값__ 으로 정의하기도 한다. 그래서 간혹 문자열 리터럴이나 const 오브젝트를 상수와 혼동하기도 한다. 하지만 이들은 엄연히 실행 중 메모리에 저장되는 오브젝트이다. 이번 챕터는 C언어에서 엄밀히 정의한 상수와, 이러한 유사 상수에 대해 학습할 것이다.

> 간혹가다가 상수를 그 자체로 표현된다는 의미의 리터럴이라고 칭하기도 한다. C17 표준까지는 상수는 명확히 상수(constant)라고만 표현했지만, C23에서는 새로 추가된 이진 상수를 이진 리터럴(binary integer literal)이라고 표현하기도 했다.

### 상수(Constant)

상수는 __값의 형태를 표현하기 위한 타입__ 을 갖는다. 예를 들어 3이라는 상수는 ```int``` 타입을 갖는다. 하지만 ```INT_MAX``` 값을 넘어가는 상수는 ```int``` 타입으로 나타낼 수 없기에 ```long int```나 ```long long int``` 타입을 가져야 한다. 이렇게 상수의 타입이 달라지면 기계어에서의 표현법이 달라지기 때문에 상수가 타입을 갖는다는 사실은 중요하다.  
그리고 상수는 표기법에 따라 상수의 종류를 지정할 수도 있다. 예를 들어 위에서 여러번 이야기한 것처럼 ```10``` 이라고 하면 십진수 상수 10을 표현하지만 ```0b10``` 이라고 하면 이진수 상수 2를 표현한다.  
각 상수의 종류 별로 접두사(prefix)와 접미사(suffix) 등을 통해서 세부 종류를 지정하거나 타입을 지정하는 방법을 알아보자.

> 사실 상수의 타입은 대부분의 경우 컴파일러가 알아서 잘 처리해주며, 잘못된 경우가 있으면 경고를 띄어준다. 따라서 프로그래밍을 처음 접하는 독자는 정수 상수와 실수 상수는 가볍게 읽고 넘어가도 좋다.

#### 정수 상수

정수를 표현하는 상수이다. 접두사로 기수법을 지정할 수 있으며, 접미사로 타입을 지정할 수 있다.

* 접두사
    * 없음 : 십진법 상수
    * ```0``` : 팔진법 상수
    * ```0x``` : 십육진법 상수
    * ```0b``` : 이진법 상수 (C23에 추가됨)
* 접미사
    * ```u``` 혹은 ```U``` : ```unsigned``` 타입 상수
    * ```l``` 혹은 ```L``` : ```long``` 타입 상수
    * ```ll``` 혹은 ```LL``` : ```long long``` 타입 상수

예를 들어 다음과 같이 지정할 수 있다.  
```c
100         // int 타입 십진 상수
0b1010      // int 타입 이진 상수
0xFF        // int 타입 십육진 상수
072         // int 타입 팔진 상수
100u        // unsigned int 타입 십진 상수
12345UL     // unsigned long 타입 십진 상수
0xAABBCCull // unsigned long long 타입 십육진 상수
```

여기서 100은 int 타입으로 충분히 표현할 수 있는 상수였다. 하지만 ```INT_MAX``` 값이 2147483647라고 가정할 때, 2147483648은 int 타입으로 표현할 수 없는 수가 된다. 이런 상수는 꼭 ```2147483648L```와 같이 접미사를 지정해줘야 할까? 그렇지는 않다. 컴파일러가 알아서 표현할 수 있는 적합한 타입을 지정해준다.  
정수 상수는 결국 아래 표에 나오는 타입 중 가장 먼저 대응하는 타입을 갖는다. 100을 표에서 해석하면 Suffix가 없고 Decimal Constant이므로 ```int```, ```long int```, ```long long int``` 중 하나인데, 이 중 가장 앞에 있는 ```int``` 타입에 대응하므로 ```int``` 타입을 갖는다. 반면 2147483648은 표에서 같은 셀에 위치하지만 ```int``` 타입에 대응하지 않는다. 그러므로 바로 다음으로 대응하는 ```long int``` 타입으로 표현할 수 있는지 확인하고, 사용하는 컴퓨터 환경에서 가능하다면 ```long int``` 타입을 갖는다. 그렇지 않다면 그 다음 타입인 ```long long int``` 을 갖게 된다. 만약 ```long long int``` 타입으로도 표현할 수 없는 수라면 정수 오버플로우가 일어난다.

> 접미사에서는 대소문자 구분을 하지 않는다. ```u```와 ```U```가 같은 의미이며, ```l```와 ```L```이 같은 의미이다. 같은 원리로 ```uL```과 ```Ul```은 같은 의미이다.

| 접미사 | 십진수 (접두사 없음) | 이진수, 팔진수, 십육진수 |
|:-----:|:-------------------|:----------------------|
| <없음> | ```int``` <br> ```long int``` <br> ```long long int``` | ```int``` <br> ```unsigned int``` <br> ```long int``` <br> ```unsigned long int``` <br> ```long long int``` <br> ```unsigned long long int``` |
| ```u``` | ```unsigned int``` <br> ```unsigned long int``` <br> ```unsigned long long int``` |  ```unsigned int``` <br> ```unsigned long int``` <br> ```unsigned long long int``` |
| ```l``` | ```long int``` <br> ```long long int``` | ```long int``` <br> ```unsigned long int``` <br> ```long long int``` <br> ```unsigned long long int``` |
| ```ul``` |  ```unsigned long int``` <br> ```unsigned long long int``` |  ```unsigned long int``` <br> ```unsigned long long int``` |
| ```ll``` | ```long long int``` | ```long long int``` <br> ```unsigned long long int``` |
| ```ull``` | ```unsigned long long int``` | ```unsigned long long int``` |
| ```wb``` | ```_BitInt(N)``` (N은 값에 적합한 1보다 큰 가장 작은 수) | ```_BitInt(N)``` (N은 값에 적합한 1보다 큰 가장 작은 수) |
| ```uwb``` | ```_BitInt(N)``` (N은 값에 적합한 0보다 큰 가장 작은 수) | ```_BitInt(N)``` (N은 값에 적합한 0보다 큰 가장 작은 수) |

> ```wb```에 관한 내용은 아직 다루지 않으므로 넘어가도 좋다.

표로 보니 복잡해 보이지만 사실 간단하다. 해당 상수를 보고 표현하기 가장 적합한 타입을 알아서 찾아준다는 것이다. 그런데 왜 ```char```나 ```short``` 타입으로 표현할 수 있는 정수도 ```int``` 타입으로 나타내는 것일까? 변수 파트에서 설명한 바와 같이 ```int``` 타입이 컴퓨터 아키텍처가 연산하기 가장 적합한 타입으로 지정하고 있기 때문이다.  
이러한 자동 타입 지정과 후에 설명할 암시적 타입 변환 등이 조합하여 프로그래머는 대부분의 경우 정수 상수의 타입을 직접 지정해주지 않아도 원하는 동작을 수행하는 프로그램을 제작할 수 있다.

#### 실수 상수

실수를 표현하는 상수이다. 유사하게 접두사로 표기법을 지정할 수 있으며 접미사로 타입을 지정할 수 있다.
* 접두사
    * 없음 : 실수 일반 표기법
    * ```e``` : 실수 지수 표기법
    * ```p``` : 이진 지수 표기법
    * ```+``` 혹은 ```-``` : 조합 시 실수의 부호 표기
* 접미사
    * ```f``` 혹은 ```F``` : ```float``` 타입 상수
    * ```l``` 혹은 ```L``` : ```long double``` 타입 상수
    * ```d``` 혹은 ```D``` : 고정 소수점 타입 상수

예를 들어 다음과 같이 지정할 수 있다.
```c
31.5            // double 타입 상수
+31.5           // double 타입 상수 양의 부호
-31.5           // double 타입 상수 음의 부호
2.1f            // float 타입 상수
56.75L          // long double 타입 상수

1.0e2           // 지수 표기법 double 타입 상수 : 100.0
1.0e-2          // 지수 표기법 double 타입 상수 : 0.01
3.14e10         // 지수 표기법 double 타입 상수 : 3.14 * 10^10
```

실수는 정수와 달리 접미사에 따른 타입 지정이 굉장히 단순하다.

| 접미사 | 타입 |
|:-----:|:----------:|
| <없음> | ```double``` |
| ```f``` | ```float``` |
| ```l``` | ```long double``` |
| ```df``` | ```_Decimal32``` |
| ```dd``` | ```_Decimal64``` |
| ```dl``` | ```_Decimal128``` |

기본 타입이 ```float```이 아닌 ```double```이라는 것만 유의하면 된다. 그 외 이진 실수의 지수 표기법과 고정 소수점 타입은 사용하지 못할 수도 있으므로 넘어가도록 한다.

#### 문자 상수

문자를 표현하기 위한 상수이다. 컴퓨터는 본질적으로 문자를 이해할 수 없기 때문에, 문자에 해당하는 코드 값으로 치환된다. 이렇게 사람이 사용하는 문자나 기호를 컴퓨터가 이해할 수 있는 신호(값)로 만드는 것을 인코딩이라고 하며, 인코딩한 이진 신호(값)을 다시 사람이 이해할 수 있는 문자로 변환하는 것을 디코딩이라고 한다. 인코딩과 디코딩을 하기 위해서는 어떤 문자를 어떤 값으로 변환할 지에 대해 미리 기준을 정해야 한다. 이 때 특정한 기준에 맞춰 특정한 문자를 표현하는 값을 코드 포인트(code points)라고 하며, 이러한 기준에 맞춘 문자와 코드 포인트의 집합을 문자셋(character sets) 혹은 코드 페이지(code page)라고 한다.  

초기 컴퓨터는 영미권에서 발전해왔기 때문에, 주로 영미권에서 사용하는 문자(알파벳)와 기호들을 코드화한 아스키코드라는 표준 인코딩을 만들어서 사용했다. 아스키 코드는 총 128개의 문자를 7비트를 사용해서 인코딩하여 1바이트(```char``` 타입)로 표현할 수 있다. 예를 들어 영어 대문자 'A'는 65, 영어 소문자 'a'는 97, 스페이스 문자는 20으로 표현한다. (아스키 코드가 지정한 전체 문자 코드표는 부록을 참고한다.) 하지만 컴퓨터와 인터넷이 전세계로 보급되며 표현해야 할 문자가 증가하였고, 그에 따라 다양한 인코딩 방식이 생겼다. 그 중 대표적으로 유니코드에서 전세계의 모든 문자를 표현하기 위해 만든 유니코드 변환 포맷(UTF)들이 있다. UTF 인코딩 방식에는 한 문자를 나타내는데 필요한 최소 비트 수를 딴 UTF-8, UTF-16, UTF-32 방식 등이 있다.

C언어에서 어떤 인코딩 방식을 사용할지는 기본적으로 구현에 따라 달려있다. (추후에 다시 자세히 알아보겠지만 이를 implementation-defined라고 한다.) 즉, 어떤 아키텍처에서 어떤 OS를 사용하는지에 따라 인코딩 방식이 결정된다는 뜻이다. 그저 ```char``` 타입을 설명할 때 이야기한 basic execution character set만 잘 표현할 수 있으면 되는 것으로 정의하고 있다. 물론, 인코딩 방식을 따로 지정하지 않은 문자는 보편적으로 아스키 코드 방식을 사용하여 나타낸다.

C언어에서 문자셋은 크게 두 가지로 나뉜다. 소스 파일에 작성할 수 있는 모든 문자를 통틀어 소스 문자셋(source character set)이라고 하며, 프로그램 실행을 위한 코드로 번역될 수 있는 문자셋을 실행 문자셋(execution character set)이라고 한다. 이들은 다시 위에서 이야기했던 기본 문자셋(basic character set)과 특정 지역(locale)에서 사용하는 문자를 포함한 확장 문자셋(extended character set)으로 나뉜다. 즉, basic execution character set의 경우 실행을 위한 코드로 번역할 수 있는 기본 문자 셋이다. 

그리고 ```\```(백슬래쉬 혹은 원) 문자를 특별히 이스케이프 문자(escape character)라고 하며, 이스케이프 문자와 조합하여 특수한 기능을 수행하는 문자 시퀀스를 이스케이프 시퀀스(escape sequence)라고 한다. 우리가 여태까지 개행 문자를 표현하기 위하여 사용한 ```\n```가 대표적인 이스케이프 시퀀스이다. 여기에 ```', \, <Enter>``` 세 문자를 제외한 소스 문자셋과 이스케이프 시퀀스를 합쳐 ```c-char```라고 하며, ```c-char``` 여러 개가 나열 되는 것을 ```c-char-sequence```라고 한다. 이제 C언어에서 문자 상수를 표현하는 방법에 대해 더 자세히 알아보도록 하자.

C언어에서 문자 상수를 지정하는 방식은 다음과 같다.  
```c
<인코딩 접두사>'c-char-sequence'
```

즉, ```'```(작은따옴표, single quote)로 ```c-char-sequence```를 묶어서 표현한다. 예를 들어 ```'A', 'a', '*', '-', '\n'```와 같이 문자 상수를 표현할 수 있다. 이 외에도 인코딩 접두사를 지정함에 따라 인코딩 방식과 타입을 다음 표와 같이 지정할 수 있다.

| 접두사 | 인코딩 방식 | 타입 | 표현 문자 |
|:-----:|:----------|:----:|:---------|
| <없음> | implementation-defined (보편적으로 아스키코드) | ```int``` | 멀티바이트 문자 |
| ```u8``` | UTF-8 | ```char8_t``` | UTF-8 문자 |
| ```u``` | UTF-16 | ```char16_t``` | UTF-16 문자 |
| ```U``` | UTF-32 | ```char32_t``` | UTF-32 문자 |
| ```L``` | implementation-defined (하단 설명) | ```wchar_t``` | 와이드 문자 |

처음 보는 타입들 때문에 굉장히 당황스러울 것이다. 우선 각 인코딩 방식에 적합하게 문자 코드를 표현할 수 있는 타입을 지정하고 있다고 생각하고 넘어가자.

여기서 유의할 점이 접두사가 없는 기본 문자 상수의 타입이 ```unsigned char```나 ```char```가 아닌 ```int``` 타입이라는 점이다. 원칙적으로 기본 문자 상수는 멀티 바이트 문자(multi byte character)를 표현하기 위해 사용한다. 멀티 바이트 문자란 1바이트를 포함하여 1바이트 이상의 바이트로 표현할 수 있는 문자를 말한다. 특히 단일 바이트로 표현할 수 있는 문자들은 보편적으로 아스키 코드에 대응하여 표현된다. 따라서, ```'A', 'a'```와 같은 문자들은 대부분의 환경에서 65와 97이라는 값을 갖는다. 그런데 ```'ab', '얍'``` 와 같이 단일 바이트 문자로 표현할 수 없는 멀티 바이트 문자가 오는 경우 어떻게 처리할지는 구현에 따라 다르다. 단지 단일 바이트 문자를 아스키 코드에 호환되도록 하면 되기 때문에, 전체적인 인코딩 방식은 implementation-defined 이다. 

만약 기본 문자 상수가 멀티 바이트 문자가 아닌 단일 바이트 문자만 처리한다고 가정하면 ```char``` 타입이 더 적합하지 않을까? 그렇다고 생각된다면 이는 ```char``` 타입이 1바이트 문자, ```int``` 타입이 4바이트 정수를 처리하기 위한 타입이다 라는 잘못된 개념에서 비롯된 생각이다. 다시 말하지만 ```char``` 타입은 basic execution character set을 저장할 수 있는 최소 크기의 정수 타입이고, ```int``` 타입은 컴퓨터 아키텍처가 연산하기 가장 좋은 정수 타입이다. 예를 들어 '레지스터 AX에 1을 저장하라' 라는 명령어가 있다면 1의 타입이 ```int```여야 가장 효율적인 연산이 되는 것처럼, '레지스터 AX에 'A'를 저장하라' 라는 명령어가 있다면, 'A'가 ```int``` 타입이어야 가장 효율적으로 연산할 수 있다. 따라서 기본 문자 상수는 보편적으로 아스키코드로 나타낼 수 있는 1바이트 문자를 표현하는데 사용하지만 ```int``` 타입을 가지며, 기본 문자 상수를 엄밀히 말해서 __정수 문자 상수(integer character constant)__ 라고 부른다. 참고로 접두사를 지정한 다른 문자 상수는 UTF-8 문자 상수(UTF-8 character constant), UTF-16 문자 상수(UTF-16 character constant)와 같이 불린다.

그렇다면 접두사가 ```L```인 문자 상수는 무엇일까? 이는 현재 설정된 지역의 문자를 모두 표현할 수 있도록 하는 1바이트 이상의 문자를 표현하기 위한 상수이며, 와이드 문자(wide character)라고 한다. 와이드 문자를 표현하기 위한 인코딩 방식은 전적으로 지역 설정에 따라 달라진다. 따라서, 와이드 문자를 사용하는 경우 로케일 설정에 신경을 써야한다.

다음 예제는 여태까지 배운 내용을 기반으로 각 문자 상수들이 현재 실행 환경에서 어떤 코드 값을 갖는지 알아본다. 

```c
// character_constant.c
#include <stdio.h>
#include <uchar.h>      // char16_t와 char32_t를 위하여 사용
#include <stddef.h>     // wchar_t를 위하여 사용
 
int main(void)
{
    // 정수 문자 상수 (single byte)
    int ic1 = 'a'; 
    printf("'a': %x\n", ic1);
    // 정수 문자 상수 (multi byte) - implementation-defined
    int ic2 = 'ab'; 
    printf("'ab': %x\n", ic2);
    int ic3 = '얍';
    printf("'얍': %x\n\n", ic3);
 
    // UTF-16 문자 상수
    char16_t uc1 = u'a'; 
    printf("'a': %x\n", (int)uc1);
    char16_t uc2 = u'β';
    printf("'β': %x\n", (int)uc2);
    char16_t uc3 = u'얍';
    printf("'얍': %x\n\n", (int)uc3);
 
    // UTF-32 문자 상수
    char32_t Uc1 = U'a';
    printf("'a': %x\n", (int)Uc1);
    char32_t Uc2 = U'β';
    printf("'β': %x\n", (int)Uc2);
    char32_t Uc3 = U'얍';
    printf("'얍': %x\n", (int)Uc3);
    char32_t Uc4 = U'🚀';
    printf("'🚀': %x\n\n", (int)Uc4);
 
    // 와이드 문자 상수
    wchar_t wc1 = L'a';
    printf("'a': %x\n", (int)wc1);
    wchar_t wc2 = L'β';
    printf("'β': %x\n", (int)wc2);
    wchar_t wc3 = L'얍';
    printf("'얍': %x\n", (int)wc3);
    wchar_t wc4 = L'🚀';
    printf("'🚀': %x\n", (int)wc4);

    return 0;
}
```

위 예제에서는 각 문자 상수들을 십육진수로 출력하고 있다. 현재 환경에서 예제를 실행하면 다음과 같다. (해당 결과는 환경에 따라 달라질 수 있다.)

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./character_constant 
'a': 61
'ab': 6162
'얍': ec968d

'a': 61
'β': 3b2
'얍': c58d

'a': 61
'β': 3b2
'얍': c58d
'🚀': 1f680

'a': 61
'β': 3b2
'얍': c58d
'🚀': 1f680
```

마지막으로 사용할 수 있는 이스케이프 시퀀스의 종류에 대해 알아보자. 굳이 외우지 않아도 되므로, 예제와 함께 가볍게 살펴보도록 하자.

| 이스케이프 시퀀스 | 설명 |
|:-----:|:----------|
| \' | 작은 따옴표(single quote) |
| \" | 큰 따옴표(double quote) |
| \? | 물음표 |
| \\ | 백슬래쉬 |
| \a | 오디오 벨(알람 소리) |
| \b | 백스페이스 |
| \f | 폼 피드(새 페이지) |
| \n | 라인 피드(개행) |
| \r | 캐리지 리턴 |
| \t | 수평 탭 |
| \v | 수직 탭 |
| \u | UTF-16 코드 지정 |
| \U | UTF-32 코드 지정 |

이 외에도 기수 표현 이스케이프 시퀀스도 있지만 잘 사용하지는 않는다. 다음 예제를 통해 이스케이프 시퀀스 동작을 좀 더 자세히 살펴보자.

```c
// escape_sequence.c
#include <stdio.h>

int main(void)
{
    printf("Ring My Bell \a \n");     // \a는 환경 설정에 따라 비프음이 들리지 않을 수 있음
    printf("\'Hello World\'\n");
    printf("\"Hello World\"\n");
    printf("Hello World\?\n");
    printf("Back\b\bSlash\n");
    printf("\f");
    printf("Hello World1\r\n");
    printf("Hello World2\v");
    printf("Hello\tWorld3\n");
    printf("Hello World4\b\b\n");
    printf("OK\rHello World5\n");
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./escape_sequence 
Ring My Bell  
'Hello World'
"Hello World"
Hello World?
BaSlash

Hello World1
Hello World2
            Hello       World3
Hello World4
Hello World5
```

사용하는 환경에 따라서 동작하는 방식이 달라질 수 있으므로, 실행 결과는 가볍게 살펴보기 바란다.  
마지막 두 개의 출력은 이해가 잘 되지 않을 수도 있다. 현재 사용하고 있는 터미널에서 ```\b```(백슬래쉬)는 문자를 바로 지우는 것이 아니라 커서를 이 전으로 한 칸씩 옮기는 것이고, ```\r```(캐리지 리턴)은 커서를 해당 라인의 맨 처음으로 옮기는 것으로 생각하면 된다.  
이스케이프 시퀀스를 개발할 당시 프린터와 같은 출력 기기들이 문자를 출력할 때 포인터의 위치 지정을 위해서 위와 같이 동작하도록 정의하였다. 근대 출력 기기가 등장하는 영화를 보면 개행 시 잉크 포인터가 맨 앞으로 이동한 후 종이가 다음 칸으로 이동하는 것을 볼 수 있다. 이러한 시절에 개행을 정확하게 표현하기 위해서는 ```\r\n```와 같이 이스케이프 시퀀스를 사용해야 했다.  
현대에는 상황에 맞게 적절히 구분하여 사용하면 되는데, 이는 관련된 과목들에서 좀 더 상세하게 배울 수 있다. (예를 들어 대부분 환경에서 터미널 개행 출력은 ```\n```을 사용하고, HTTP 통신 시 개행 문자는 ```\r\n```을 사용하며, HTTP 헤더와 바디를 구분하기 위한 구분자로 ```\r\n\r\n```을 사용한다. 이러한 것들은 관련된 세부 과목에서 자세히 배우게 될 것이다.)

#### 미리 정의된 상수

C언어에서 특수 목적으로 미리 정의된 상수이다. C++에 있던 문법인데, C23에서 새로 편입되었다. 다음과 같이 세 가지가 있다.

* ```false``` : 거짓을 나타내는 상수로, 0의 값을 가진다.
* ```true``` : 참을 나타내는 상수로, 1의 값을 가진다.
* ```nullptr``` : 널 포인터를 나타내는 상수이다.

위 상수들의 자세한 용도는 선택문 챕터와 포인터 챕터에서 자세히 알아볼 것이다.

### 문자열 리터럴(String Literal)

문자열 리터럴이란 문자의 연속된 나열(sequence)을 나타내는 요소다. 큰 따옴표로 문자 시퀀스를 묶어서 표현한다. 여태까지 ```printf``` 문에서 사용했던 ```"Hello, World!\n"``` 와 같은 것들이 모두 문자열 리터럴이다. 문자열 리터럴은 문자 상수를 잘 공부했다면 문자 코드가 연속적으로 나열되는 것으로 쉽게 이해할 수 있다. 문자열 리터럴도 문자 상수와 같이 인코딩 지정 방식에 따라 다음과 같이 분류할 수 있다.  

| 접두사 | 리터럴 종류 | 표현 문자 시퀀스 |
|:-----:|:----------|:-----------|
| <없음> | 캐릭터 문자열 리터럴<br>(character string literal) | 멀티바이트 문자 시퀀스 |
| ```u8``` | UTF-8 문자열 리터럴 | UTF-8 문자 시퀀스 |
| ```u``` | UTF-16 문자열 리터럴 | UTF-16 문자 시퀀스 |
| ```U``` | UTF-32 문자열 리터럴 | UTF-32 문자 시퀀스 |
| ```L``` | wchar_t 문자열 리터럴 | 와이드 문자 시퀀스 |

UTF-16 문자열 리터럴, UTF-32 문자열 리터럴, wchar_t 문자열 리터럴을 합쳐서 와이드 문자열 리터럴(wide string literals)이라고도 한다.

### Const

### Constexpr