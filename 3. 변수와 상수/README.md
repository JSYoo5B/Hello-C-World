# 변수와 상수

이번 챕터에서는 C언어에서 사용하는 변수와 상수에 대해 공부하고, 이들이 가질 수 있는 타입에 대해 알아 볼 것입니다.  
그런데 변수와 상수에 대해 자세히 이해하려면 컴퓨터가 어떻게 숫자를 표현하고 데이터를 저장하는지를 알아야 합니다.  
따라서 이번 챕터의 앞 부분에서는 이러한 선행 내용을 먼저 다루도록 하겠습니다.  

## 데이터와 이진수

데이터라는 용어는 처음에 저장하거나 전달할 수 있는 컴퓨터 정보(information)라는 의미로 사용되었습니다.  
시간이 지나고 용어의 의미가 가공되면서 사람들은 문자나 숫자와 같은 것들을 컴퓨터가 처리할 수 있는 형태로 만든 자료를 데이터라고 부르게 되었습니다. 그리고 이 데이터를 가공하여 정보(information)를 얻는다고 이야기를 하고는 합니다.  
여기에 더해 데이터에 대한 학술적인 의미를 살펴보면 '정보를 전달하거나 수량이나 통계 등을 묘사하기 위한 이산(discrete) 값들을 컴퓨터로 처리하거나 해석하기 위하여 순서를 가지고 나열된 기호(Symbol)의 모음'이라고 합니다.  
이러한 사전적 의미들은 항상 너무 딱딱하고 어렵습니다. 우선은 우리가 사용하는 컴퓨터나 스마트폰에 저장되어 있는 텍스트 파일, 사진 파일, 동영상 파일같은 것들을 데이터라고 한다고 추상적으로 생각해봅시다.  
그리고 컴퓨터는 이 데이터를 항상 이진법으로 저장하고 해석합니다.  

이진법은 0과 1 두 개의 숫자만을 사용하는 수 체계입니다.  
우리는 평소에 0부터 9까지 총 열 개의 숫자를 사용하는 십진법을 사용하고 있습니다.  
십진법으로 0부터 차례대로 정수를 써내려가면 0, 1, 2, 3, 4, ..., 9, 10, 11, 12, ..., 19, 20, ..., 99, 100, 101, ... 와 같이 쓸 수 있습니다.  
그러면 이진법으로 0부터 차례대로 숫자를 써내려가면 어떻게 될까요?  
0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, ... 와 같이 쓸 수 있습니다.  
십진수와 이진수의 나열을 일부 비교하면 다음과 같습니다.  

| 십진수 | 이진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |
| 9 | 1001 |
| 10 | 1010 |

이진수를 좀 더 와닿게 하도록 평소에 사용하는 십진수의 자릿값을 생각해보겠습니다.  
563 이라는 숫자는 일의 자리가 3, 십의 자리가 6, 백의 자리가 5인 수입니다.  
1234 라는 숫자는 일의 자리가 4, 십의 자리가 3, 백의 자리가 2, 천의 자리가 1인 수입니다.  
이렇게 자릿값을 계산할 때 각 자리는 10을 영(0)번 곱한 일($10^0$)의 자리, 10을 한(1)번 곱한 십($10^1$)의 자리, 10을 두(2)번 곱한 백($10^2$)의 자리, 10을 세(3)번 곱한 천($10^3$)의 자리, ... 와 같이 증가합니다.  
이진수도 이와 다를바가 없습니다. 여기서 10 대신에 2를 사용하여 자릿값을 구하면 됩니다.  
즉, 2를 영(0)번 곱한 일($2^0$)의 자리, 2를 한번 곱한 이($2^1$)의 자리, 2를 두번 곱한 사($2^2$)의 자리, 2를 세번 곱한 팔($2^3$)의 자리, 2를 네번 곱한 십육($2^4$)의 자리, .. 와 같이 증가합니다.  

그리고 각 숫자가 어떤 진법을 사용하고 있는지는 숫자의 다음과 같이 우측 아래에 진법을 통해 표기하고는 합니다.  
$563_{10}$  $1010_{2}$  
좌측은 10진법으로 563을 뜻하고 우측은 2진법으로 1010을 뜻합니다.  
$1010_{2}$ 와 같은 표기를 프로그래밍 언어에서는 보통 숫자 앞에 접두사로 ```0b```를 붙여 ```0b1010```과 같이 표현하기도 합니다. (여기서 b는 이진법의 영어인 Binary에서 따온 글자입니다.)  
앞으로 해당 서적에서도 어떤 숫자 앞에 ```0b```가 붙는다면 이진수를 뜻한다고 생각해주시면 됩니다.  

이제 이진수를 십진수로 변환하는 방법에 대해서 살펴보겠습니다.  
우선 십진수 563의 각각의 자릿수를 펼쳐서 써보면 다음과 같습니다.  
$5 * 10^2 + 6 * 10^1 + 3 * 10^0  = 500 + 60 + 3 = 563$  
이와 마찬가지로 ```0b1010```이라는 이진수의 각각의 자릿수를 펼쳐서 써보면 다음과 같습니다.  
$1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0$  
이를 계산하면 다음과 같습니다.  
$1 * 8 + 0 * 4 + 1 * 2 + 0 * 1 = 8 + 2 = 10$  

해보니 어렵지 않습니다. ```0b10101```이라는 수로 한번만 더 연습해보겠습니다.  
$1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1 * 16 + 0 * 8 + 1 * 4 + 0 * 2 + 1 * 1 = 16 + 4 + 1 = 21$  

이렇게 자꾸 연습하다 보면 이진수를 대충 보고도 바로바로 십진수로 변환할 수 있게 됩니다.  

그렇다면 십진수를 이진수로 변환하는건 어떻게 하면 될까요?  
십진수를 몫이 0이 될 때까지 2로 계속 나누어서 그 나머지를 거꾸로 모아주면 됩니다.  
위의 10과 21을 예로 들어서 변환해보겠습니다.  

$10 / 2 = 5 ... 0$  
$5 / 2 = 2 ... 1$  
$2 / 2 = 1 ... 0$  
$1 / 2 = 0 ... 1$  
10을 2로 나눈 몫은 5이고, 나머지는 0입니다.  
그 몫을 다시 2로 나눈 몫은 2이며, 나머지는 1입니다.  
이런식으로 몫이 0이 될 때까지 계속 나누고, 그로 인해 생긴 나머지들을 거꾸로 읽어주시면 이진수가 됩니다.  
위의 나눔 연산의 나머지들을 거꾸로 모아보면 10을 이진수로 표현한 ```0b1010```이 되는걸 볼 수 있습니다.  

21에 대해서도 한번만 더 연습해보도록 하겠습니다.  
$21 / 2 = 10 ... 1$  
$10 / 2 = 5 ... 0$  
$5 / 2 = 2 ... 1$  
$2 / 2 = 1 ... 0$  
$1 / 2 = 0 ... 1$  
마찬가지로 나머지들만 거꾸로 모아보면 ```0b10101```이 되는 것을 볼 수 있습니다.  

이제 숫자를 어떻게 이진법으로 표현하는지는 충분히 이해가 되었을 겁니다.  
일반적으로 컴퓨터는 MOSFET이라는 트랜지스터들이 모여서 회로를 구성하며, 트랜지스터에 전기가 흐르면 1, 흐르지 않으면 0과 같이 표현하여 이진 데이터를 해석하거나 저장할 수 있습니다. (이에 대해 더 자세한 내용은 디지털 논리라는 과목을 공부하면 알 수 있습니다.)  
컴퓨터는 수십, 수백억개의 트랜지스터가 들어가기 때문에 이진수를 굉장히 잘 사용할 수 있습니다.  
그리고 프로그래머는 컴퓨터와 대화를 하기 위해 이진수를 열심히 사용하려고 합니다.  
하지만 프로그래머도 사람입니다. 이진수의 숫자가 커지면 점점 보기가 힘들어집니다.  
숫자 1000만 하더라도 이진수로 하면 ```0b1111101000```이 됩니다.  
프로그래밍을 하다보면 수억을 넘어가는 굉장히 큰 수를 다루게 되는데 이를 이진수로 표현하기엔 너무 숫자의 배열이 길어집니다.  
그래서 프로그래머들은 이진수와 호환이 좋으면서도 큰 수를 짧게 표현할 수 있는 십육진법을 많이 사용합니다.  
십육진법에서는 9 이후로 로마 문자를 사용하여 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 16개의 숫자를 사용합니다.  
십진수와 십육진수를 대강 비교하면 다음과 같습니다.  

| 십진수 | 십육진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| ... | ... |
| 9 | 9 |
| 10 | A |
| 11 | B |
| 12 | C |
| 13 | D |
| 14 | E |
| 15 | F |
| 16 | 10 |
| 17 | 11 |
| ... | ... |
| 25 | 19 |
| 26 | 1A |
| 27 | 1B |
| ... | ... |
| 31 | 1F |
| 32 | 20 |

십진수와 십육진수를 서로 변환하는건 이진수와 십진수를 서로 변환하는 것과 근본적인 원리에 큰 차이는 없습니다.  
하지만 십육진수는 주로 이진수와의 호환을 위해 사용하고는 합니다.  
따라서 십진수와 십육진수를 변환하는 것보다는 이진수와 십육진수를 변환하는 것을 살펴보는 것이 좋습니다.  
그 전에 참고로, 이진수를 프로그래밍 언어에서 표현할 때 숫자 앞에 ```0b```를 붙인 것처럼, 십육진수를 프로그래밍 언어에서 표현할 때 숫자 앞에 ```0x```를 붙입니다.  
예를 들어, 십육진수 $3F_{16}$ 를 ```0x3F```와 같이 표현하고는 합니다.  
마찬가지로 해당 서적에서 어떤 숫자 앞에 ```0x```를 붙인다면 십육진수를 표현한다고 생각해주시면 됩니다.  
돌아와서 이진수와 십육진수를 대강 비교하면 다음과 같습니다.  

| 이진수 | 십육진수 |
|:-----:|:-----:|
| 0 | 0 |
| 1 | 1 |
| 10 | 2 |
| ... | ... |
| 1110 | E |
| 1111 | F |
| 10000 | 10 |
| 10001 | 11 |
| 10010 | 12 |
| ... | ... |
| 11110 | 1E |
| 11111 | 1F |
| 100000 | 20 |
| ... | ... |
| 11111111 | FF |
| 100000000 | 100 |

눈치가 빠른 분은 어느정도 규칙을 발견할 수도 있었을 겁니다.  
$16 = 2^4$ 이기 때문에 이진수 네 자리와 십육진수 한 자리가 대응되는걸 볼 수 있습니다.  
예를 들어 십육진수 ```0x4B27``` 의 각 자리는 이진수의 네 자리에 대응되어 열여섯 자리의 이진수가 됩니다.  
```0x4 = 0b0100```  
```0xB = 0b1011```  
```0x2 = 0b0010```  
```0x7 = 0b0111```  
이므로 각 자리들을 모으면  
```0x4B27 = 0b0100101100100111``` 이 됩니다.  
이처럼 이진수와 십육진수는 서로 굉장히 잘 호환되는 것을 볼 수 있습니다.  

## 변수

C언어에서 변수(variable)는 값을 저장하는 임시 저장소입니다.  
컴퓨터는 연산을 하기 위해 다양한 데이터들을 주기억장치(Main Memory)에 저장하고 불러와서 사용합니다.  
예를 들어 즐겨하는 게임에서 내 캐릭터의 HP같은 것이 있다고 가정하면, 공격을 맞았을 때 HP는 감소하고 아이템을 사용하거나 회복하면 HP가 증가하게 됩니다. 컴퓨터는 이런 HP와 같은 값들을 주기억장치에 저장해두고, 해당 값을 더하거나 빼거나 하는 등의 연산을 수행합니다.  
그러면 우리가 플레이하는 게임 프로그램은 주기억장치의 어느 위치에 HP에 해당하는 값이 저장되어 있는지를 찾아야 합니다. 이 때 사용하는 것이 바로 변수입니다. HP라는 변수를 만들면 이 변수가 주기억장치의 어딘가에 위치하게 되고(위치를 결정하는건 운영체제가 결정합니다.) 프로그램에서 이 HP라는 변수를 사용하게 되면 알아서 HP가 저장되어있는 위치를 찾아갑니다. 그리고 해당 값을 읽는다던지, 새로운 값을 써넣는다던지, 기존 값에서 특정 값을 더하고 빼는 작업을 수행할 수 있게 됩니다.  

컴퓨터에서 보통 주기억장치라고 하면 RAM(Random Access Memory)을 의미합니다. 주기억장치(Main Memory) 혹은 1차 기억장치(Primary Memory)는 CPU가 직접 접근하는 메모리로 RAM, ROM 등이 존재합니다. 지금부터는 그 중 자주 사용하는 RAM에 집중하여 이야기해보겠습니다.  

컴퓨터나 스마트폰을 구매할 때 RAM이 4GB니 16GB이니 하는 이야기를 많이 들어보셨을 겁니다. 이게 RAM의 크기를 나타낸다는 것은 이제 많은 사람들에게 익숙한 이야기입니다. 그렇다면 이 크기가 얼마나 큰 것일까요?  
위에서 트랜지스터 하나가 전기가 흐르면 1, 흐르지 않으면 0을 표현할 수 있다고 했습니다. 이 트랜지스터 하나가 표현할 수 있는 이진수 한 자리가 1 비트(bit) 입니다. 그리고 8개의 비트가 모여서 1 바이트(byte)가 됩니다. (사실 1 바이트가 몇 비트인지는 컴퓨터 아키텍처와 구현에 따라 달라질 수도 있지만 보편적으로 8 비트를 사용합니다.)  
한 자리의 이진수로 표현할 수 있는 수는 0과 1 두 개 ($2^1$) 입니다.  
두 자리의 이진수로 표현할 수 있는 수는 00, 01, 10, 11 네 개 ($2^2$) 입니다.
이런 식으로 N 자리의 이진수로 표현할 수 있는 수는 $2^N$ 개 입니다.  
그러면 여덟 자리의 이진수로 표현할 수 있는 수, 다시 말해 1바이트(8비트)로 표현할 수 있는 수는 $2^8 = 256$ 개이며 0부터 255까지 표현할 수 있습니다.  
이에 더해 4바이트(32비트)로 표현할 수 있는 수는 $2^{32} = 4294967296$ 개이며 0부터 4294967295(0xFFFFFFFF)까지 표현할 수 있습니다.  

그리고 바이트는 약 천 단위로 새로운 저장 단위를 갖습니다.  
1024($2^{10}$) 바이트는 1 킬로바이트이며, 다시 1024 킬로바이트는 1 메가바이트이고, 1024 메가바이트는 1 기가바이트가 됩니다.  
즉, 1 기가바이트는 $2^{10} * 2^{10} * 2^{10} = 2^{30}$ 바이트가 되는 것이고, 4 기가바이트는 여기에 4를 곱하여 $2^{30} * 4 = 2^{30} * 2^2 = 2^{32}$ 바이트가 되는 것입니다.  
RAM의 크기가 4 기가바이트다 라고 한다면, $2^{32}$ 바이트의 데이터를 RAM에 동시에 저장할 수 있다는 의미가 되는것이죠.  
이 4 기가바이트 RAM의 각 바이트 저장 공간에는 주소라는 것이 있습니다. 저희가 사는 집주소를 프로시 그램구 씨동 1024번지와 같이 표현하는 것처럼 말이죠.  
4 기가바이트 RAM에서 주소는 0번지부터 $2^{32} - 1$ 번지까지 존재합니다. 시작 주소가 1번지가 아닌 0번지인 것에 유의합시다. 따라서 끝 주소는 $2^{32}$ 번지가 아닌 $2^{32} - 1$ 번지가 됩니다. 그리고 앞으로 RAM의 주소를 이야기할 때는 항상 십육진법으로 표기를 하겠습니다.  
그리하여 보통 RAM을 그림으로 나타낼 때 다음과 같이 그리고는 합니다.  
![ram](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%EB%B3%80%EC%88%98%EC%99%80%20%EC%83%81%EC%88%98/memory.png?raw=true)  
위 그림에서 네모 한 칸에 1바이트(8비트)를 저장할 수 있습니다.  
자, 그러면 0x0 번지에 HP라는 변수가 저장된다고 가정하고 HP를 1만(10,000)으로 설정해봅시다. 어라? 1만은 2진수로 ```0b10011100010000``` 인데 (십육진수로 0x2710), 한 바이트로 해당 수를 다 표현할 수가 없습니다! 애초에, 1바이트로 표현할 수 있는 수는 0부터 255까지밖에 없다고 했습니다. 그러면 이보다 큰 수는 어떻게 해야 할까요?  
정답은 0x0번지부터 0x1번지까지 이어서 값을 저장하고 0x0번지와 0x1번지를 합쳐서 HP라고 지정하면 됩니다. 이렇게 2바이트를 사용하면 위에서 했던 계산에 의해 최대 65535(0xFFFF)까지 표현할 수 있습니다.  
그러면 65535보다 큰 수는 또 어떻게 해야 할까요? 3바이트를 사용하면 되는 걸까요? 그래도 되지만, 현대 컴퓨터에서는 효율과 편의를 위하여 2의 거듭제곱 수만큼 증가해 사용합니다. 즉, 그보다 큰 수는 4바이트를 사용해 표현합니다. 그리고 4바이트로 표현할 수 없는 수는 8바이트로 표현하고는 하죠.  
그러면 8바이트로도 표현할 수 없는 수는 16바이트로 표현할까요? 보통 그렇지는 않습니다. 현재는 효율의 문제로 8바이트로 표현할 수 있는 크기의 숫자까지만 취급하고 있습니다. (물론 이는 얼마든지 변경될 수 있는 내용입니다. 그렇다 해도 언제나 한 번에 처리할 수 있는 크기의 한계는 존재할 것입니다.) 하지만 8바이트만으로도 최대 18,446,744,073,709,551,615 라는 엄청난 크기의 숫자까지 표현할 수 있으므로 큰 걱정을 하지는 않으셔도 됩니다.  

> 그러면 현재 사용 중인 컴퓨터는 정말로 18,446,744,073,709,551,615 보다 큰 정수를 저장하지 못하는 걸까요?
> 꼭 그런 것만은 아닙니다. 해당 숫자보다 큰 수를 어떻게 저장할 수 있을지에 대한 것은 책의 중반정도까지 공부하고 나면 알 수 있을 겁니다.  

서론이 정말 길었습니다. 이제 위에서 이야기한 HP라는 변수를 C언어에서 어떻게 사용하는지 알아보도록 하겠습니다.  

### 변수 선언

C언어에서 변수를 사용하기 위해서는 변수를 선언(declaration)해야 합니다.  
다음 예제를 따라서 변수를 사용해봅시다.  
```c
// variable.c
#include <stdio.h>

int main(void)
{
    /* 변수를 선언함
     * int는 변수가 정수형이라는 것을 지정함
     * hp는 변수의 이름을 식별함
     * =는 변수에 초기값을 설정하겠다는 것을 알림
     * 100은 변수의 초기값을 나타냄
     */
    int hp = 100;
    printf("%d \n", hp);
    return 0;
}
```  
실행하면 다음과 같은 결과를 볼 수 있습니다.  
```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make variable
cc     variable.c   -o variable
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./variable 
100 
```  

너무나도 장대했던 서론에 비하여 굉장히 간단한 사용이었습니다.  
C언어에서 선언의 형태는 다음과 같습니다.  
```c
<선언 지정자> <초기화 선언자 리스트>
```  
선언 지정자(declaration-specifier)에는 타입 지정자(type-specifier)같은 것들이 올 수 있습니다. (다시 말해 타입 지정자가 아닌 내용도 추가될 수 있다는 것인데, 이는 이 후 챕터들에서 천천히 다루겠습니다.) 위에서 사용한 ```int``` 같은 것들이지요. 타입 지정자는 변수가 메모리에 어떻게 저장될지를 지정합니다. 즉, 1바이트 공간을 사용하여 저장할지, 4바이트 공간을 사용하여 저장할지, 정수의 형태로 저장할지, 실수의 형태로 저장할지 등을 정하는 것인데 타입에 대한 내용은 바로 후에 조금 더 자세히 이야기하겠습니다.  
초기화 선언자 리스트(init-declarator-list)에는 선언자(declarator)와 이니셜라이저(initializer)가 올 수 있습니다. 선언자는 변수의 이름을 나타내기 위한 식별자(identifier)와 같은 요소고, 이니셜라이저란 변수에 초기 값을 지정해주기 위한 요소입니다. 그리고 이니셜라이저 앞에는 항상 ```=``` 라는 구두점을 사용하여 선언자와 구분해야 하며, 이니셜라이저는 등장하지 않을 수도 있습니다. 이론은 다소 복잡한데, 지금 당장 쉽게 이야기하면 변수 이름과 변수에 처음 할당해줄 값을 쓸 수 있다는 겁니다. 그리고 초기화 선언자 리스트는 ```,```(쉼표) 구두점을 통해 여러 개가 나올 수 있습니다. 즉, 한 번에 여러 변수를 선언할 수 있습니다.  
말로 설명하니 굉장히 어렵게 느껴집니다. 위 내용을 예시를 통해 쉽게 살펴보도록 하겠습니다.  

```c
// variable_declaration.c
#include <stdio.h>

int main(void)
{
    // int는 변수의 타입을 지정하는 선언 지정자
    int a;          // 이니셜라이저 없이 변수 이름 a를 식별하기 위한 선언자만 사용
    int b = 10;     // 변수 이름을 식별하기 위한 b라는 선언자, = 라는 구두점, 10이라는 이니셜라이저
    int c = 1, d = 2, e = 3;    // 쉼표를 통해 초기화 선언자 리스트를 여러 개 나열
    int f, g = 4, h, i = 100;   // 쉼표를 통해 초기화 선언자 리스트 여러 개 나열, 이니셜라이저는 포함할 수도 포함하지 않을 수도 있음
    // 변수 선언 이 후 별도의 작업 없이 프로그램 종료
    return 0;
}
```

보시면 아시겠지만 코드는 간단한데 오히려 주석이 더 복잡합니다. 예제 코드만 보면 대충 감으로 이해할 수 있겠는데, 부가 설명이 혼란을 가중시킵니다. 지금은 우선 변수를 사용하기 위해서는 이름을 지어줘야 하며, 해당 변수가 처음 가질 수 있는 값을 지정해 줄 수도 있고, 쉼표를 통해 한 번에 여러 개의 변수를 선언할 수도 있다고 이해하시면 됩니다. 다른 부연 설명들은 책의 후반부에 나오는 내용들을 보고 나면 좀 더 쉽게 이해할 수 있습니다.  

### 타입 지정자

위에서 사용한 ```int```와 같은 것들을 타입 지정자라고 합니다. 이 외에도 C11를 기준으로 타입 지정자는 다음과 같은 것들이 있습니다.  
* void
* __char__
* __short__
* __int__
* __long__
* __float__
* __double__
* __signed__
* __unsigned__
* _BitInt
* bool
* _Bool
* _Complex
* _Decimal32
* _Decimal64
* _Decimal128
* _atomic-type-specifier_
* _struct-or-union-specifier_
* _enum-specifier_
* _typedef-name_
* _typeof-specifier_

이 중에서 볼드체로 작성하지 않은 일곱 개의 타입 지정자는 책의 후반부에서 마저 공부할 것입니다. 우선은 볼드체로 작성한 여덟 개의 타입 지정자에 대해 알아보도록 하겠습니다.  

위 타입 지정자 중 정수형 데이터를 저장하기 위한 타입은 char, short, int, long, signed, unsigned가 있고 실수형 데이터를 저장하기 위한 타입은 float, double이 있습니다.  
왜 정수형 데이터를 나타내는 데에만 네 가지 타입이나 존재하고 실수형 데이터를 나타내는 데에 두 가지 타입이 존재하는 걸까요?  
그것은 각 타입마다 크기가 다르기 때문입니다. 그렇기 때문에 표현할 수 있는 수의 범위도 달라지고 용도도 조금씩 달라지게 됩니다.  
추가로 사실 타입 지정자는 위에 있는 것들 중 하나만 사용할 수 있는 것이 아니라 여러 개를 조합해서 사용할 수도 있습니다. 이러한 점들을 고려하며 예제를 하나 작성해본 후, 각 타입 지정자들을 좀 더 상세히 알아보도록 하겠습니다.  

```c
// type_specifier.c
#include <stdio.h>

int main(void)
{
    int positive = 3;       // 양수 저장
    int negative = -2;      // 음수 저장
    double average = 0.5;   // 실수 저장
    char last = 'z';        // 문자 코드 저장
    unsigned long long int big_num = 18446744073709551615ULL;       // 큰 수 저장
    // 숫자 뒤에 붙은 ULL은 상수 챕터에서 알아볼 정수 접미사

    // int 타입 기본 정수 출력 서식 문자는 %d
    printf("%d is positive number\n", positive);
    printf("%d is negative number\n", negative);
    // double 타입 기본 실수 출력 서식 문자는 %f
    printf("Average is %f\n", average);
    // char 타입의 문자 출력 서식 문자는 %c
    printf("Last alphabet is %c\n", last);
    // unsigned long long int 타입 정수 출력 서식 문자는 %llu
    printf("Big size number %llu\n", big_num);
    return 0;
}
```

위 예제를 실행하면 다음과 같은 결과를 볼 수 있습니다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make type_specifier
cc     type_specifier.c   -o type_specifier
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./type_specifier 
3 is positive number
-2 is negative number
Average is 0.500000
Last alphabet is z
Big size number 18446744073709551615
```

예제 내용을 이해할 수 있도록 세부 내용을 천천히 학습해보도록 하겠습니다.

#### 정수 타입 지정자

우선 ```signed```는 부호가 있는 정수(음수를 표현할 수 있음)를 표현하는데 사용하고, ```unsigned```는 부호가 없는 정수(음수를 표현할 수 없음)를 표현하는데 사용한다는 것을 염두합시다. 조합 가능한 정수 타입들에 대한 설명은 다음과 같습니다.  

* ```char``` : __basic execution character set을 저장할 수 있도록 크기가 보장__ 됩니다. 보통 아스키코드 문자 인코딩을 사용하는 정수값을 통해 문자를 표현할 때 사용합니다. ```signed```나 ```unsigned```와 조합하여 사용하지 않으면 __부호가 있는 타입인지 부호가 없는 타입인지 보장할 수 없습니다.__ (둘 중 어떤 타입이 되더라도 basic execution character set은 저장할 수 있습니다.)
    * basic execution character set : 알파벳 대문자, 알파벳 소문자, 10개의 숫자 문자에 더해 다음 29개의 특수 문자의 집합; ```! " # % & ' ( ) * + , - . / : ; < = > ? [ \ ] ^ _ { | } ~```
    * basic execution character set이 아닌 문자를 char에 저장하는 것은 implementation-defined 입니다. 하지만 보통 char 타입이 가질 수 있는 범위 내의 문자 인코딩은 표현 가능합니다.
    * 사실 1 바이트의 엄밀한 의미는 이 basic character set을 저장할 수 있는 크기의 저장 유닛입니다. 따라서, char 타입의 크기는 1 바이트임이 보장됩니다.
* ```signed char``` : ```char```와 동일한 크기를 가지고, ```signed```임을 보장합니다.
* ```unsigned char``` : ```char```와 동일한 크기를 가지고, ```unsigned```임을 보장합니다.
* ```short```, ```signed short```, ```short int```, ```signed short int``` : 부호 있는 정수를 표현하는데 사용하며 ```int```보다 작거나 같은 크기임을 보장합니다.
* ```unsigned short```, ```unsigned short int``` : 부호 없는 정수를 표현하는데 사용하며 ```unsigned int```보다 작거나 같은 크기임을 보장합니다.
* ```int```, ```signed```, ```signed int``` : 부호 있는 정수를 표현하는데 사용합니다. ```int``` 타입은 특히 __컴퓨터 아키텍처가 연산을 수행하기 가장 좋은 타입__ 입니다.
* ```unsigned```, ```unsigned int``` : 부호 없는 정수를 표현하는데 사용하며 ```int``` 타입과 같은 크기를 갖습니다.
* ```long```, ```signed long```, ```long int```, ```signed long int``` : 부호 있는 정수를 표현하는데 사용하며 ```int```보다 크거나 같고, ```long long int```보다 작거나 같은 크기를 보장합니다.
* ```unsigned long```, ```unsigned long int``` : 부호 없는 정수를 표현하는데 사용하며, ```long int```와 같은 크기를 갖습니다.
* ```long long```, ```signed long long```, ```long long int```, ```signed long long int``` : 부호 있는 정수를 표현하는데 사용하며, ```long```보다 크거나 같은 크기를 보장합니다. 보통 최소 64비트의 크기를 보장해줍니다. (그렇지 않을 수도 있습니다.)
* ```unsigned long long```, ```unsigned long long int``` : 부호 없는 정수를 표현하는데 사용하며, ```long long int```와 같은 크기를 갖습니다.

설명이 조금 복잡해 보입니다. 우선은 문자 표현을 위해서 ```char```, 일반적인 부호 있는 정수 표현에는 ```int```, 일반적인 부호 없는 정수 표현에는 ```unsigned int```, 부호 있는 큰 정수에는 ```long long```, 부호 없는 큰 정수에는 ```unsigned long long``` 을 사용한다고 생각해주셔도 좋습니다. 그 외의 타입이 필요한 상황이 오면 이미 C언어를 어느정도 익숙하게 구사할 것이므로, 당장은 해당 다섯 개의 타입을 주로 익혀주시면 됩니다.  

> 간혹가다 char는 1바이트, short는 2바이트, int는 4바이트, long long은 8바이트와 같이 타입의 크기를 설명하는 자료들이 있습니다. 하지만 표준에서는 char가 basic execution character set을 충분히 저장할 수 있는 크기이다 (다시 말해 1바이트) 외에 크기에 대한 명시를 하고 있지 않습니다. 더군다나 과거에는 int 타입이 주로 2바이트였고, 추후에는 int가 8바이트인 시스템을 사용할 수도 있습니다. 해당 타입들의 크기를 고정해서 설명하는 자료들은 모두 틀린 자료들이니 참고하시기 바랍니다.

> 만약 크기가 고정된 타입을 사용하고 싶다면 추후에 설명할 정확히 고정된 크기의 정수 타입(Exact-width integer type)을 사용해야 합니다.

#### 음의 정수

그런데 부호 있는 정수와 부호 없는 정수는 무엇이 다를까요? 그리고 컴퓨터는 어떻게 음수를 표현할까요? 독자분들께서 컴퓨터를 설계한다고 했을 때 어떻게 음수를 표현할지 한번 생각해보시기 바랍니다.  

필자는 이 질문을 받았을 때 다른 내용은 그대로 두고, 정수를 표현하는 비트 중 하나를 음수와 양수를 구분하는 데 사용하면 되지 않을까 생각했습니다. 예를 들어 부호 있는 1바이트 변수에 3이라는 값이 ```0b00000011```이라고 표현된다면, 음수는 ```0b10000011```로 표현하는 것이죠. 이런 방법을 생각하셨다면 이것도 크게 틀린 것은 아닙니다.  

하지만 더하기의 성질을 생각해보면 좀 더 나은 방법을 고안할 수도 있습니다. 절대값이 같은 양수와 음수를 더하면 0이 된다는 성질을 말이죠.  
예를들어 1바이트 signed char에 있는 2진수 ```0b01010101```에 무엇을 더하면 0이 될까요? ```0b10101011```을 더하면 어떻게 될까요? 자리 올림을 하다가 결국 1바이트로 표현할 수 있는 범위를 벗어나게 됩니다. ```0b100000000```이 되고, 8비트 범위를 벗어난 1은 버려져서 결과적으로 ```0b00000000```이 되는 것이죠.

그렇다면 더해서 0이 되는 수를 어떻게 쉽게 구할 수 있을까요? 이는 역사에 길이 남을 천재 존 폰 노이만이 제안한 2의 보수(Two's complement)로 쉽게 구할 수 있습니다.  
보수(complement)란 두 수의 합이 진법의 밑수가 되게 하는 수 입니다. 예를 들어 십진수 3의 10의 보수는 7 입니다. 보수의 성질은 디지털 논리 과목에서 더욱 자세하게 공부하도록 하고, 이진수 2의 보수 구하는 방법을 살펴보겠습니다.  
정말 쉽습니다. 먼저 이진수의 모든 자리가 1인 수에서 주어진 수를 빼면 1의 보수를 얻을 수 있습니다. 이를 더 쉽게 이야기하면 이진수의 모든 자릿수를 1은 0으로, 0은 1로 뒤집으면 1의 보수가 됩니다. 그리고 1의 보수에 1을 더하면 2의 보수가 됩니다.  
위에서 예시로 든 ```0b01010101```의 경우 모든 자릿수를 뒤집어서 1의 보수를 구하면 ```0b10101010```이 됩니다. 여기에 1을 더하면 2의 보수인 ```0b10101011```이 되죠.  
하나만 더 예시로 들어서 ```0b00000011```의 1의 보수는 ```0b11111100```입니다. 여기에 1을 더해서 2의 보수를 구하면 ```0b11111101``` 입니다.  
원래 수와 구한 2의 보수를 더해봅시다. 항상 표현 가능한 범위 내의 모든 자리가 0이 될 것입니다. 심지어 0에 대한 2의 보수를 구해보면 이조차 0이 되는 것을 볼 수 있습니다.  
또한, 0을 제외한 정수들을 양수와 음수 상관 없이 2의 보수를 구하면 그 결과 가장 큰 비트(가장 왼쪽의 비트)가 뒤집어지며, 2의 보수로 표현한 음수들은 가장 큰 비트가 1인 것을 확인할 수 있습니다.
이 외에도 2의 보수로 음의 정수를 나타냄으로써 빼기 연산을 음수에 대한 더하기 연산으로 효율적으로 대체할 수도 있습니다. (예를 들어 5 - 3이라는 식을 5 + (-3)이라는 식으로 계산할 수 있습니다.)

> Q. 부호 비트를 사용해서 음의 정수를 나타내는 방법은 2의 보수를 사용해서 음의 정수를 나타내는 것보다 좋지 않은 것이 더하기/빼기 연산의 효율 외에 무엇이 더 있을까요?

> A. 부호 비트를 사용해서 음의 정수를 나타내면 양의 0과 음의 0이 따로 존재하게 됩니다. (0b00000000도 0b10000000도 0을 나타냅니다.) 서로 다른 비트 배열이 같은 수를 표현하는 것은 데이터의 낭비입니다.

> Q. 부호 있는 타입이 2의 보수로 음수를 나타내는 경우, 표현할 수 있는 양수의 절대값 범위와 음수의 절대값 범위가 동일한가요?

> A. 2의 보수에서는 음의 0 대신 음수 하나를 더 표현할 수 있습니다. 예를 들어, signed char가 표현할 수 있는 (0을 제외한) 양수의 범위가 1 ~ 127이라면 음수는 -128 ~ -1 입니다.

이렇게 저희는 컴퓨터가 음의 정수를 표현하는 방법을 잘 숙지할 수 있었습니다. 서론에서 했던 이야기를 다시 하면, 부호 있는 정수 타입은 가장 큰 비트(가장 왼쪽 비트)를 부호 비트로 표현하고, 2의 보수를 통해 음수를 표현하고 있습니다. 그리고 부호 없는 정수 타입은 가장 큰 비트도 양수의 값을 표현하는데 사용하여 0부터 해당 비트 크기로 표현할 수 있는 최대 수까지 표현할 수 있습니다. (예를 들어 unsigned char는 0 ~ 255까지 표현할 수 있습니다.)

#### 정수 오버플로우


#### 실수 타입 지정자

### 타입 캐스팅과 프로모션

## 상수


