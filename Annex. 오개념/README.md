# 오개념

* 포인터 파라미터 함수 인자에 주소 값을 전달하는 것은 Call-by-reference이다.
    * C언어에는 Call-by-reference가 없다. 모든 함수 인자 전달은 Call-by-value이다. Call-by-reference는 함수의 인자로 오브젝트를 직접 전달하고, 전달받은 함수는 해당 오브젝트의 복사본이 아닌 원본에 접근하는 경우를 이야기한다. C언어에서 포인터 인자에 주소 값을 전달하면, 포인터 변수에 해당 주소 값이 복사된다.
* ```i = 0; sizeof(i++); printf("%d", i);```의 출력 결과는 1이다.
    * ```sizeof``` 연산자는 피연산자를 평가하지 않으므로 출력 결과는 0이다.
* ```unsigned char c = 0; c -= 1;``` 의 결과로 변수 ```c```에 저장된 값이 255가 되는 것을 언더플로우라고 한다.
    * 이 또한 언더플로우가 아닌 오버플로우이며, 정수 연산에는 언더플로우가 없다. 언더플로우는 실수 연산에서 실수의 절대값이 표현할 수 있는 가장 작은 값보다 작아질 때 0이 되는 현상을 말한다.
* ```i++```를 사용하면 ```++i```보다 변수 ```i```에 저장된 값이 늦게 증가한다.
    * 변수 값의 증가는 side effect이며, 다음 시퀀스 포인트 이 전 아무 때나 증가할 수 있다. 변수의 값 증가 자체는 ```i++```가 ```++i```보다 빨리 증가할 수도, 늦게 증가할 수도, 같은 시점에 증가할 수도 있다.
* ```int j = i++;``` 라는 선언에서 변수 ```j``` 값 초기화보다 변수 ```i``` 증가가 늦게 일어난다.
    * ```i++```의 결과 값이 ```i```일 뿐, 변수 ```i```의 증가는 변수 ```j```의 값 초기화보다 먼저 발생한다. initializer와 declarator의 끝은 각각 시퀀스 포인트이기 때문에, 선언의 값 초기화는 initializer와 declarator 이 후로 시퀀스된다. 따라서, 변수 ```i```가 증가하는 side effect는 변수 j의 값 초기화보다 먼저 발생한다.
    * 위 선언의 동작 과정을 가상의 기계어로 번역하면 다음과 같다. ```tmp = i; i = tmp + 1; j = tmp;```
* ```int``` 타입 변수의 크기는 4이다.
    * C언어에서 ```(signed/unsigned) char``` 타입을 제외한 타입의 크기는 보장되지 않는다. 변수의 크기는 데이터 모델에 따라 달라진다. 실제로 과거에는 ```int``` 타입의 크기가 2인 데이터 모델을 사용했다.
* ```char``` 타입은 ```signed char```로 해석되며, 부호 있는 1 바이트 문자형 자료형이다.
    * ```char``` 타입은 ```unsigned char```인지 ```signed char```인지 구현에 따라 다르다. 실제로 ```char``` 타입은 gcc에서는 default로 ```signed char```이며, clang에서는 default로 ```unsigned char```이다.
* 문자열 리터럴은 상수로 취급된다.
    * 문자열 리터럴은 static 스토리지 클래스를 가지는 오브젝트이다.