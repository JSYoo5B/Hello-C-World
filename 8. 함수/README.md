# 함수

함수(function)는 C언어의 근간이 되는 요소 중 하나이다. 함수라는 용어는 수학의 함수에서 유래했는데, C언어에서는 특정한 동작을 수행하기 위한 선언과 명령문들의 모음에 이름을 붙인 것을 의미한다. 이렇게 특정한 명령어들을 모아둔 코드 조각을 함수라는 용어 외에도 서브루틴(subroutine)이나 프로시저(procedure)라고도 한다. 프로그래밍 언어에 따라 위 용어들이 구분되는 경우도 있지만, C언어에서는 세 용어 다 같은 의미를 갖는다.  

함수가 C언어의 근간이라고 말한 이유는 C언어가 절차적(절차지향) 프로그래밍 언어이기 때문이다. 절차적 프로그래밍 언어가 무엇인지 알기 위해서는 우선 명령형 프로그래밍이 무엇인지 알아야 한다.  
명령형 프로그래밍은 명령문을 통해 소프트웨어의 상태(state)를 변경시키는 프로그래밍 패러다임으로, 현존하는 대부분 프로그래밍 언어의 근간이 된다. 보통 소프트웨어의 상태는 메모리의 내용으로 정의되는데, 이를 추상화한 대표적인 예시가 변수이다. 즉, 명령문을 통해 변수같은 메모리의 내용을 변경시키는 것으로 원하는 동작을 수행하는 프로그래밍 패러다임이 명령형 프로그래밍인 것이다. 그리고 이 메모리의 변경을 칭하는 용어가 바로 이 전 챕터들에서 한번씩 이야기했던 사이드 이펙트(side effect)다. 참고로 최초의 명령형 프로그래밍 언어는 기계어로, 전기로 동작하는 현대 컴퓨터에서 동작한 최초의 언어이다.  

초기의 명령형 프로그래밍에서는 분기나 반복같은 명령어 이동을 모두 점프 명령어로 처리했다. 하지만 많은 컴퓨터 연구가들은 좀 더 구조화된 프로그램을 만들기 위하여 함수(서브루틴,프로시저)의 개발을 시도해서 함수 호출을 위한 명령을 만들어냈고, 함수 호출 메커니즘이 점차 발전하여 결국 포트란II에서 고수준 프로그래밍 언어 최초로 함수(서브루틴) 호출 문법을 도입했다.  

절차적 프로그래밍은 이 함수 메커니즘을 기반으로 명령형 프로그래밍에서 파생된 프로그래밍 패러다임이다. (즉, 명령형 프로그래밍의 부분 집합이다.) 기존에 단순히 명령어들을 나열하고 점프문을 통해 이동하는 것과 달리, 명령어들을 특정한 기능을 위해 모듈화한 함수 단위의 프로그램을 작성하는 것이 주요 특징이다. 우리가 여태까지 작성한 예제들도 결국 명령어들을 모아서 main 함수를 구성하는 것이었다. C언어는 현대까지 가장 많이 사용되는 절차적 프로그래밍 언어의 대표라고 할 수 있다.  

그런데 이야기를 듣다보니 함수를 근간으로 한 프로그래밍 패러다임이라면, 절차적 프로그래밍이 아니라 함수형 프로그래밍이라고 칭하는게 옳지 않은 것인가 하는 의문이 들 수 있다. 사실 절차적 프로그래밍의 원어는 Procedural Programming으로, 절차적 명령어들의 모음인 프로시저를 기반으로 한 프로그래밍이라는 뜻이다. 절차라는 용어보다 프로시저라는 용어에 더욱 집중해야 원 뜻을 이해할 수 있기 떄문에, 프로시저럴 프로그래밍이라고 하는 것이 좀 더 알맞을 수도 있었다. 아무튼 이 함수를 근간으로 한 프로그래밍 패러다임을 절차적 프로그래밍이라고 하는데다가, 심지어 함수형 프로그래밍이라는 패러다임은 별도로 존재한다. 함수형 프로그래밍이라고 할 때의 함수는 프로시저나 서브루틴과 동의어의 함수가 아닌, 수학적 함수를 의미한다.  

함수형 프로그래밍은 상태의 변경을 통해 원하는 동작을 수행하는 명령형 프로그래밍과 달리, 순수(pure) 함수 동작들을 응용하여 자료를 처리하는 프로그래밍 패러다임을 말한다. 여기서 순수 함수란 수학의 함수와 같이 동일한 인자를 입력하였을때 항상 같은 결과가 출력되는 함수를 말한다. 다시 말해 사이드 이펙트가 없는 함수를 의미한다. 하지만 실제 응용 프로그램을 개발하기 위하여 사용하는 대부분의 함수형 프로그래밍 언어들은 이렇게 순수 함수들로만 프로그램을 구성하도록 제한하지는 않고, 명령형 패러다임을 어느 정도 차용하고 있다. 최초의 함수형 프로그래밍 언어는 1956년에 발표된 IPL라는 언어이며, 이 후 1960년에 발표된 LISP라는 언어는 함수형 프로그래밍 패러다임을 잘 정제하여 만들어진 고급 프로그래밍 언어이다. LISP는 LISt Processing의 줄임말로, 이름(심볼) 있는 데이터로 구성된 리스트를 함수적으로 처리함으로써 (특히 인공지능 연구용) 수학적인 계산들을 컴퓨터 프로그램으로 수행하기 위해 주로 사용하였다. 현대 대부분 함수형 프로그래밍 언어가 이 LISP 언어로부터 영향을 받아 탄생하였다. 그런데 사실 이 함수형 프로그래밍 언어는 1930년대에 발표된 람다 대수라는 추상화된 수학적 개념을 기반으로 만들어졌다. 위의 LISP에서 언급한 함수적인 처리도 이 람다 대수를 기반으로 한 것이다. 따라서 명령형 프로그래밍과 함께 프로그래밍 패러다임의 거대한 두 시조라고 할 수 있다.  

이 외에 참고로 프로그래밍을 학습하다보면 앞으로 자주 접하게 될 객체 지향 프로그래밍이라는 패러다임도 존재한다. 간혹 객체 지향 프로그래밍이 그저 절차적 프로그래밍을 구조화하여 만든 패러다임이라고 오해하는 경우가 있는데, 사실 객체 지향 프로그래밍은 위의 함수형 프로그래밍과 절차적 프로그래밍을 조합하여 만들어낸 패러다임이다. 위에서 이야기한 함수형 언어의 대표인 LISP I Programmers Manual의 88 페이지를 보면 다음과 같은 문구가 나온다

```
Each of these atomic symbols has an association list associated with it, and in fact the atomic symbol on the list of atomic symbols points to the location of the association list.

In the local MIT patois, association lists are also referred to as "property lists", and atomic symbols are sometimes called "objects".
```  

고대의 LISP를 설명하기에는 책의 범위를 넘어서므로, 대략적으로 이야기하면 이름(심볼)로 표현하는 단일 데이터를 객체(object)라고 하고, 객체는 연관되는 속성 리스트(property list)와 연관될 수 있다는 것이다. LISP는 이런 객체 리스트들에 연속적인 함수적 처리들을 통해서 원하는 결과를 산출해낸다.  

그리고 위 LISP나 포트란과 함께 현대 프로그래밍 언어에 큰 영향을 준 ALGOL이라는 언어가 있는데, 이는 주로 알고리즘의 연구 개발과 컴퓨터를 이용한 수학적 연구를 위해 만들어진 언어이다. ALGOL언어는 굉장히 다양한 버전이 존재하는데, 절차적 프로그래밍을 비롯하여 굉장히 다양한 프로그래밍 패러다임을 지원했다. MIT에서 만든 ALGOL X는 특별한 특징이 있었는데, 자료구조에 프로시저를 연관시킬 수 있었다. 이러한 프로시저를 통해 특정하게 원하는 대상 데이터에 효과적으로 상태를 변경시킬 수 있었다.  

여태까지의 내용을 정리해보자. LISP에서는 어떠한 속성이 있는 객체들에 함수를 적용하여 원하는 결과를 도출해낸다고 하였다. ALGOL에서는 어떠한 데이터에 연관된 프로시저를 통해 상태 변화를 만들어낸다고 하였다. 이 두 가지 내용을 조합하면 재미난 생각을 해볼 수 있다. 어떠한 속성을 지닌 객체들이 메시지를 통해서 상호 작용하며 그 상태를 변경해나가는 것으로 소프트웨어의 가상 세계를 디자인하면 어떨까? 예를 들어 현실 세계에서 구매자라는 객체와 판매자가 있고, 이들은 소지 금액과 물품 보유 수라는 속성을 갖는다고 해보자. 그러면 구매자가 판매자에게 '돈을 지불한다' 라는 메시지를 보내면, 구매자의 소지 금액은 줄어들고 판매자의 소지 금액은 늘어날 것이다. 이제 그에 응답하여 판매자는 구매자에게 '물품을 건넨다' 라는 메시지를 보내면, 판매자의 물품 보유 수는 줄어들고 구매자의 물품 보유 수는 늘어날 것이다. 이런 방식으로 객체들이 메시지를 주고 받는 것으로 프로그램을 설계하는 것이 바로 객체 지향의 근간이다.  

이러한 개념들을 더욱 정제해서 Simula라는 기념비적인 언어가 탄생했다. 객체의 속성과 메시지의 동작 방식을 정의할 수 있는 클래스(class)라는 개념을 도입하였으며, 클래스를 통해 객체를 생성할 수 있게 하였다. 메시지의 동작 방식은 객체에 연관된 프로시저를 통해 정의했으며, 이를 메소드(method) 혹은 멤버 함수(member function)이라고 한다. 이 외에도 강아지와 고양이는 모두 포유류의 일종인데, 암컷 포유류는 젖샘이라는 속성을 가지고 새끼에게 수유하다 라는 메시지를 전달할 수 있다. 강아지와 고양이는 둘 다 포유류이므로 이러한 포유류의 속성을 그대로 가지고 있는데, 이렇게 하위 분류에 소속한 객체는 상위 분류에 소속한 객체의 속성을 그대로 물려받을 수 있다는 것을 상속(inheritance)이라는 개념으로 도입하였다. 이 외에도 동적 바인딩(dynamic binding)과 같은 개념도 추가하여 Simula는 객체 지향 프로그래밍 패러다임의 뼈대를 완성했으며, 추후 이를 더욱 일반화한 Smalltalk라는 언어 등이 등장하였다. 특히 C++ 언어는 C언어에 Simula와 Smalltalk의 객체 지향 개념을 도입하여 만든 언어이다.  

참고로 C언어에서 이야기 하는 객체(object)와 다른 객체 지향 언어들에서 이야기하는 객체의 의미가 조금 다른 이유가 바로 이것이다. 객체 지향 언어에서는 위와 같이 클래스를 통해 만들어낸 속성과 메소드를 지닌 아이템을 주로 객체라고 칭한다. 반면 C언어에서는 값을 나타낼 수 있는 데이터 저장 영역을 모두 객체라고 한다.  

여태까지 다양한 프로그래밍 패러다임들을 소개했는데, 사실 현대 상업적으로 사용하고 있는 대부분의 언어는 어느 하나의 패러다임만 지원하는 것이 아니라 다양한 패러다임을 복합적으로 지원한다. 심지어 굳이 언어적인 차원에서 어떠한 프로그래밍 패러다임을 지원하지 않다고 하더라도, 해당 언어가 가진 문법적인 요소들을 잘 조합하여 다른 프로그래밍 패러다임을 흉내내기도 한다. 예를 들어 C언어는 언어 차원에서 객체 지향 패러다임 요소들을 지원하지는 않지만, 추후에 학습할 구조체와 함수 포인터들을 이용하여 객체 지향 프로그래밍을 흉내내기도 한다. (실제로 리눅스 커널과 디바이스 드라이버의 많은 부분들이 이런 식으로 동작하기도 한다.) 따라서, 어떠한 프로그래밍 언어가 특정한 프로그래밍 패러다임 언어다 라고 이야기 하는게 맞을 수도 맞지 않을 수도 있다.  

C언어에서 함수의 중요성을 이야기하기 위하여 절차적 프로그래밍을 소개하다보니 다양한 프로그래밍 패러다임에 대해 소개하게 되었다. 비록 프로그래밍 패러다임에 대한 이야기가 이번 장에서 설명할 함수와 직접적인 연관이 없을 수도 있지만, 프로그래밍 언어에 대한 이해도를 좀 더 높여주고 C언어에서 함수가 얼마나 중요한지 인지시켜주는 계기가 되었으면 한다. 그러면 본격적으로 C언어의 함수에 대해 학습해보도록 하자.  

## 함수 체험하기

본격적인 함수의 개념과 문법 요소들에 대해 학습하기 전에 예제들을 통해 간단하게 함수를 만들고 사용해보면서 함수가 필요한 이유에 대해 알아보자.  
기존에 1부터 N까지 자연수의 합을 구하는 예제의 경우 main 함수에서 모든 것을 처리하였다. 함수를 응용하여 해당 내용을 수정하면 다음과 같다. (예제가 정확히 이해가지 않아도 괜찮다.)  

```c
int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);      // 함수의 인자로 n을 전달하여 함수를 호출하고 결과 값을 저장
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}
```  

동작은 이 전 예제들과 크게 달라지지 않은 것 같은데, 어쩐지 소스 코드는 괜히 더 복잡해진듯 보인다. 그래도 합을 구하는 단계와 입력 및 출력 단계를 나눠서 프로그램의 전체적인 흐름을 나눠볼 수 있는 것은 장점으로 보인다.  
그렇다면 함수의 장점은 이게 전부일까? 예제 상황을 아주 조금 더 복잡하게 만들어보자. 이번에는 1부터 N까지의 자연수의 합과 1부터 M까지의 자연수의 합을 구해서 두 수의 합을 구한다고 가정해보자. 함수를 사용하지 않으면 다음과 같을 것이다.  

```c
int main(void)
{
    int n, m, sum, sum1 = 0, sum2 = 0;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {  // 1부터 n까지의 합
        sum1 += i;
    }
    for (int i = 1; i <= m; i++) {  // 1부터 m까지의 합
        sum2 += i;
    }
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

1부터 N까지의 합을 구하는 코드와 1부터 M까지의 합을 구하는 코드가 굉장히 유사하다. 제어 식의 비교에 사용된 변수와 누산을 위한 변수만 다를 뿐, 그 외에는 모두 동일하다.  
이 전 챕터에서 똑같은 코드를 여러 번 반복해서 나열하는 것이 싫어서 반복문을 학습했다. 그러면 위의 코드도 반복문으로 바꾸면 될까? 이중 반복문을 사용해서 중복 코드를 줄일 수도 있기야 하겠지만, 이러한 상황에서는 함수를 사용하면 다음과 같이 훨씬 깔끔하게 코드를 정리할 수 있다.  

```c
int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, m, sum, sum1 = 0, sum2 = 0;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    sum1 = accumulation(n);     // 함수를 호출하고 결과 값을 저장
    sum2 = accumulation(m);     // 함수를 호출하고 결과 값을 저장
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

한 번 정의한 함수를 여러 번 호출하여 반복되는 코드를 단숨에 줄일 수 있었다. 함수는 이렇게 한 번 잘 정의하면 원하는 곳에서 여러 번 사용할 수 있기 때문에 재사용성(reusability)할 수 있다고 한다.  
재사용성은 프로그래밍에 있어 절대적인 강점이며 수많은 프로그래밍 스킬과 아키텍처들은 그 뿌리에 재사용성을 염두에 두고 있을 정도로 중요하다.  
그리고 사실 처음에 언급했던 프로그램을 단계별로 명확하게 나눠서 각 단계를 함수로 만들면 각각의 단계를 이해하기 쉬워진다는 장점도 작은 부분이 아니다.  
뿐만 아니라, 억지스럽지만 회사에서 우리 팀에 1부터 N까지 자연수의 합을 구하는 프로그램을 만들어달라는 업무가 할당됐다고 가정해보자.  
이 업무를 본인과 동료 한 명을 더해 두 명이서 수행한다고 했을 때, 두 명이서 처음부터 끝까지 프로그래밍을 같이 진행할 수도 있다. 하지만 단계를 나눠서 합을 구하는 단계를 본인이, 입력과 출력을 수행하는 단계를 동료가 맡고 각자 맡은 함수만 잘 구현하여 조립하면 이론상 두 배 빠르게 일을 끝낼 수도 있다.  

또 한가지 중요한 사실은, 여기까지 학습한 독자분들은 이미 함수를 여러 번 사용하였으므로 그 강력한 장점을 은연중에 느끼고 있어야 한다. 그렇다, printf 함수와 scanf 함수도 우리가 정의하지 않았지만 함수인 것이다.  
여태까지 별 신경 쓰지 않고 입출력 함수를 사용해왔지만, 사실 터미널에 무엇인가를 입력하고 출력한다는 행위 자체가 굉장히 고난이도의 작업이다. 심지어 이 내용은 너무 어려워서 해당 책의 범위를 벗어나므로 자세히 다루지도 않을 것이다.  
그런데도 우리는 별 어려움 없이 터미널에 입출력을 해왔다. 이것이 바로 함수의 마법이다. 비록 어떤 함수의 내부가 어떻게 만들어졌는지 알지 못하더라도, 그 함수의 사용법만 알면 해당 함수가 제공하는 기능을 그대로 이용할 수 있다.  

함수에는 이렇게 많은 장점이 있기 때문에 이번 챕터의 서두에서 이야기한 것과 같이 컴퓨터 연구가들은 서브 루틴 명령어를 지원하도록 매달렸던 것이다. 이만 함수의 필요성과 대략적인 형태를 확인하였으니 본격적인 요소들에 대해 학습해보자.  

## 함수 정의하기