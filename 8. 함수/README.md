# 함수

함수(function)는 C언어의 근간이 되는 요소 중 하나이다. 함수라는 용어는 수학의 함수에서 유래했는데, C언어에서는 특정한 동작을 수행하기 위한 선언과 명령문들의 모음에 이름을 붙인 것을 의미한다. 이렇게 특정한 명령어들을 모아둔 코드 조각을 함수라는 용어 외에도 서브루틴(subroutine)이나 프로시저(procedure)라고도 한다. 프로그래밍 언어에 따라 위 용어들이 구분되는 경우도 있지만, C언어에서는 세 용어 다 같은 의미를 갖는다.  

함수가 C언어의 근간이라고 말한 이유는 C언어가 절차적(절차지향) 프로그래밍 언어이기 때문이다. 절차적 프로그래밍 언어가 무엇인지 알기 위해서는 우선 명령형 프로그래밍이 무엇인지 알아야 한다.  
명령형 프로그래밍은 명령문을 통해 소프트웨어의 상태(state)를 변경시키는 프로그래밍 패러다임으로, 현존하는 대부분 프로그래밍 언어의 근간이 된다. 보통 소프트웨어의 상태는 메모리의 내용으로 정의되는데, 이를 추상화한 대표적인 예시가 변수이다. 즉, 명령문을 통해 변수같은 메모리의 내용을 변경시키는 것으로 원하는 동작을 수행하는 프로그래밍 패러다임이 명령형 프로그래밍인 것이다. 그리고 이 메모리의 변경을 칭하는 용어가 바로 이 전 챕터들에서 한번씩 이야기했던 사이드 이펙트(side effect)다. 참고로 최초의 명령형 프로그래밍 언어는 기계어로, 전기로 동작하는 현대 컴퓨터에서 동작한 최초의 언어이다.  

초기의 명령형 프로그래밍에서는 분기나 반복같은 명령어 이동을 모두 점프 명령어로 처리했다. 하지만 많은 컴퓨터 연구가들은 좀 더 구조화된 프로그램을 만들기 위하여 함수(서브루틴,프로시저)의 개발을 시도해서 함수 호출을 위한 명령을 만들어냈고, 함수 호출 메커니즘이 점차 발전하여 결국 포트란II에서 고수준 프로그래밍 언어 최초로 함수(서브루틴) 호출 문법을 도입했다.  

절차적 프로그래밍은 이 함수 메커니즘을 기반으로 명령형 프로그래밍에서 파생된 프로그래밍 패러다임이다. (즉, 명령형 프로그래밍의 부분 집합이다.) 기존에 단순히 명령어들을 나열하고 점프문을 통해 이동하는 것과 달리, 명령어들을 특정한 기능을 위해 모듈화한 함수 단위의 프로그램을 작성하는 것이 주요 특징이다. 우리가 여태까지 작성한 예제들도 결국 명령어들을 모아서 main 함수를 구성하는 것이었다. C언어는 현대까지 가장 많이 사용되는 절차적 프로그래밍 언어의 대표라고 할 수 있다.  

그런데 이야기를 듣다보니 함수를 근간으로 한 프로그래밍 패러다임이라면, 절차적 프로그래밍이 아니라 함수형 프로그래밍이라고 칭하는게 옳지 않은 것인가 하는 의문이 들 수 있다. 사실 절차적 프로그래밍의 원어는 Procedural Programming으로, 절차적 명령어들의 모음인 프로시저를 기반으로 한 프로그래밍이라는 뜻이다. 절차라는 용어보다 프로시저라는 용어에 더욱 집중해야 원 뜻을 이해할 수 있기 떄문에, 프로시저럴 프로그래밍이라고 하는 것이 좀 더 알맞을 수도 있었다. 아무튼 이 함수를 근간으로 한 프로그래밍 패러다임을 절차적 프로그래밍이라고 하는데다가, 심지어 함수형 프로그래밍이라는 패러다임은 별도로 존재한다. 함수형 프로그래밍이라고 할 때의 함수는 프로시저나 서브루틴과 동의어의 함수가 아닌, 수학적 함수를 의미한다.  

함수형 프로그래밍은 상태의 변경을 통해 원하는 동작을 수행하는 명령형 프로그래밍과 달리, 순수(pure) 함수 동작들을 응용하여 자료를 처리하는 프로그래밍 패러다임을 말한다. 여기서 순수 함수란 수학의 함수와 같이 동일한 인자를 입력하였을때 항상 같은 결과가 출력되는 함수를 말한다. 다시 말해 사이드 이펙트가 없는 함수를 의미한다. 하지만 실제 응용 프로그램을 개발하기 위하여 사용하는 대부분의 함수형 프로그래밍 언어들은 이렇게 순수 함수들로만 프로그램을 구성하도록 제한하지는 않고, 명령형 패러다임을 어느 정도 차용하고 있다. 최초의 함수형 프로그래밍 언어는 1956년에 발표된 IPL라는 언어이며, 이 후 1960년에 발표된 LISP라는 언어는 함수형 프로그래밍 패러다임을 잘 정제하여 만들어진 고급 프로그래밍 언어이다. LISP는 LISt Processing의 줄임말로, 이름(심볼) 있는 데이터로 구성된 리스트를 함수적으로 처리함으로써 (특히 인공지능 연구용) 수학적인 계산들을 컴퓨터 프로그램으로 수행하기 위해 주로 사용하였다. 현대 대부분 함수형 프로그래밍 언어가 이 LISP 언어로부터 영향을 받아 탄생하였다. 그런데 사실 이 함수형 프로그래밍 언어는 1930년대에 발표된 람다 대수라는 추상화된 수학적 개념을 기반으로 만들어졌다. 위의 LISP에서 언급한 함수적인 처리도 이 람다 대수를 기반으로 한 것이다. 따라서 명령형 프로그래밍과 함께 프로그래밍 패러다임의 거대한 두 시조라고 할 수 있다.  

이 외에 참고로 프로그래밍을 학습하다보면 앞으로 자주 접하게 될 객체 지향 프로그래밍이라는 패러다임도 존재한다. 간혹 객체 지향 프로그래밍이 그저 절차적 프로그래밍을 구조화하여 만든 패러다임이라고 오해하는 경우가 있는데, 사실 객체 지향 프로그래밍은 위의 함수형 프로그래밍과 절차적 프로그래밍을 조합하여 만들어낸 패러다임이다. 위에서 이야기한 함수형 언어의 대표인 LISP I Programmers Manual의 88 페이지를 보면 다음과 같은 문구가 나온다

```
Each of these atomic symbols has an association list associated with it, and in fact the atomic symbol on the list of atomic symbols points to the location of the association list.

In the local MIT patois, association lists are also referred to as "property lists", and atomic symbols are sometimes called "objects".
```  

고대의 LISP를 설명하기에는 책의 범위를 넘어서므로, 대략적으로 이야기하면 이름(심볼)로 표현하는 단일 데이터를 객체(object)라고 하고, 객체는 연관되는 속성 리스트(property list)와 연관될 수 있다는 것이다. LISP는 이런 객체 리스트들에 연속적인 함수적 처리들을 통해서 원하는 결과를 산출해낸다.  

그리고 위 LISP나 포트란과 함께 현대 프로그래밍 언어에 큰 영향을 준 ALGOL이라는 언어가 있는데, 이는 주로 알고리즘의 연구 개발과 컴퓨터를 이용한 수학적 연구를 위해 만들어진 언어이다. ALGOL언어는 굉장히 다양한 버전이 존재하는데, 절차적 프로그래밍을 비롯하여 굉장히 다양한 프로그래밍 패러다임을 지원했다. MIT에서 만든 ALGOL X는 특별한 특징이 있었는데, 자료구조에 프로시저를 연관시킬 수 있었다. 이러한 프로시저를 통해 특정하게 원하는 대상 데이터에 효과적으로 상태를 변경시킬 수 있었다.  

여태까지의 내용을 정리해보자. LISP에서는 어떠한 속성이 있는 객체들에 함수를 적용하여 원하는 결과를 도출해낸다고 하였다. ALGOL에서는 어떠한 데이터에 연관된 프로시저를 통해 상태 변화를 만들어낸다고 하였다. 이 두 가지 내용을 조합하면 재미난 생각을 해볼 수 있다. 어떠한 속성을 지닌 객체들이 메시지를 통해서 상호 작용하며 그 상태를 변경해나가는 것으로 소프트웨어의 가상 세계를 디자인하면 어떨까? 예를 들어 현실 세계에서 구매자라는 객체와 판매자가 있고, 이들은 소지 금액과 물품 보유 수라는 속성을 갖는다고 해보자. 그러면 구매자가 판매자에게 '돈을 지불한다' 라는 메시지를 보내면, 구매자의 소지 금액은 줄어들고 판매자의 소지 금액은 늘어날 것이다. 이제 그에 응답하여 판매자는 구매자에게 '물품을 건넨다' 라는 메시지를 보내면, 판매자의 물품 보유 수는 줄어들고 구매자의 물품 보유 수는 늘어날 것이다. 이런 방식으로 객체들이 메시지를 주고 받는 것으로 프로그램을 설계하는 것이 바로 객체 지향의 근간이다.  

이러한 개념들을 더욱 정제해서 Simula라는 기념비적인 언어가 탄생했다. 객체의 속성과 메시지의 동작 방식을 정의할 수 있는 클래스(class)라는 개념을 도입하였으며, 클래스를 통해 객체를 생성할 수 있게 하였다. 메시지의 동작 방식은 객체에 연관된 프로시저를 통해 정의했으며, 이를 메소드(method) 혹은 멤버 함수(member function)이라고 한다. 이 외에도 강아지와 고양이는 모두 포유류의 일종인데, 암컷 포유류는 젖샘이라는 속성을 가지고 새끼에게 수유하다 라는 메시지를 전달할 수 있다. 강아지와 고양이는 둘 다 포유류이므로 이러한 포유류의 속성을 그대로 가지고 있는데, 이렇게 하위 분류에 소속한 객체는 상위 분류에 소속한 객체의 속성을 그대로 물려받을 수 있다는 것을 상속(inheritance)이라는 개념으로 도입하였다. 이 외에도 동적 바인딩(dynamic binding)과 같은 개념도 추가하여 Simula는 객체 지향 프로그래밍 패러다임의 뼈대를 완성했으며, 추후 이를 더욱 일반화한 Smalltalk라는 언어 등이 등장하였다. 특히 C++ 언어는 C언어에 Simula와 Smalltalk의 객체 지향 개념을 도입하여 만든 언어이다.  

참고로 C언어에서 이야기 하는 객체(object)와 다른 객체 지향 언어들에서 이야기하는 객체의 의미가 조금 다른 이유가 바로 이것이다. 객체 지향 언어에서는 위와 같이 클래스를 통해 만들어낸 속성과 메소드를 지닌 아이템을 주로 객체라고 칭한다. 반면 C언어에서는 값을 나타낼 수 있는 데이터 저장 영역을 모두 객체라고 한다.  

여태까지 다양한 프로그래밍 패러다임들을 소개했는데, 사실 현대 상업적으로 사용하고 있는 대부분의 언어는 어느 하나의 패러다임만 지원하는 것이 아니라 다양한 패러다임을 복합적으로 지원한다. 심지어 굳이 언어적인 차원에서 어떠한 프로그래밍 패러다임을 지원하지 않다고 하더라도, 해당 언어가 가진 문법적인 요소들을 잘 조합하여 다른 프로그래밍 패러다임을 흉내내기도 한다. 예를 들어 C언어는 언어 차원에서 객체 지향 패러다임 요소들을 지원하지는 않지만, 추후에 학습할 구조체와 함수 포인터들을 이용하여 객체 지향 프로그래밍을 흉내내기도 한다. (실제로 리눅스 커널과 디바이스 드라이버의 많은 부분들이 이런 식으로 동작하기도 한다.) 따라서, 어떠한 프로그래밍 언어가 특정한 프로그래밍 패러다임 언어다 라고 이야기 하는게 맞을 수도 맞지 않을 수도 있다.  

C언어에서 함수의 중요성을 이야기하기 위하여 절차적 프로그래밍을 소개하다보니 다양한 프로그래밍 패러다임에 대해 소개하게 되었다. 비록 프로그래밍 패러다임에 대한 이야기가 이번 장에서 설명할 함수와 직접적인 연관이 없을 수도 있지만, 프로그래밍 언어에 대한 이해도를 좀 더 높여주고 C언어에서 함수가 얼마나 중요한지 인지시켜주는 계기가 되었으면 한다. 그러면 본격적으로 C언어의 함수에 대해 학습해보도록 하자.  

## 함수 체험하기

본격적인 함수의 개념과 문법 요소들에 대해 학습하기 전에 예제들을 통해 간단하게 함수를 만들고 사용해보면서 함수가 필요한 이유에 대해 알아보자.  
기존에 1부터 N까지 자연수의 합을 구하는 예제의 경우 main 함수에서 모든 것을 처리하였다. 함수를 응용하여 해당 내용을 수정하면 다음과 같다. (예제가 정확히 이해가지 않아도 괜찮다.)  

```c
int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;    // main 함수의 sum과는 별개의 변수
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);      // 함수의 인자로 n을 전달하여 함수를 호출하고 결과 값을 저장
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}
```  

동작은 이 전 예제들과 크게 달라지지 않은 것 같은데, 어쩐지 소스 코드는 괜히 더 복잡해진듯 보인다. 그래도 합을 구하는 단계와 입력 및 출력 단계를 나눠서 프로그램의 전체적인 흐름을 나눠볼 수 있는 것은 장점으로 보인다.  
그렇다면 함수의 장점은 이게 전부일까? 예제 상황을 아주 조금 더 복잡하게 만들어보자. 이번에는 1부터 N까지의 자연수의 합과 1부터 M까지의 자연수의 합을 구해서 두 수의 합을 구한다고 가정해보자. 함수를 사용하지 않으면 다음과 같을 것이다.  

```c
int main(void)
{
    int n, m, sum, sum1 = 0, sum2 = 0;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {  // 1부터 n까지의 합
        sum1 += i;
    }
    for (int i = 1; i <= m; i++) {  // 1부터 m까지의 합
        sum2 += i;
    }
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

1부터 N까지의 합을 구하는 코드와 1부터 M까지의 합을 구하는 코드가 굉장히 유사하다. 제어 식의 비교에 사용된 변수와 누산을 위한 변수만 다를 뿐, 그 외에는 모두 동일하다.  
이 전 챕터에서 똑같은 코드를 여러 번 반복해서 나열하는 것이 싫어서 반복문을 학습했다. 그러면 위의 코드도 반복문으로 바꾸면 될까? 이중 반복문을 사용해서 중복 코드를 줄일 수도 있기야 하겠지만, 이러한 상황에서는 함수를 사용하면 다음과 같이 훨씬 깔끔하게 코드를 정리할 수 있다.  

```c
// accumulation_sum.c
#include <stdio.h>

int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, m, sum, sum1, sum2;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    sum1 = accumulation(n);     // 함수를 호출하고 결과 값을 저장
    sum2 = accumulation(m);     // 함수를 호출하고 결과 값을 저장
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make accumulation_sum
cc     accumulation_sum.c   -o accumulation_sum
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./accumulation_sum 
자연수 N, M을 입력하세요 : 5 7 
합의 합 : 43
```  

한 번 정의한 함수를 여러 번 호출하여 반복되는 코드를 단숨에 줄일 수 있었다. 함수는 이렇게 한 번 잘 정의하면 원하는 곳에서 여러 번 사용할 수 있기 때문에 재사용성(reusability)할 수 있다고 한다.  
재사용성은 프로그래밍에 있어 절대적인 강점이며 수많은 프로그래밍 스킬과 아키텍처들은 그 뿌리에 재사용성을 염두에 두고 있을 정도로 중요하다.  
그리고 사실 처음에 언급했던 프로그램을 단계별로 명확하게 나눠서 각 단계를 함수로 만들면 각각의 단계를 이해하기 쉬워진다는 장점도 작은 부분이 아니다.  
뿐만 아니라, 억지스럽지만 회사에서 우리 팀에 1부터 N까지 자연수의 합을 구하는 프로그램을 만들어달라는 업무가 할당됐다고 가정해보자.  
이 업무를 본인과 동료 한 명을 더해 두 명이서 수행한다고 했을 때, 두 명이서 처음부터 끝까지 프로그래밍을 같이 진행할 수도 있다. 하지만 단계를 나눠서 합을 구하는 단계를 본인이, 입력과 출력을 수행하는 단계를 동료가 맡고 각자 맡은 함수만 잘 구현하여 조립하면 이론상 두 배 빠르게 일을 끝낼 수도 있다.  

또 한가지 중요한 사실은, 여기까지 학습한 독자분들은 이미 함수를 여러 번 사용하였으므로 그 강력한 장점을 은연중에 느끼고 있어야 한다. 그렇다, printf 함수와 scanf 함수도 우리가 정의하지 않았지만 함수인 것이다.  
여태까지 별 신경 쓰지 않고 입출력 함수를 사용해왔지만, 사실 터미널에 무엇인가를 입력하고 출력한다는 행위 자체가 굉장히 고난이도의 작업이다. 심지어 이 내용은 너무 어려워서 해당 책의 범위를 벗어나므로 자세히 다루지도 않을 것이다.  
그런데도 우리는 별 어려움 없이 터미널에 입출력을 해왔다. 이것이 바로 함수의 마법이다. 비록 어떤 함수의 내부가 어떻게 만들어졌는지 알지 못하더라도, 그 함수의 사용법만 알면 해당 함수가 제공하는 기능을 그대로 이용할 수 있다.  

함수에는 이렇게 많은 장점이 있기 때문에 이번 챕터의 서두에서 이야기한 것과 같이 컴퓨터 연구가들은 서브 루틴 명령어를 지원하도록 매달렸던 것이다. 이만 함수의 필요성과 대략적인 형태를 확인하였으니 본격적인 요소들에 대해 학습해보자.  

## 함수 정의하기

함수를 정의하기 위한 문법적인 형태는 다음과 같다.  

```c
attribute-specifier-sequence(opt) declaration-specifiers declarator function-body
```  

당연하지만 위의 내용만 보고는 무슨 말인지 알 수 없다. 여기서 function-body는 compound statement이고, declarator는 무엇이고, declaration-specifiers는 무엇이고, ... 와 같이 설명을 할 수도 있겠지만 혼란만 초래할 것이다. 위 형태를 알아보기 쉽게 일반화하면 다음과 같이 표현할 수 있다.  

```c
return-type function-name(parameter-type-list)
compound-statement
```  

훨씬 나아졌지만 아직도 조금 복잡해 보인다. 한국어를 사용하고 조금 더 쉽게 표현하면 다음과 같다.  

```c
반환타입 함수이름(파라미터리스트)
{
    선언들과 문장들
}
```  

이제 어디서 많이 본 것 같다. 반환 타입이 ```int```, 함수 이름이 ```main```, 파라미터 리스트가 ```void```, 문장이 ```return 0;``` 이면 어떻게 될까?  

```c
int main(void)
{
    return 0;
}
```  

너무나도 익숙한 main 함수가 탄생했다.  
함수는 이렇게 '반환 타입', '함수 이름', '파라미터 리스트', '함수 몸체'로 구성된다.  
각 요소를 설명하기 전에 함수가 어떠한 과정으로 실행되는지 알아보자.  
우선, 함수의 호출자가 함수에 인자(argument)를 전달하여 호출한다. 예를 들어 main 함수에서 위 예제의 accumulation 함수를 호출하는 것과 같다.  
그러면 피호출자 함수는 인자 값을 파라미터(parameter)로 전달 받고, 함수의 몸체를 실행한다. 몸체를 실행하다가 return 문을 만나면 함수를 종료하며, return 문에 지정한 값을 호출자에게 반환한다. 마찬가지로 위 예제 accumulation 함수의 ```return sum;``` 문장에서 변수 sum에 있는 값을 호출자에게 반환하여, ```sum = accumulation(n);``` 문장에서 해당 반환 값을 변수 sum에 저장한 것이다. (main 함수의 sum 변수와 accumulation 함수의 sum 변수는 별도의 변수이다.)  

함수의 동작 방식은 위와 같으며, 함수의 각 요소의 역할은 다음과 같다.  
* 반환 타입 : 함수가 반환할 값의 타입을 지정한다. return 문에서 반환한 값이 해당 타입으로 호출자에게 전달된다.  
* 함수 이름 : 프로그램 내에서 함수를 유일하게 구별할 식별자이다.  
* 파라미터 리스트 : 함수가 전달받을 인자 값들을 담기 위한 변수 리스트이다.  
* 함수 몸체 : 함수가 수행할 명령문들의 모음이다. 함수의 몸체는 복합문으로 정의한다.  

함수의 인자를 뜻하는 원어는 argument와 parameter 두 가지가 있다. 일반적으로 함수를 호출하는 곳에서 전달하는 인자를 argument라고 하고, 함수를 정의하는 곳에서 전달받는 인자를 parameter라고 한다. 이 두 용어는 엄격하게 구분되는 것은 아니라서 혼용하기도 하지만, 이해의 편의를 위해 해당 서적에서는 이 둘을 구분하여 사용할 것이다. 한국어로 번역하면 두 용어 모두 인자가 되기 때문에, argument는 인자로 parameter는 파라미터로 표현할 것이므로 이 후 학습에 참고하길 바란다. (간혹가다가 두 용어를 모두 포함하는 의미로 인자라는 용어를 사용하기도 할 것이다.)  

함수는 한 가지 예외를 제외하고 항상 return 문으로 종료해야 한다. 한 가지 예외는 반환 타입이 ```void``` 타입인 경우인데, 이는 함수가 반환하는 값이 없다는 의미이다. 이 경우엔 함수 몸체의 끝에 도달하면 함수가 종료된다. return 문을 사용해서 함수를 종료할 수도 있지만, return 문에 반환할 값을 지정할 수는 없다.  

이와 유사하게 함수의 인자가 존재하지 않을 수도 있는데, 이 경우 파라미터 리스트를 비우거나 ```void```를 지정해줘야 한다. 그리고 호출부의 인자 리스트에는 아무 것도 지정하지 않으면 된다.  

다음 예제는 반환 타입과 파라미터 리스트가 모두 void인 함수를 정의하고 호출한다.  

```c
// void_function.c
#include <stdio.h>

void func(void)
{
    printf("func\n");
}

int main(void)
{
    printf("main\n");
    func();
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make void_function
cc     void_function.c   -o void_function
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./void_function 
main
func
```  

언어에 따라 위와 같이 반환 타입과 인자가 없는 함수를 프로시저라고 구분하기도 하지만, C언어에서는 구분 없이 모두 함수라고 부른다.  

## 함수 선언하기

여태까지 예제들을 보면 항상 호출하는 함수가 main 함수보다 상단에 위치했다. 두 함수의 순서를 바꿀 수는 없을까? 예를 들어 예제를 다음과 같이 작성할 수 없을까?  

```c
#include <stdio.h>

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}

int accumulation(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

컴파일해보면 현재 사용하고 있는 환경에서는 다음과 같은 경고가 뜰 것이다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make test
cc     test.c   -o test
test.c: In function ‘main’:
test.c:8:11: warning: implicit declaration of function ‘accumulation’ [-Wimplicit-function-declaration]
    8 |     sum = accumulation(n);
      |           ^~~~~~~~~~~~
```  

어쨋든 실행 파일 만들어졌고 실행 되니까 잘 되는거 아닐까? 절대 아니다. 이는 프로그래머의 바보같은 실수를 해당 컴파일러가 넓은 아량으로 한 번 봐주었을 뿐 정상적인 상황이 아니다. 경우에 따라서 경고는 에러와 다를 바 없으며, 실제로 다른 컴파일러 및 환경을 사용하면 컴파일 에러 처리가 되기도 한다.  
이는 변수를 사용하기 전에 선언해야 하는 것과 유사하다. 즉, 호출되는 함수가 항상 호출하는 함수보다 상단에 위치해야 한다는 것인데, 예제와 같이 작은 규모의 프로그램이면 모를까 수천 수만 개의 함수들이 얽히고 설켜서 상호간의 호출을 반복하는데 이러한 순서를 보장할 수 있을까? 불가능하다.  

이러한 상황을 해결할 수 있도록 함수의 선언(declaration)과 정의(definition)를 분리할 수 있다. 소스 코드의 상단부에 사용하려는 함수들의 형태를 미리 선언해두고, 하단부에서 호출 순서에 상관 없이 원하는 위치에 함수를 정의할 수 있다. 위 예제의 경우 다음과 같이 accumulation 함수의 선언과 정의를 분리할 수 있다.  

```c
// function_declaration.c
#include <stdio.h>

int accumulation(int n);        // 함수 선언

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}

int accumulation(int n)         // 함수 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

컴파일 및 실행해보면 아무런 경고 혹은 에러 없이 정상적으로 동작하는 것을 확인할 수 있다.  
결국 함수를 호출하기 전에 선언이나 정의 둘 중 아무거나 존재하기만 하면 된다. 그리고 함수 선언의 문법적인 형태는 예제를 보면 알겠지만 다음과 같다.  

```c
반환타입 함수이름(파라미터리스트);
```  

사실 위의 내용 또한 간략화한 것이며, 명확한 형태는 direct-declarator라는 요소를 알아야 한다. 하지만 이 또한 지금 전부 학습하기엔 무리가 있으므로 우선 위와 같은 형태로 알아둬도 충분하다.  

### 함수 프로토타입

초기 C언어의 선언 및 정의의 형태는 현재와 조금 다른 모양새를 가졌다. 굳이 알 필요는 없지만, 대략 다음과 같다.  

```c
int accumulation();     // 구형 함수 선언

int main(void)
{
    sum = accumulation(5);
    return 0;
}

int accumulation(n)     // 구형 함수 정의
    int n;
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

이를 K&R 스타일의 함수 선언과 정의라고 하는데, 사용에 대한 지양을 권고하다가 C23 표준에 와서 결국 없어진 형태의 문법이다.  
이런 K&R 스타일의 함수 선언과 현재의 함수 선언 방식을 구분하기 위하여, 현재의 함수 선언 방식을 함수 프로토타입(function prototype)이라고 부르기도 한다. 프로토타입의 사전적인 의미는 실 제품 출시 전 제품의 원형이라는 뜻으로, 함수를 정의하기 전에 미리 그 형태를 구성하여 알려준다는 뜻이다.  

구형 K&R 스타일의 함수 선언 및 정의를 사용할 때와, 현재의 함수 프로토타입 및 정의를 사용할 때와 함수 인자 타입 평가 방식이 조금씩 달라진다. 따라서 K&R 형태와 현재의 형태를 혼용은 절대로 하면 안 된다. 예를 들어 프로토타입 방식으로 선언하고, K&R 방식으로 함수를 정의한다던지 하는 일은 절대로 하면 안 된다. 물론, K&R 스타일은 표준에서 쫓겨난 구형 방식이므로 애초에 사용을 지양해야 한다. (서적에서도 이런게 있다는 것을 소개하기 위하여 다뤘을 뿐, 굳이 학습할 필요조차 없다.)  

함수의 프로토타입에 대해서 조금 더 생각해보자. 프로토타입은 함수를 호출하기 전에 해당 함수가 어떤 형태를 가지고 있는지 알려주기 위해 존재한다. 즉, 호출 시점에 함수가 어떤 형태로 구성되어 있는지에 대한 정보를 제공해주기만 하면 된다.  
함수를 호출하는 시점에 알아야 하는 정보는 함수의 반환 타입, 함수의 이름, 파라미터의 개수 및 타입 정보이다. 이것들만 알면 함수를 호출할 때 필요한 정보는 모두 알고있는 것이다.  

```c
ret = func('a', 10, 3.14);
```  

그렇다면 호출시점에 몰라도 되는 정보는 무엇일까? 파라미터의 이름 즉, 파라미터 변수명은 몰라도 호출하는데 아무런 지장이 없다. 파라미터 변수 이름은 함수를 정의할 때 함수의 몸체에서 사용하기 위한 것이지 호출할 때는 몰라도 된다. 따라서, 함수의 프로토타입에서는 다음과 같이 파라미터 이름을 생략할 수 있다.  

```c
int accumulation(int);      // 파라미터 이름 생략, 개수와 타입만 알면 됨
void func(char, int, double);   // 파라미터 이름 생략, 개수와 타입만 알면 됨
```  

하지만 프로토타입에서 파라미터의 이름을 생략할 수 있다고 하더라도, 해당 소스 코드를 보는 동료 프로그래머가 함수의 프로토타입만 보고도 각 파라미터가 어떠한 역할을 하는지 파악할 수 있도록 이름을 명시해주는 것이 좋다.  

마지막으로 명심할 내용으로, 함수 프로토타입의 형태와 함수 정의의 형태가 동일해야 한다. 예를 들어, 함수 프로토타입은 ```int func(char, double)``` 이었는데 정의를 ```double func(int, short) {}``` 와 같이 반환 타입 혹은 파라미터 리스트 정보가 다르면 안 된다는 것이다. 심지어 ```unsigned int```와 ```int```간의 혼용조차도 허용되지 않으므로 주의가 필요하다.  

## 변수의 범위

이 전 예제에서 main 함수의 변수 sum과 accumulation 함수의 변수 sum은 다른 변수라고 언급하였다. 애초에 변수의 이름은 식별자(identifier)이고, 식별자는 특정한 범위 내에서 어떠한 개체를 유일하게 식별하기 위한 요소이므로 저 두 변수가 다른 개체가 아니라면 유일한 식별이라는 정의에 부합하지 못한다.  
그렇다면 서로 다른 함수라면 같은 이름의 변수 이름을 사용할 수 있는 것일까? 그렇다. 서로 다른 함수라면 변수명이 같더라도 둘이 별개의 변수로 취급하기 때문에 같은 이름을 사용할 수 있다.  
변수는 유효 범위라는 것이 정해져있기 때문에 이러한 방식으로 동작할 수 있다. 사실 변수의 유효 범위를 정확하게 이해하려면 변수의 스토리지 기간(storage duration), 식별 유효 범위(scope), 식별 링크(linkage) 라는 세 속성에 대해 자세히 알아야 한다. 이는 책의 후반부에서 살펴볼 것이므로 지금은 좀 더 일반적이고 간단한 개념인 지역 변수와 전역 변수에 대해 알아보자. 아래의 내용들은 아직 위의 속성들을 담지 못하여 엄밀한 내용은 아니지만 이 후 학습의 편의를 도와줄 것이다.  

> 지역 변수와 전역 변수는 표준에서 정의하고 있는 개념은 아니지만, ALGOL 이 후 대부분 언어들에 통용하는 개념으로 TCPL에서도 해당 용어를 사용한다.

지역 변수는 함수나 블록 내에 선언되어 해당 범위를 갖는 변수를 말한다. 즉, 함수 몸체를 포함하여 복합문의 내에서 선언한 변수는 해당 복합문 내에서만 유효한 지역 변수이며, 해당 지역을 벗어나면 사용할 수 없도록 파괴된다. 예를 들어 다음과 같은 변수들은 모두 지역 변수이다.  

```c
void func(void)
{
    int a = 3;      // 함수의 지역 변수 a
    
    if (a == 3) {
        int b = 1;      // 복합문의 지역 변수 b
        ...
    }   // 복합문 종료 시 지역 변수 b는 사라짐

    for (int i = 0; i < 10; i++) {  // for문의 지역 변수 i
        ...
    }   // for문 종료 시 지역 변수 i는 사라짐
    ...
    return 0;
}   // 함수 종료 시 지역 변수 a는 사라짐
```  

반면 전역 변수는 어떤 블록 내에도 속하지 않는 변수를 말한다. 함수 밖에 문장(statement)은 존재할 수 없었지만, 선언은 존재할 수 있다. 다시 말해 함수 밖에 변수를 선언할 수 있다. 이러한 변수를 전역 변수라고 하며 프로그램이 종료할 때까지 존재하면서 어디에서나 접근할 수 있다.  
예를 들어 다음과 같이 전역 변수를 선언하고 함수 내에서 사용할 수 있다.  

```c
int global = 10;        // 전역 변수

void func(void)
{
    printf("global : %d\n", global);    // 20 출력
}

int main(void)
{
    printf("global : %d\n", global);    // 10 출력
    global += 10;       // 10 증가
    func();         // func 함수 호출
}
```  

전역 변수는 프로그램이 실행될 때 생성되어, 프로그램이 종료할 때 사라진다. 전역 변수에 초기 값을 지정해주지 않으면 0으로 초기화되는데, 그렇다고 해서 초기 값을 지정해주지 않는 것은 좋지 않다. (0으로 초기화 하더라도 명시적인 초기값을 지정해주는 것이 좋다. 이는 지역 변수도 마찬가지이다.)  

그렇다면 지역 변수와 전역 변수의 이름이 같은 경우엔 어떻게 될까? 이 경우엔 유효 범위가 중첩 되어 지역 변수가 전역 변수를 가리게 된다. 이와 마찬가지로, 지역 변수 또한 서로 다른 유효 범위를 가지는 경우 같은 변수 명을 가질 수 있는데, 이 때 안쪽 유효 범위를 가진 변수가 바깥쪽 유효 범위를 가진 변수를 가리게 된다. 다음 예제를 보면서 해당 내용을 확인해보자.  

```c
// local_global.c
#include <stdio.h>

int var = 3;        // 전역변수 var 초기값 3

void func(void)
{
    printf("[3] 전역변수 var : %d\n", var);  // 전역변수 출력 (기존에 1 증가되었음)
    int var = 10;       // 지역변수 var 초기값 10
    printf("[4] 지역변수 var : %d\n", var);  // 지역변수 출력

    {
        printf("[5] 바깥 지역변수 var : %d\n", var);
        int var = 100;  // 지역변수 var 초기값 100 (바깥 지역변수 가림)
        printf("[6] 안쪽 지역변수 var : %d\n", var);  // 안쪽 지역변수 출력
    }

    printf("[7] 바깥 지역변수 var : %d\n", var);  // 바깥 지역변수 출력
}

int main(void)
{
    printf("[1] 전역변수 var : %d\n", var);  // 전역변수 출력
    var += 1;       // 전역변수 1 증가

    int var = 5;    // 지역변수 var 초기값 5
    printf("[2] 지역변수 var : %d\n", var);  // 지역변수 출력

    func();
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make local_global
cc     local_global.c   -o local_global
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./local_global 
[1] 전역변수 var : 3
[2] 지역변수 var : 5
[3] 전역변수 var : 4
[4] 지역변수 var : 10
[5] 바깥 지역변수 var : 10
[6] 안쪽 지역변수 var : 100
[7] 바깥 지역변수 var : 10
```  

함수 func에서 복합문 주변의 동작 결과를 자세히 살펴보자. 복합문 내부 범위의 var이 선언되기 전에는 바깥의 var을 사용하여서 5번 출력 결과는 10이었다. 이 후 내부 범위의 var이 선언되어 바깥의 var를 가려서 6번 출력 결과는 100이 되었다. 마지막으로 복합문을 빠져나가며 내부 var이 사라지고 다시 바깥의 지역 변수 var를 출력하여 7번 출력 결과는 10이 되었다.  

마지막으로 함수의 파라미터는 무엇일까? 함수의 정의에서 사용하는 파라미터는 함수를 호출하는 곳에서 전달한 인자 값으로 초기화한(복사한) 지역 변수로 취급된다. 이와 관련되어 더욱 자세한 내용들은 책의 후반부에서 학습할 예정이다.  

## 함수의 인자

C언어에서 모든 함수의 인자는 값이 복사되어 전달된다. 예를 들어 다음과 같은 예제 코드가 있을 때,  
```c
void func(int n) {
    ...
}

int main(void) {
    int a = 3;
    func(a);
    ...
}
```  
파라미터 n은 변수 a의 값을 복사하여 초기화한다. 이는 두 변수를 같은 유효 범위 내에서 ```int n = a;``` 처럼 선언한 것과 유사하다. 아래 예제의 주석을 보면 더욱 확실히 이해할 수 있을 것이다.  

```c
void func(int c) {  // c는 값을 복사하여 초기화
    c += 5;     // c를 수정하여도 a에 변화 없음
}

int main(void) {
    int a = 3;
    int b = a;  // a의 값으로 b를 초기화
    b += 5;     // b를 수정하여도 a에 변화 없음
    func(a);    // a의 값을 전달함
    return 0;
}
```  

이렇게 인자로 전달하는 값을 복사하여 함수의 인자를 평가하는 방식을 call-by-value 라고 한다. C언어에서는 모든 인자를 call-by-value 방식으로만 전달한다. 간혹 C언어에서 call-by-value 외의 호출 방식을 지원한다고 잘못 설명하는 경우가 있는데, 그러한 착각을 유발하는 원인은 포인터 챕터에서 다시 알아볼 것이다.  

### 함수 인자 형변환

여태까지 예제들은 함수를 호출할 때 전달하는 인자와 함수에서 전달받은 파라미터의 타입이 일치했다. 하지만 항상 인자와 파라미터의 타입이 완전히 일치해야 하는 것은 아니다. 두 타입이 호환만 가능하면 암시적 형변환(Implicit Type Conversion)이라는 것을 통해서 값을 적절히 전달한다.  

옛날 K&R 스타일의 함수 선언을 사용하거나, 함수를 호출하기 전에 함수의 선언(프로토타입)과 정의가 등장하지 않는 경우엔 기본 인자 승격(default argument promotion)이라는 동작을 우선 수행했다. ```float``` 타입은 ```double``` 타입으로, ```char``` 타입과 ```short``` 타입은 ```int``` 타입으로 변환하는 건데, 지금은 해당 내용을 크게 신경쓰지 않아도 괜찮다.  

현재와 같이 함수의 프로토타입을 사용하는 경우 전달받은 파라미터의 타입에 맞춰서 형변환이 발생한다. 예를 들어 ```void func(int a);``` 함수를 ```func(3.5)``` 처럼 호출하면 파라미터 a는 정수 3으로 초기화되며, ```void func(double a);``` 함수를 ```func(3)``` 처럼 호출하면 파라미터 a는 실수 3.0으로 초기화된다.  

사실 이 외에도 함수의 인자에 관하여 알고있어야 할 내용들이 아직 많다. 주로 배열이나 포인터와 관련된 인자 평가 내용이 남아있는데, 이는 관련된 챕터들에서 학습할 예정이다.  

## 함수의 종료



## 좋은 함수 만들기

## 함수 호출 메커니즘

## 재귀 함수