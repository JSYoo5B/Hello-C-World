# 함수

함수(function)는 C언어의 근간이 되는 요소 중 하나이다. 함수라는 용어는 수학의 함수에서 유래했는데, C언어에서는 특정한 동작을 수행하기 위한 선언과 명령문들의 모음에 이름을 붙인 것을 의미한다. 이렇게 특정한 명령어들을 모아둔 코드 조각을 함수라는 용어 외에도 서브루틴(subroutine)이나 프로시저(procedure)라고도 한다. 프로그래밍 언어에 따라 위 용어들이 구분되는 경우도 있지만, C언어에서는 세 용어 다 같은 의미를 갖는다.  

함수가 C언어의 근간이라고 말한 이유는 C언어가 절차적(절차지향) 프로그래밍 언어이기 때문이다. 절차적 프로그래밍 언어가 무엇인지 알기 위해서는 우선 명령형 프로그래밍이 무엇인지 알아야 한다.  
명령형 프로그래밍은 명령문을 통해 소프트웨어의 상태(state)를 변경시키는 프로그래밍 패러다임으로, 현존하는 대부분 프로그래밍 언어의 근간이 된다. 보통 소프트웨어의 상태는 메모리의 내용으로 정의되는데, 이를 추상화한 대표적인 예시가 변수이다. 즉, 명령문을 통해 변수같은 메모리의 내용을 변경시키는 것으로 원하는 동작을 수행하는 프로그래밍 패러다임이 명령형 프로그래밍인 것이다. 그리고 이 메모리의 변경을 칭하는 용어가 바로 이 전 챕터들에서 한번씩 이야기했던 사이드 이펙트(side effect)다. 참고로 최초의 명령형 프로그래밍 언어는 기계어로, 전기로 동작하는 현대 컴퓨터에서 동작한 최초의 언어이다.  

초기의 명령형 프로그래밍에서는 분기나 반복같은 명령어 이동을 모두 점프 명령어로 처리했다. 하지만 많은 컴퓨터 연구가들은 좀 더 구조화된 프로그램을 만들기 위하여 함수(서브루틴,프로시저)의 개발을 시도해서 함수 호출을 위한 명령을 만들어냈고, 함수 호출 메커니즘이 점차 발전하여 결국 포트란II에서 고수준 프로그래밍 언어 최초로 함수(서브루틴) 호출 문법을 도입했다.  

절차적 프로그래밍은 이 함수 메커니즘을 기반으로 명령형 프로그래밍에서 파생된 프로그래밍 패러다임이다. (즉, 명령형 프로그래밍의 부분 집합이다.) 기존에 단순히 명령어들을 나열하고 점프문을 통해 이동하는 것과 달리, 명령어들을 특정한 기능을 위해 모듈화한 함수 단위의 프로그램을 작성하는 것이 주요 특징이다. 우리가 여태까지 작성한 예제들도 결국 명령어들을 모아서 main 함수를 구성하는 것이었다. C언어는 현대까지 가장 많이 사용되는 절차적 프로그래밍 언어의 대표라고 할 수 있다.  

그런데 이야기를 듣다보니 함수를 근간으로 한 프로그래밍 패러다임이라면, 절차적 프로그래밍이 아니라 함수형 프로그래밍이라고 칭하는게 옳지 않은 것인가 하는 의문이 들 수 있다. 사실 절차적 프로그래밍의 원어는 Procedural Programming으로, 절차적 명령어들의 모음인 프로시저를 기반으로 한 프로그래밍이라는 뜻이다. 절차라는 용어보다 프로시저라는 용어에 더욱 집중해야 원 뜻을 이해할 수 있기 떄문에, 프로시저럴 프로그래밍이라고 하는 것이 좀 더 알맞을 수도 있었다. 아무튼 이 함수를 근간으로 한 프로그래밍 패러다임을 절차적 프로그래밍이라고 하는데다가, 심지어 함수형 프로그래밍이라는 패러다임은 별도로 존재한다. 함수형 프로그래밍이라고 할 때의 함수는 프로시저나 서브루틴과 동의어의 함수가 아닌, 수학적 함수를 의미한다.  

함수형 프로그래밍은 상태의 변경을 통해 원하는 동작을 수행하는 명령형 프로그래밍과 달리, 순수(pure) 함수 동작들을 응용하여 자료를 처리하는 프로그래밍 패러다임을 말한다. 여기서 순수 함수란 수학의 함수와 같이 동일한 인자를 입력하였을때 항상 같은 결과가 출력되는 함수를 말한다. 다시 말해 사이드 이펙트가 없는 함수를 의미한다. 하지만 실제 응용 프로그램을 개발하기 위하여 사용하는 대부분의 함수형 프로그래밍 언어들은 이렇게 순수 함수들로만 프로그램을 구성하도록 제한하지는 않고, 명령형 패러다임을 어느 정도 차용하고 있다. 최초의 함수형 프로그래밍 언어는 1956년에 발표된 IPL라는 언어이며, 이 후 1960년에 발표된 LISP라는 언어는 함수형 프로그래밍 패러다임을 잘 정제하여 만들어진 고급 프로그래밍 언어이다. LISP는 LISt Processing의 줄임말로, 이름(심볼) 있는 데이터로 구성된 리스트를 함수적으로 처리함으로써 (특히 인공지능 연구용) 수학적인 계산들을 컴퓨터 프로그램으로 수행하기 위해 주로 사용하였다. 현대 대부분 함수형 프로그래밍 언어가 이 LISP 언어로부터 영향을 받아 탄생하였다. 그런데 사실 이 함수형 프로그래밍 언어는 1930년대에 발표된 람다 대수라는 추상화된 수학적 개념을 기반으로 만들어졌다. 위의 LISP에서 언급한 함수적인 처리도 이 람다 대수를 기반으로 한 것이다. 따라서 명령형 프로그래밍과 함께 프로그래밍 패러다임의 거대한 두 시조라고 할 수 있다.  

이 외에 참고로 프로그래밍을 학습하다보면 앞으로 자주 접하게 될 객체 지향 프로그래밍이라는 패러다임도 존재한다. 간혹 객체 지향 프로그래밍이 그저 절차적 프로그래밍을 구조화하여 만든 패러다임이라고 오해하는 경우가 있는데, 사실 객체 지향 프로그래밍은 위의 함수형 프로그래밍과 절차적 프로그래밍을 조합하여 만들어낸 패러다임이다. 위에서 이야기한 함수형 언어의 대표인 LISP I Programmers Manual의 88 페이지를 보면 다음과 같은 문구가 나온다

```
Each of these atomic symbols has an association list associated with it, and in fact the atomic symbol on the list of atomic symbols points to the location of the association list.

In the local MIT patois, association lists are also referred to as "property lists", and atomic symbols are sometimes called "objects".
```  

고대의 LISP를 설명하기에는 책의 범위를 넘어서므로, 대략적으로 이야기하면 이름(심볼)로 표현하는 단일 데이터를 객체(object)라고 하고, 객체는 연관되는 속성 리스트(property list)와 연관될 수 있다는 것이다. LISP는 이런 객체 리스트들에 연속적인 함수적 처리들을 통해서 원하는 결과를 산출해낸다.  

그리고 위 LISP나 포트란과 함께 현대 프로그래밍 언어에 큰 영향을 준 ALGOL이라는 언어가 있는데, 이는 주로 알고리즘의 연구 개발과 컴퓨터를 이용한 수학적 연구를 위해 만들어진 언어이다. ALGOL언어는 굉장히 다양한 버전이 존재하는데, 절차적 프로그래밍을 비롯하여 굉장히 다양한 프로그래밍 패러다임을 지원했다. MIT에서 만든 ALGOL X는 특별한 특징이 있었는데, 자료구조에 프로시저를 연관시킬 수 있었다. 이러한 프로시저를 통해 특정하게 원하는 대상 데이터에 효과적으로 상태를 변경시킬 수 있었다.  

여태까지의 내용을 정리해보자. LISP에서는 어떠한 속성이 있는 객체들에 함수를 적용하여 원하는 결과를 도출해낸다고 하였다. ALGOL에서는 어떠한 데이터에 연관된 프로시저를 통해 상태 변화를 만들어낸다고 하였다. 이 두 가지 내용을 조합하면 재미난 생각을 해볼 수 있다. 어떠한 속성을 지닌 객체들이 메시지를 통해서 상호 작용하며 그 상태를 변경해나가는 것으로 소프트웨어의 가상 세계를 디자인하면 어떨까? 예를 들어 현실 세계에서 구매자라는 객체와 판매자가 있고, 이들은 소지 금액과 물품 보유 수라는 속성을 갖는다고 해보자. 그러면 구매자가 판매자에게 '돈을 지불한다' 라는 메시지를 보내면, 구매자의 소지 금액은 줄어들고 판매자의 소지 금액은 늘어날 것이다. 이제 그에 응답하여 판매자는 구매자에게 '물품을 건넨다' 라는 메시지를 보내면, 판매자의 물품 보유 수는 줄어들고 구매자의 물품 보유 수는 늘어날 것이다. 이런 방식으로 객체들이 메시지를 주고 받는 것으로 프로그램을 설계하는 것이 바로 객체 지향의 근간이다.  

이러한 개념들을 더욱 정제해서 Simula라는 기념비적인 언어가 탄생했다. 객체의 속성과 메시지의 동작 방식을 정의할 수 있는 클래스(class)라는 개념을 도입하였으며, 클래스를 통해 객체를 생성할 수 있게 하였다. 메시지의 동작 방식은 객체에 연관된 프로시저를 통해 정의했으며, 이를 메소드(method) 혹은 멤버 함수(member function)이라고 한다. 이 외에도 강아지와 고양이는 모두 포유류의 일종인데, 암컷 포유류는 젖샘이라는 속성을 가지고 새끼에게 수유하다 라는 메시지를 전달할 수 있다. 강아지와 고양이는 둘 다 포유류이므로 이러한 포유류의 속성을 그대로 가지고 있는데, 이렇게 하위 분류에 소속한 객체는 상위 분류에 소속한 객체의 속성을 그대로 물려받을 수 있다는 것을 상속(inheritance)이라는 개념으로 도입하였다. 이 외에도 동적 바인딩(dynamic binding)과 같은 개념도 추가하여 Simula는 객체 지향 프로그래밍 패러다임의 뼈대를 완성했으며, 추후 이를 더욱 일반화한 Smalltalk라는 언어 등이 등장하였다. 특히 C++ 언어는 C언어에 Simula와 Smalltalk의 객체 지향 개념을 도입하여 만든 언어이다.  

참고로 C언어에서 이야기 하는 객체(object)와 다른 객체 지향 언어들에서 이야기하는 객체의 의미가 조금 다른 이유가 바로 이것이다. 객체 지향 언어에서는 위와 같이 클래스를 통해 만들어낸 속성과 메소드를 지닌 아이템을 주로 객체라고 칭한다. 반면 C언어에서는 값을 나타낼 수 있는 데이터 저장 영역을 모두 객체라고 한다.  

여태까지 다양한 프로그래밍 패러다임들을 소개했는데, 사실 현대 상업적으로 사용하고 있는 대부분의 언어는 어느 하나의 패러다임만 지원하는 것이 아니라 다양한 패러다임을 복합적으로 지원한다. 심지어 굳이 언어적인 차원에서 어떠한 프로그래밍 패러다임을 지원하지 않다고 하더라도, 해당 언어가 가진 문법적인 요소들을 잘 조합하여 다른 프로그래밍 패러다임을 흉내내기도 한다. 예를 들어 C언어는 언어 차원에서 객체 지향 패러다임 요소들을 지원하지는 않지만, 추후에 학습할 구조체와 함수 포인터들을 이용하여 객체 지향 프로그래밍을 흉내내기도 한다. (실제로 리눅스 커널과 디바이스 드라이버의 많은 부분들이 이런 식으로 동작하기도 한다.) 따라서, 어떠한 프로그래밍 언어가 특정한 프로그래밍 패러다임 언어다 라고 이야기 하는게 맞을 수도 맞지 않을 수도 있다.  

C언어에서 함수의 중요성을 이야기하기 위하여 절차적 프로그래밍을 소개하다보니 다양한 프로그래밍 패러다임에 대해 소개하게 되었다. 비록 프로그래밍 패러다임에 대한 이야기가 이번 장에서 설명할 함수와 직접적인 연관이 없을 수도 있지만, 프로그래밍 언어에 대한 이해도를 좀 더 높여주고 C언어에서 함수가 얼마나 중요한지 인지시켜주는 계기가 되었으면 한다. 그러면 본격적으로 C언어의 함수에 대해 학습해보도록 하자.  

## 함수 체험하기

본격적인 함수의 개념과 문법 요소들에 대해 학습하기 전에 예제들을 통해 간단하게 함수를 만들고 사용해보면서 함수가 필요한 이유에 대해 알아보자.  
기존에 1부터 N까지 자연수의 합을 구하는 예제의 경우 main 함수에서 모든 것을 처리하였다. 함수를 응용하여 해당 내용을 수정하면 다음과 같다. (예제가 정확히 이해가지 않아도 괜찮다.)  

```c
int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;    // main 함수의 sum과는 별개의 변수
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);      // 함수의 인자로 n을 전달하여 함수를 호출하고 결과 값을 저장
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}
```  

동작은 이 전 예제들과 크게 달라지지 않은 것 같은데, 어쩐지 소스 코드는 괜히 더 복잡해진듯 보인다. 그래도 합을 구하는 단계와 입력 및 출력 단계를 나눠서 프로그램의 전체적인 흐름을 나눠볼 수 있는 것은 장점으로 보인다.  
그렇다면 함수의 장점은 이게 전부일까? 예제 상황을 아주 조금 더 복잡하게 만들어보자. 이번에는 1부터 N까지의 자연수의 합과 1부터 M까지의 자연수의 합을 구해서 두 수의 합을 구한다고 가정해보자. 함수를 사용하지 않으면 다음과 같을 것이다.  

```c
int main(void)
{
    int n, m, sum, sum1 = 0, sum2 = 0;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {  // 1부터 n까지의 합
        sum1 += i;
    }
    for (int i = 1; i <= m; i++) {  // 1부터 m까지의 합
        sum2 += i;
    }
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

1부터 N까지의 합을 구하는 코드와 1부터 M까지의 합을 구하는 코드가 굉장히 유사하다. 제어 식의 비교에 사용된 변수와 누산을 위한 변수만 다를 뿐, 그 외에는 모두 동일하다.  
이 전 챕터에서 똑같은 코드를 여러 번 반복해서 나열하는 것이 싫어서 반복문을 학습했다. 그러면 위의 코드도 반복문으로 바꾸면 될까? 이중 반복문을 사용해서 중복 코드를 줄일 수도 있기야 하겠지만, 이러한 상황에서는 함수를 사용하면 다음과 같이 훨씬 깔끔하게 코드를 정리할 수 있다.  

```c
// accumulation_sum.c
#include <stdio.h>

int accumulation(int n)     // 1부터 N까지의 합을 계산하는 함수를 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;     // 누산한 값을 반환
}

int main(void)
{
    int n, m, sum, sum1, sum2;
    printf("자연수 N, M을 입력하세요 : ");
    scanf("%d %d", &n, &m);
    sum1 = accumulation(n);     // 함수를 호출하고 결과 값을 저장
    sum2 = accumulation(m);     // 함수를 호출하고 결과 값을 저장
    sum = sum1 + sum2;
    printf("합의 합 : %d\n", sum);
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make accumulation_sum
cc     accumulation_sum.c   -o accumulation_sum
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./accumulation_sum 
자연수 N, M을 입력하세요 : 5 7 
합의 합 : 43
```  

한 번 정의한 함수를 여러 번 호출하여 반복되는 코드를 단숨에 줄일 수 있었다. 함수는 이렇게 한 번 잘 정의하면 원하는 곳에서 여러 번 사용할 수 있기 때문에 재사용성(reusability)할 수 있다고 한다.  
재사용성은 프로그래밍에 있어 절대적인 강점이며 수많은 프로그래밍 스킬과 아키텍처들은 그 뿌리에 재사용성을 염두에 두고 있을 정도로 중요하다.  
그리고 사실 처음에 언급했던 프로그램을 단계별로 명확하게 나눠서 각 단계를 함수로 만들면 각각의 단계를 이해하기 쉬워진다는 장점도 작은 부분이 아니다.  
뿐만 아니라, 억지스럽지만 회사에서 우리 팀에 1부터 N까지 자연수의 합을 구하는 프로그램을 만들어달라는 업무가 할당됐다고 가정해보자.  
이 업무를 본인과 동료 한 명을 더해 두 명이서 수행한다고 했을 때, 두 명이서 처음부터 끝까지 프로그래밍을 같이 진행할 수도 있다. 하지만 단계를 나눠서 합을 구하는 단계를 본인이, 입력과 출력을 수행하는 단계를 동료가 맡고 각자 맡은 함수만 잘 구현하여 조립하면 이론상 두 배 빠르게 일을 끝낼 수도 있다.  

또 한가지 중요한 사실은, 여기까지 학습한 독자분들은 이미 함수를 여러 번 사용하였으므로 그 강력한 장점을 은연중에 느끼고 있어야 한다. 그렇다, printf 함수와 scanf 함수도 우리가 정의하지 않았지만 함수인 것이다.  
여태까지 별 신경 쓰지 않고 입출력 함수를 사용해왔지만, 사실 터미널에 무엇인가를 입력하고 출력한다는 행위 자체가 굉장히 고난이도의 작업이다. 심지어 이 내용은 너무 어려워서 해당 책의 범위를 벗어나므로 자세히 다루지도 않을 것이다.  
그런데도 우리는 별 어려움 없이 터미널에 입출력을 해왔다. 이것이 바로 함수의 마법이다. 비록 어떤 함수의 내부가 어떻게 만들어졌는지 알지 못하더라도, 그 함수의 사용법만 알면 해당 함수가 제공하는 기능을 그대로 이용할 수 있다.  

함수에는 이렇게 많은 장점이 있기 때문에 이번 챕터의 서두에서 이야기한 것과 같이 컴퓨터 연구가들은 서브 루틴 명령어를 지원하도록 매달렸던 것이다. 이만 함수의 필요성과 대략적인 형태를 확인하였으니 본격적인 요소들에 대해 학습해보자.  

## 함수 정의하기

함수를 정의하기 위한 문법적인 형태는 다음과 같다.  

```c
attribute-specifier-sequence(opt) declaration-specifiers declarator function-body
```  

당연하지만 위의 내용만 보고는 무슨 말인지 알 수 없다. 여기서 function-body는 compound statement이고, declarator는 무엇이고, declaration-specifiers는 무엇이고, ... 와 같이 설명을 할 수도 있겠지만 혼란만 초래할 것이다. 위 형태를 알아보기 쉽게 일반화하면 다음과 같이 표현할 수 있다.  

```c
return-type function-name(parameter-type-list)
compound-statement
```  

훨씬 나아졌지만 아직도 조금 복잡해 보인다. 한국어를 사용하고 조금 더 쉽게 표현하면 다음과 같다.  

```c
반환타입 함수이름(파라미터리스트)
{
    선언들과 문장들
}
```  

이제 어디서 많이 본 것 같다. 반환 타입이 ```int```, 함수 이름이 ```main```, 파라미터 리스트가 ```void```, 문장이 ```return 0;``` 이면 어떻게 될까?  

```c
int main(void)
{
    return 0;
}
```  

너무나도 익숙한 main 함수가 탄생했다.  
함수는 이렇게 '반환 타입', '함수 이름', '파라미터 리스트', '함수 몸체'로 구성된다.  
각 요소를 설명하기 전에 함수가 어떠한 과정으로 실행되는지 알아보자.  
우선, 함수의 호출자가 함수에 인자(argument)를 전달하여 호출한다. 예를 들어 main 함수에서 위 예제의 accumulation 함수를 호출하는 것과 같다.  
그러면 피호출자 함수는 인자 값을 파라미터(parameter)로 전달 받고, 함수의 몸체를 실행한다. 몸체를 실행하다가 return 문을 만나면 함수를 종료하며, return 문에 지정한 값을 호출자에게 반환한다. 마찬가지로 위 예제 accumulation 함수의 ```return sum;``` 문장에서 변수 sum에 있는 값을 호출자에게 반환하여, ```sum = accumulation(n);``` 문장에서 해당 반환 값을 변수 sum에 저장한 것이다. (main 함수의 sum 변수와 accumulation 함수의 sum 변수는 별도의 변수이다.)  

함수의 동작 방식은 위와 같으며, 함수의 각 요소의 역할은 다음과 같다.  
* 반환 타입 : 함수가 반환할 값의 타입을 지정한다. return 문에서 반환한 값이 해당 타입으로 호출자에게 전달된다.  
* 함수 이름 : 프로그램 내에서 함수를 유일하게 구별할 식별자이다.  
* 파라미터 리스트 : 함수가 전달받을 인자 값들을 담기 위한 변수 리스트이다.  
* 함수 몸체 : 함수가 수행할 명령문들의 모음이다. 함수의 몸체는 복합문으로 정의한다.  

함수의 인자를 뜻하는 원어는 argument와 parameter 두 가지가 있다. 일반적으로 함수를 호출하는 곳에서 전달하는 인자를 argument라고 하고, 함수를 정의하는 곳에서 전달받는 인자를 parameter라고 한다. 이 두 용어는 엄격하게 구분되는 것은 아니라서 혼용하기도 하지만, 이해의 편의를 위해 해당 서적에서는 이 둘을 구분하여 사용할 것이다. 한국어로 번역하면 두 용어 모두 인자가 되기 때문에, argument는 인자로 parameter는 파라미터로 표현할 것이므로 이 후 학습에 참고하길 바란다. (간혹가다가 두 용어를 모두 포함하는 의미로 인자라는 용어를 사용하기도 할 것이다.)  

함수는 한 가지 예외를 제외하고 항상 return 문으로 종료해야 한다. 한 가지 예외는 반환 타입이 ```void``` 타입인 경우인데, 이는 함수가 반환하는 값이 없다는 의미이다. 이 경우엔 함수 몸체의 끝에 도달하면 함수가 종료된다. return 문을 사용해서 함수를 종료할 수도 있지만, return 문에 반환할 값을 지정할 수는 없다.  

이와 유사하게 함수의 인자가 존재하지 않을 수도 있는데, 이 경우 파라미터 리스트를 비우거나 ```void```를 지정해줘야 한다. 그리고 호출부의 인자 리스트에는 아무 것도 지정하지 않으면 된다.  

다음 예제는 반환 타입과 파라미터 리스트가 모두 void인 함수를 정의하고 호출한다.  

```c
// void_function.c
#include <stdio.h>

void func(void)
{
    printf("func\n");
}

int main(void)
{
    printf("main\n");
    func();
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make void_function
cc     void_function.c   -o void_function
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./void_function 
main
func
```  

언어에 따라 위와 같이 반환 타입과 인자가 없는 함수를 프로시저라고 구분하기도 하지만, C언어에서는 구분 없이 모두 함수라고 부른다.  

## 함수 선언하기

여태까지 예제들을 보면 항상 호출하는 함수가 main 함수보다 상단에 위치했다. 두 함수의 순서를 바꿀 수는 없을까? 예를 들어 예제를 다음과 같이 작성할 수 없을까?  

```c
#include <stdio.h>

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}

int accumulation(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

컴파일해보면 현재 사용하고 있는 환경에서는 다음과 같은 경고가 뜰 것이다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make test
cc     test.c   -o test
test.c: In function ‘main’:
test.c:8:11: warning: implicit declaration of function ‘accumulation’ [-Wimplicit-function-declaration]
    8 |     sum = accumulation(n);
      |           ^~~~~~~~~~~~
```  

어쨋든 실행 파일 만들어졌고 실행 되니까 잘 되는거 아닐까? 절대 아니다. 이는 프로그래머의 바보같은 실수를 해당 컴파일러가 넓은 아량으로 한 번 봐주었을 뿐 정상적인 상황이 아니다. 경우에 따라서 경고는 에러와 다를 바 없으며, 실제로 다른 컴파일러 및 환경을 사용하면 컴파일 에러 처리가 되기도 한다.  
이는 변수를 사용하기 전에 선언해야 하는 것과 유사하다. 즉, 호출되는 함수가 항상 호출하는 함수보다 상단에 위치해야 한다는 것인데, 예제와 같이 작은 규모의 프로그램이면 모를까 수천 수만 개의 함수들이 얽히고 설켜서 상호간의 호출을 반복하는데 이러한 순서를 보장할 수 있을까? 불가능하다.  

이러한 상황을 해결할 수 있도록 함수의 선언(declaration)과 정의(definition)를 분리할 수 있다. 소스 코드의 상단부에 사용하려는 함수들의 형태를 미리 선언해두고, 하단부에서 호출 순서에 상관 없이 원하는 위치에 함수를 정의할 수 있다. 위 예제의 경우 다음과 같이 accumulation 함수의 선언과 정의를 분리할 수 있다.  

```c
// function_declaration.c
#include <stdio.h>

int accumulation(int n);        // 함수 선언

int main(void)
{
    int n, sum;
    printf("자연수 N을 입력하세요 : ");
    scanf("%d", &n);
    sum = accumulation(n);
    printf("1부터 N까지의 합 : %d\n", sum);
    return 0;
}

int accumulation(int n)         // 함수 정의
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

컴파일 및 실행해보면 아무런 경고 혹은 에러 없이 정상적으로 동작하는 것을 확인할 수 있다.  
결국 함수를 호출하기 전에 선언이나 정의 둘 중 아무거나 존재하기만 하면 된다. 그리고 함수 선언의 문법적인 형태는 예제를 보면 알겠지만 다음과 같다.  

```c
반환타입 함수이름(파라미터리스트);
```  

사실 위의 내용 또한 간략화한 것이며, 명확한 형태는 direct-declarator라는 요소를 알아야 한다. 하지만 이 또한 지금 전부 학습하기엔 무리가 있으므로 우선 위와 같은 형태로 알아둬도 충분하다.  

### 함수 프로토타입

초기 C언어의 선언 및 정의의 형태는 현재와 조금 다른 모양새를 가졌다. 굳이 알 필요는 없지만, 대략 다음과 같다.  

```c
int accumulation();     // 구형 함수 선언

int main(void)
{
    sum = accumulation(5);
    return 0;
}

int accumulation(n)     // 구형 함수 정의
    int n;
{
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```  

이를 K&R 스타일의 함수 선언과 정의라고 하는데, 사용에 대한 지양을 권고하다가 C23 표준에 와서 결국 없어진 형태의 문법이다.  
이런 K&R 스타일의 함수 선언과 현재의 함수 선언 방식을 구분하기 위하여, 현재의 함수 선언 방식을 함수 프로토타입(function prototype)이라고 부르기도 한다. 프로토타입의 사전적인 의미는 실 제품 출시 전 제품의 원형이라는 뜻으로, 함수를 정의하기 전에 미리 그 형태를 구성하여 알려준다는 뜻이다.  

구형 K&R 스타일의 함수 선언 및 정의를 사용할 때와, 현재의 함수 프로토타입 및 정의를 사용할 때와 함수 인자 타입 평가 방식이 조금씩 달라진다. 따라서 K&R 형태와 현재의 형태를 혼용은 절대로 하면 안 된다. 예를 들어 프로토타입 방식으로 선언하고, K&R 방식으로 함수를 정의한다던지 하는 일은 절대로 하면 안 된다. 물론, K&R 스타일은 표준에서 쫓겨난 구형 방식이므로 애초에 사용을 지양해야 한다. (서적에서도 이런게 있다는 것을 소개하기 위하여 다뤘을 뿐, 굳이 학습할 필요조차 없다.)  

함수의 프로토타입에 대해서 조금 더 생각해보자. 프로토타입은 함수를 호출하기 전에 해당 함수가 어떤 형태를 가지고 있는지 알려주기 위해 존재한다. 즉, 호출 시점에 함수가 어떤 형태로 구성되어 있는지에 대한 정보를 제공해주기만 하면 된다.  
함수를 호출하는 시점에 알아야 하는 정보는 함수의 반환 타입, 함수의 이름, 파라미터의 개수 및 타입 정보이다. 이것들만 알면 함수를 호출할 때 필요한 정보는 모두 알고있는 것이다.  

```c
ret = func('a', 10, 3.14);
```  

그렇다면 호출시점에 몰라도 되는 정보는 무엇일까? 파라미터의 이름 즉, 파라미터 변수명은 몰라도 호출하는데 아무런 지장이 없다. 파라미터 변수 이름은 함수를 정의할 때 함수의 몸체에서 사용하기 위한 것이지 호출할 때는 몰라도 된다. 따라서, 함수의 프로토타입에서는 다음과 같이 파라미터 이름을 생략할 수 있다.  

```c
int accumulation(int);      // 파라미터 이름 생략, 개수와 타입만 알면 됨
void func(char, int, double);   // 파라미터 이름 생략, 개수와 타입만 알면 됨
```  

하지만 프로토타입에서 파라미터의 이름을 생략할 수 있다고 하더라도, 해당 소스 코드를 보는 동료 프로그래머가 함수의 프로토타입만 보고도 각 파라미터가 어떠한 역할을 하는지 파악할 수 있도록 이름을 명시해주는 것이 좋다.  

마지막으로 명심할 내용으로, 함수 프로토타입의 형태와 함수 정의의 형태가 동일해야 한다. 예를 들어, 함수 프로토타입은 ```int func(char, double)``` 이었는데 정의를 ```double func(int, short) {}``` 와 같이 반환 타입 혹은 파라미터 리스트 정보가 다르면 안 된다는 것이다. 심지어 ```unsigned int```와 ```int```간의 혼용조차도 허용되지 않으므로 주의가 필요하다.  

## 변수의 범위

이 전 예제에서 main 함수의 변수 sum과 accumulation 함수의 변수 sum은 다른 변수라고 언급하였다. 애초에 변수의 이름은 식별자(identifier)이고, 식별자는 특정한 범위 내에서 어떠한 개체를 유일하게 식별하기 위한 요소이므로 저 두 변수가 다른 개체가 아니라면 유일한 식별이라는 정의에 부합하지 못한다.  
그렇다면 서로 다른 함수라면 같은 이름의 변수 이름을 사용할 수 있는 것일까? 그렇다. 서로 다른 함수라면 변수명이 같더라도 둘이 별개의 변수로 취급하기 때문에 같은 이름을 사용할 수 있다.  
변수는 유효 범위라는 것이 정해져있기 때문에 이러한 방식으로 동작할 수 있다. 사실 변수의 유효 범위를 정확하게 이해하려면 변수의 스토리지 기간(storage duration), 식별 유효 범위(scope), 식별 링크(linkage) 라는 세 속성에 대해 자세히 알아야 한다. 이는 책의 후반부에서 살펴볼 것이므로 지금은 좀 더 일반적이고 간단한 개념인 지역 변수와 전역 변수에 대해 알아보자. 아래의 내용들은 아직 위의 속성들을 담지 못하여 엄밀한 내용은 아니지만 이 후 학습의 편의를 도와줄 것이다.  

> 지역 변수와 전역 변수는 표준에서 정의하고 있는 개념은 아니지만, ALGOL 이 후 대부분 언어들에 통용하는 개념으로 TCPL에서도 해당 용어를 사용한다.

지역 변수는 함수나 블록 내에 선언되어 해당 범위를 갖는 변수를 말한다. 즉, 함수 몸체를 포함하여 복합문의 내에서 선언한 변수는 해당 복합문 내에서만 유효한 지역 변수이며, 해당 지역을 벗어나면 사용할 수 없도록 파괴된다. 예를 들어 다음과 같은 변수들은 모두 지역 변수이다.  

```c
void func(void)
{
    int a = 3;      // 함수의 지역 변수 a
    
    if (a == 3) {
        int b = 1;      // 복합문의 지역 변수 b
        ...
    }   // 복합문 종료 시 지역 변수 b는 사라짐

    for (int i = 0; i < 10; i++) {  // for문의 지역 변수 i
        ...
    }   // for문 종료 시 지역 변수 i는 사라짐
    ...
    return 0;
}   // 함수 종료 시 지역 변수 a는 사라짐
```  

반면 전역 변수는 어떤 블록 내에도 속하지 않는 변수를 말한다. 함수 밖에 문장(statement)은 존재할 수 없었지만, 선언은 존재할 수 있다. 다시 말해 함수 밖에 변수를 선언할 수 있다. 이러한 변수를 전역 변수라고 하며 프로그램이 종료할 때까지 존재하면서 어디에서나 접근할 수 있다.  
예를 들어 다음과 같이 전역 변수를 선언하고 함수 내에서 사용할 수 있다.  

```c
int global = 10;        // 전역 변수

void func(void)
{
    printf("global : %d\n", global);    // 20 출력
}

int main(void)
{
    printf("global : %d\n", global);    // 10 출력
    global += 10;       // 10 증가
    func();         // func 함수 호출
}
```  

전역 변수는 프로그램이 실행될 때 생성되어, 프로그램이 종료할 때 사라진다. 전역 변수에 초기 값을 지정해주지 않으면 0으로 초기화되는데, 그렇다고 해서 초기 값을 지정해주지 않는 것은 좋지 않다. (0으로 초기화 하더라도 명시적인 초기값을 지정해주는 것이 좋다. 이는 지역 변수도 마찬가지이다.)  

그렇다면 지역 변수와 전역 변수의 이름이 같은 경우엔 어떻게 될까? 이 경우엔 유효 범위가 중첩 되어 지역 변수가 전역 변수를 가리게 된다. 이와 마찬가지로, 지역 변수 또한 서로 다른 유효 범위를 가지는 경우 같은 변수 명을 가질 수 있는데, 이 때 안쪽 유효 범위를 가진 변수가 바깥쪽 유효 범위를 가진 변수를 가리게 된다. 다음 예제를 보면서 해당 내용을 확인해보자.  

```c
// local_global.c
#include <stdio.h>

int var = 3;        // 전역변수 var 초기값 3

void func(void)
{
    printf("[3] 전역변수 var : %d\n", var);  // 전역변수 출력 (기존에 1 증가되었음)
    int var = 10;       // 지역변수 var 초기값 10
    printf("[4] 지역변수 var : %d\n", var);  // 지역변수 출력

    {
        printf("[5] 바깥 지역변수 var : %d\n", var);
        int var = 100;  // 지역변수 var 초기값 100 (바깥 지역변수 가림)
        printf("[6] 안쪽 지역변수 var : %d\n", var);  // 안쪽 지역변수 출력
    }

    printf("[7] 바깥 지역변수 var : %d\n", var);  // 바깥 지역변수 출력
}

int main(void)
{
    printf("[1] 전역변수 var : %d\n", var);  // 전역변수 출력
    var += 1;       // 전역변수 1 증가

    int var = 5;    // 지역변수 var 초기값 5
    printf("[2] 지역변수 var : %d\n", var);  // 지역변수 출력

    func();
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make local_global
cc     local_global.c   -o local_global
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./local_global 
[1] 전역변수 var : 3
[2] 지역변수 var : 5
[3] 전역변수 var : 4
[4] 지역변수 var : 10
[5] 바깥 지역변수 var : 10
[6] 안쪽 지역변수 var : 100
[7] 바깥 지역변수 var : 10
```  

함수 func에서 복합문 주변의 동작 결과를 자세히 살펴보자. 복합문 내부 범위의 var이 선언되기 전에는 바깥의 var을 사용하여서 5번 출력 결과는 10이었다. 이 후 내부 범위의 var이 선언되어 바깥의 var를 가려서 6번 출력 결과는 100이 되었다. 마지막으로 복합문을 빠져나가며 내부 var이 사라지고 다시 바깥의 지역 변수 var를 출력하여 7번 출력 결과는 10이 되었다.  

마지막으로 함수의 파라미터는 무엇일까? 함수의 정의에서 사용하는 파라미터는 함수를 호출하는 곳에서 전달한 인자 값으로 초기화한(복사한) 지역 변수로 취급된다. 이와 관련되어 더욱 자세한 내용들은 책의 후반부에서 학습할 예정이다.  

## 함수의 인자

C언어에서 모든 함수의 인자는 값이 복사되어 전달된다. 예를 들어 다음과 같은 예제 코드가 있을 때,  
```c
void func(int n) {
    ...
}

int main(void) {
    int a = 3;
    func(a);
    ...
}
```  
파라미터 n은 변수 a의 값을 복사하여 초기화한다. 이는 두 변수를 같은 유효 범위 내에서 ```int n = a;``` 처럼 선언한 것과 유사하다. 아래 예제의 주석을 보면 더욱 확실히 이해할 수 있을 것이다.  

```c
void func(int c) {  // c는 값을 복사하여 초기화
    c += 5;     // c를 수정하여도 a에 변화 없음
}

int main(void) {
    int a = 3;
    int b = a;  // a의 값으로 b를 초기화
    b += 5;     // b를 수정하여도 a에 변화 없음
    func(a);    // a의 값을 전달함
    return 0;
}
```  

이렇게 인자로 전달하는 값을 복사하여 함수의 인자를 평가하는 방식을 call-by-value 라고 한다. C언어에서는 모든 인자를 call-by-value 방식으로만 전달한다. 간혹 C언어에서 call-by-value 외의 호출 방식을 지원한다고 잘못 설명하는 경우가 있는데, 그러한 착각을 유발하는 원인은 포인터 챕터에서 다시 알아볼 것이다.  

### 함수 인자 형변환

여태까지 예제들은 함수를 호출할 때 전달하는 인자와 함수에서 전달받은 파라미터의 타입이 일치했다. 하지만 항상 인자와 파라미터의 타입이 완전히 일치해야 하는 것은 아니다. 두 타입이 호환만 가능하면 암시적 형변환(Implicit Type Conversion)이라는 것을 통해서 값을 적절히 전달한다.  

옛날 K&R 스타일의 함수 선언을 사용하거나, 함수를 호출하기 전에 함수의 선언(프로토타입)과 정의가 등장하지 않는 경우엔 기본 인자 승격(default argument promotion)이라는 동작을 우선 수행했다. ```float``` 타입은 ```double``` 타입으로, ```char``` 타입과 ```short``` 타입은 ```int``` 타입으로 변환하는 건데, 지금은 해당 내용을 크게 신경쓰지 않아도 괜찮다.  

현재와 같이 함수의 프로토타입을 사용하는 경우 전달받은 파라미터의 타입에 대입하는 것처럼 형변환이 발생한다. 예를 들어 ```void func(int a);``` 함수를 ```func(3.5)``` 처럼 호출하면 파라미터 a는 정수 3으로 초기화되며, ```void func(double a);``` 함수를 ```func(3)``` 처럼 호출하면 파라미터 a는 실수 3.0으로 초기화된다.  

함수의 인자가 없다는 것을 표현하기 위해 파라미터 리스트에 void를 사용하여 ```(void)```라고 표현한다고 하였다. 이 void는 꼭 넣어줘야 하는 것일까? 함수를 ```void func();```와 같이 선언하는 경우 이 전에 본 것과 같이 K&R 스타일의 함수 선언이 된다. 따라서 함수의 프로토타입에 파라미터가 없다는 것을 표기하고 싶다면 void를 적어줘야 한다. 반면 함수를 정의할 때는 ```(void)```와 ```()```가 같은 의미를 가지므로 어느 것을 사용해도 상관없다.  

여기까지의 내용 외에도 함수의 인자에 관하여 알아야 할 내용들이 아직 남아있다. 주로 배열이나 포인터와 관련된 인자 평가 내용인데, 이는 관련된 챕터들에서 학습할 예정이다.  

## 함수의 종료

반환 타입이 void가 아닌 함수는 항상 return 문으로 종료한다고 언급하였다. return 문의 문법적인 형태는 다음과 같다.  

```c
return expression(opt);
```  

위 형태에서 expression에 (opt) 표시가 되어있지만, 식의 작성 여부는 함수 반환 타입에 따라 고정으로 정해진다. 반환 타입이 void면 expression을 생략해야하고, 반환 타입이 void가 아니면 expression을 필수로 적어줘야 한다.  
이 전에 언급한 바와 같이 함수는 return 문을 만나면 실행을 종료하고 함수를 호출했던 곳으로 실행 흐름을 되돌린다. 또한 다음과 같이 하나의 함수에는 무한정 여러 개의 return 문이 올 수 있다. 이 중 처음 만난 하나의 return 문만 동작한다.  

```c
int func(int n)
{
    // 반환 타입이 void가 아닌 함수는
    // 항상 return으로 종료해야 함
    // return문은 여러 개가 올 수 있음
    if (n == 0) {
        return 0;   // n이 0일때 실행할 return문
    } else if (n == 1) {
        return 1;   // n이 1일때 실행할 return문
    } else {
        return n * n;   // 그 외 실행할 return문
    }
    // 위의 if-else문에서 이미 함수는 종료
    return -1;  // 실행되지 않을 return문
}
```  

반환 타입이 void인 함수에서 return 문을 사용하는 예시는 다음과 같다.  

```c
void func(int n, int m)
{
    if (m == 0)     // 나누는 수가 0이면 종료
        return;
    printf("%d / %d = %d\n", n, m, n / m);
}
```  

만약 반환 타입이 void가 아닌 함수에서 return문을 사용하지 않거나 return문에 식을 지정하지 않으면 어떻게 될까? 이는 미정의 행위이기 때문에 고민할 필요도 없이 절대 하면 안 된다. 마찬가지로 반환 타입이 void인 함수에서 return문에 식을 지정하는 것도 시도하면 안 되는 행위이다.  

그러면 반환 타입이 void가 아닌 함수에서 return문에 지정된 식의 타입과 반환 타입이 맞지 않는 경우에는 어떻게 될까? 이 경우에는 식의 평가 값을 반환 타입에 대입하는 것처럼 형변환이 발생한다. 예를 들어, ```int func() { return 3.5; }``` 와 같은 함수를 호출하면 식의 값인 3.5를 반환 타입 ```int```에 대입하는 것처럼 정수형 3으로 형변환하여 반환한다.  

### 프로그램의 종료

이번 챕터 초기에 이야기한 것과 같이 C언어는 대표적인 프로시저형 프로그래밍 언어로, 모든 명령문이 함수(프로시저)안에 포함되어 있다. 프로그램을 시작하며 main 함수가 시작하며 main 함수가 종료하며 프로그램이 종료된다. main 함수가 시작하기 전이나 끝난 후에 보이지 않는 준비 혹은 정리 작업이 있기는 하지만, 해당 프로그램이 담고 있는 명령문은 main 함수로 시작하여 main 함수로 종료한다. 이는 다시 말해, main 함수가 return문으로 종료하면 프로그램이 종료된다는 뜻이다.  

그렇다면 main 함수의 반환 값은 어디로 가는 것일까? 이는 프로그램을 실행시켜준 운영체제에게로 돌아가며, 필요에 따라 해당 값을 다른 프로그램에서 읽을 수도 있다. 다음 예제는 해당 사실을 확인시켜주는 예제인데, C언어의 범주를 벗어나는 내용들이 포함되어있다. 소스 코드 내용은 이해하지 못해도 괜찮으니, if 문에서 반환한 값을 else if문에서 읽어서 출력하고 있다는 것만 확인하면 충분하다.  

```c
// main_return.c
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void)
{
    pid_t pid = fork();     // 자식 프로세스를 생성함
    if (pid == 0) {     // 아래 else if 문과 별도의 프로세스
        // 자식 프로세스 영역
        printf("Child Process Return 100\n");
        return 100;     // main 함수에서 100을 return
    } else if (pid > 0) {   // 위 if 문과 별도의 프로세스
        int status = 0;
        waitpid(pid, &status, 0);   // 자식 프로세스의 return 값을 읽어옴
        printf("Parent Process Get %d\n", WEXITSTATUS(status));
    }
    return 0;
}
```  

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make main_return
cc     main_return.c   -o main_return
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./main_return 
Child Process Return 100
Parent Process Get 100
```  

이로써 main 함수도 함수이며, main함수에서 return 문을 사용하면 프로그램을 종료하며 반환 값을 어딘가에 전달한다는 사실을 확실히 알게되었다. 또한 책의 초반부에 main 함수는 다음과 같이 오로지 두 가지의 형태만 갖는다고 하였다.  

```c
// 1번 형태
int main(void) 
{
  /* ... */ 
  return 0;
}

// 2번 형태
int main(int argc, char *argv[])
{
  /* ... */
  return 0;
}
```  

왜 main 함수는 굳이 저 두 가지 형태만 가질 수 있는 것일까? 이는 운영체제가 프로그램을 정해진 방식으로 실행시키기 위하여 특별히 정해진 규칙이다. 책의 후반부에서 2번 형태로 동작하는 main 함수에 대해 학습해보면 더욱 자세히 이해할 수 있을 것이다.  
그런데 간혹가다가 main 함수를 다음과 같이 다른 방식으로 정의하는 경우를 볼 수 있다.  
```c
void main() { /* ... */ }

main() { /* ... */ }
```  
이는 K&R 스타일의 구형 main 함수 정의 방식으로 더 이상 사용하면 안 된다.  

지금까지 프로그램을 종료하기 위한 방법으로 main 함수의 종료를 학습하였다. 여기에 한 가지 방법이 더 있는데, ```exit()``` 이라는 함수를 사용해도 프로그램을 종료할 수 있다.  
main 함수에서 A 함수를 호출하고, A함수에서 B 함수를 호출하고, B함수에서 C함수를 호출했는데 C 함수를 진행하다보니 프로그램을 종료해야 하는 상황이라고 가정해보자. 여태까지 호출되었던 흐름을 전부 정리하고 돌아가서 main 함수를 종료하려면 얼마나 복잡할까? ```exit()``` 함수는 이러한 걱정을 단번에 해결해준다. ```exit()``` 함수의 프로토타입은 다음과 같다.  

```c
// stdlib.h 헤더에 포함되어 있음
noreturn void exit(int status);
```  

사용법은 굉장히 단순하다. main 함수에서 return문을 사용하는 것과 유사하게 ```exit(expression);``` 와 같이 사용하면 된다. 단지 return 문과 달리 함수를 호출하는 것이기 때문에 괄호가 필수적이라는 것이 다르다. 그리고 ```exit()``` 함수를 사용하기 위해서는 ```stdlib.h``` 헤더를 삽입해줘야 한다. 이러한 내용들만 제외하면 ```exit()``` 함수를 사용하는 것과 main 함수에서 return 문을 사용하는 것은 같은 효과를 갖는다. 즉, 위 예제를 다음과 같이 바꿔도 같은 출력을 볼 수 있다.  

```c
// main_exit.c
#include <stdio.h>
#include <stdlib.h>     // exit 함수 사용을 위해 필요
#include <sys/wait.h>
#include <unistd.h>

int main(void)
{
    pid_t pid = fork();     // 자식 프로세스를 생성함
    if (pid == 0) {     // 아래 else if 문과 별도의 프로세스
        // 자식 프로세스 영역
        printf("Child Process Exit 100\n");
        exit(100);      // main 함수에서 100으로 exit
    } else if (pid > 0) {   // 위 if 문과 별도의 프로세스
        int status = 0;
        waitpid(pid, &status, 0);   // 자식 프로세스의 return 값을 읽어옴
        printf("Parent Process Get %d\n", WEXITSTATUS(status));
    }
    return 0;
}
```  

그런데 여태까지 main 함수를 종료할 때 왜 굳이 0을 반환하는지 궁금하지 않았는가? 이는 사실 프로그램의 정상적인 종료 값을 나타내는 관용적인 값으로, 다른 값을 반환하더라도 상관 없다. 대신 반환 값은 대부분의 경우 하위 8비트만 사용된다는 것은 인지해두는 것이 좋다. 즉, 성공을 나타내는 값으로 10, 실패를 나타내는 값으로 20을 사용하는 것은 괜찮지만, 성공을 나타내는 값으로 1000, 실패를 나타내는 값으로 2000을 사용하는 것은 좋지 못하다.  
사실 표준에서는 ```exit()``` 함수의 인자로 사용할 프로그램의 정상 종료 값과 비정상 종료 값을 이미 정의해뒀다. ```stdlib.h``` 헤더 안에 매크로라는 것을 이용하여 정상 종료 값은 ```EXIT_SUCCESS```로, 비정상 종료 값은 ```EXIT_FAILURE```로 정의되어있다. 따라서, 특별한 경우가 아니면 ```exit()``` 함수는 다음과 같이 사용하면 된다.  
```c
int main()
{
    if (비정상 상황) {
        exit(EXIT_FAILURE);
    }
    ...
    exit(EXIT_SUCCESS);
}
```  

마지막으로 코딩 습관 형성을 위하여 행해왔던 거짓에 대해 고할 것이 있다. 반환 타입이 void가 아닌 함수는 항상 return 문으로 종료해야 한다고 했는데, 예외가 하나 있다. main 함수는 반환 타입과 상관 없이 return 문을 사용하지 않아도 되는 유일한 함수이다. main 함수가 return 문을 만나지 않고 끝에 도달하면, ```return 0;```으로 종료한 것과 똑같은 동작을 수행한다. 이는 심지어 표준에도 명시된 내용이다. 하지만 이에 의존하여 일부러 main 함수에 return 문을 생략하는 것은 지양하도록 해야 한다. 또한, main 함수의 반환 타입은 굳이 ```int```가 아니더라도, ```int```에 완전히 호환 가능하기만 하면 된다. 하지만 마찬가지로 반환 타입을 ```int```가 아닌 다른 타입을 사용하는 것은 지양해야 한다.  

## 좋은 함수 만들기

함수에 대한 기본적인 문법 요소들은 대부분 학습하였다. 함수 학습에 있어서 문법 요소를 익히는 것 만큼이나 중요한 것이, 어떤 함수를 어떻게 만드냐이다. 함수의 이름은 어떻게 지을 것인지, 함수의 반환 타입과 파라미터 리스트는 뭘로 정할 것인지, 함수의 기능과 범위는 어떻게 정할 것인지 등 신경써야 하는 내용들이 많다.  
사실 이러한 내용들은 책 몇 권 읽고 코딩 조금 해본다고 해결되는 문제가 아니다. 지속적인 학습과 경험이 쌓여서 내공이 되어야 비로소 상황에 알맞는 코드와 함수를 만들 수 있게 된다. 따라서 처음부터 너무 완벽한 함수만을 만들어내겠다는 부담을 가지지 않아도 된다. 우선은 여기서 제안하는 몇 가지 가이드라인을 따르도록 노력하고 경험이 쌓이면 상황에 따라 적절하게 맞춰가도록 하자.  

* 하나의 함수가 하나의 목적 또는 기능을 수행하도록 만든다.
    * 함수가 한 번에 여러 가지 작업을 수행하면 함수의 기능을 파악하기 어렵고 함수를 수정하기도 어렵게 된다. 되도록 하나의 함수에는 한 가지 기능을 수행하도록 만드는 것이 좋다.
    * 현실적으로 모든 함수가 하나의 기능만 가질 수는 없다. 어떠한 문제 상황에서 하나의 큰 기능이 작은 여러 개의 기능으로 나뉜다고 했을 때, 각각을 함수로 만들어서 단계별로 나눠서 해결하면 된다. 예를 들어, 계산기의 기능을 동작하는 함수를 만든다고 했을 때 계산기라는 큰 기능 안에는 더하기, 빼기, 곱하기, 나누기 등의 작은 기능이 있을 것이다. 그러면 큰 기능을 ```calculate``` 라는 함수로 만들고, 사칙연산을 각각 ```add```, ```subtract```, ```multiply```, ```divide``` 라는 함수로 만든 후, ```caculate``` 함수에서 나머지 네 개의 함수를 호출하도록 만드는 방식으로 설계할 수 있다.  
* 함수의 이름만으로 함수의 기능을 파악하도록 만든다.
    * 함수가 한 번에 한 가지 기능만 수행한다면, 자연스럽게 해당 함수가 수행하는 동작에 맞는 이름을 정해줄 수도 있다. 함수의 이름만으로 함수의 기능을 파악할 수 있게 만든다면, 해당 함수를 사용한 소스 코드를 파악하기도 쉽고 해당 함수를 다른 곳에서 사용하기도 쉬워진다.
    * 사실 기능을 파악할 수 있도록 이름 짓는 것은 최소한의 조건이다. 이 외에도 기억하기 쉽고, 검색하기 쉽고, 발음하기 쉽고, 문제 상황을 파악하기 쉬운 이름을 짓는 것이 좋다. 물론 이는 쉽지 않은 작업이기 때문에 프로그래머가 가장 어려워하는 일에 대한 설문조사에 이름 짓기가 항상 상위권에 있을 정도이다.
* 함수에서 발생할 수 있는 사이드 이펙트를 최소화한다.
    * 본래 프로그램의 상태를 변경하는 모든 것이 사이드 이펙트라고 하였다. 여기서 이야기하는 사이드 이펙트는 조금 더 좁은 범위로, 해당 함수 외부에서도 존재하는 객체들에 대한 사이드 이펙트를 말한다. 대표적으로 전역 변수에 대한 사이드 이펙트를 들 수 있다. ```int global = 0; void func() { global++; }``` 와 같은 함수가 있으면, func 함수를 호출할 때마다 func 함수의 외부에 있는 global 변수에 사이드 이펙트가 발생한다.
    * 해당 함수 내에서 선언한 지역 변수의 사용은 크게 문제되지 않는다.
    * 함수에서 외부에 대한 사이드 이펙트가 발생하면 해당 함수를 호출할 때마다 결과 값이 달라질 수 있으며, 이에 따라 함수의 호출자가 원하지 않은 결과를 받을 수도 있게 된다.
* 파라미터의 개수가 과도하게 많아지는 것을 지양한다.
    * 파라미터의 개수가 늘어나면 호출하는 곳에서 어떤 인자들을 전달해야 하는지 신경써야 하는 부분이 늘어나며, 이는 실수할 확률의 증가로 이어진다. 또한 파라미터의 개수가 늘어나면 가독성을 해칠 수도 있다.
    * 함수가 정말 여러 인자 정보를 필요로 하는 경우도 많다. 이럴 때 연관성이 높은 객체들은 구조체라는 것으로 묶어서 전달하는 것이 좋다. 구조체에 대한 내용은 추후에 학습할 것이다.
* 함수 기능의 성공 및 실패 여부를 알 수 있도록 한다.
    * 실세계에 있는 요구사항을 해결하기 위한 대부분의 함수는 수행 도중 다양한 이유로 실패할 수 있다. 이럴 때 함수를 호출한 곳에서 해당 함수가 실패했는지 성공했는지 확인할 수 있어야 한다. 따라서 대부분의 경우 함수의 반환 값으로 함수의 성공 혹은 실패 여부를 반환하는 것이 좋다.
* 반환 타입, 함수 이름, 파라미터 리스트는 되도록 수정되지 않도록 만든다.
    * 실제 프로그램은 요구사항의 변경, 버그 수정, 성능 개선 등 다양한 이유로 지속적인 수정이 발생한다. 소스 코드의 어느 한 지점을 수정했을 때 다른 곳들도 연쇄적으로 수정해야 한다면 좋지 못한 것이다.
    * 만약 어떤 함수의 파라미터가 ```int func(int, int)``` 였는데, 추후에 인자 정보가 하나 더 필요하게 돼서 ```int func(int, int, int)```와 같이 수정될 수도 있다. 이렇게 되면 함수의 프로토타입/정의뿐만이 아니라 해당 함수를 호출하는 모든 곳을 수정해야 한다.
    * 이와 달리 함수의 몸체 내용은 수정한다고 해서 대부분 함수의 호출부까지 수정할 필요는 없다. 예를 들어, 1부터 N까지의 합을 구하는 함수 ```int accumulation(int n)```의 프로토타입은 그대로 두고 몸체를 반복문이 아닌 수학 공식을 사용하도록 개선했다고 해보자. 함수를 정의하는 곳은 ```int accumulation(int n) { return (n + 1) * n / 2; }```와 같이 수정될 것이다. 하지만 해당 함수를 호출하는 곳은 ```sum = accumulation(n);``` 에서 변경할 필요가 없다.
    * 그럼에도 불구하고 변경이 필요한 경우엔 변경을 할 수 밖에 없다. 애초에 함수를 처음 설계할 때, 위 세 가지 정보는 더욱 신경써서 추후에 변경이 없도록 만드는 것이 좋다.
* 연관성이 큰 작업들을 묶어서 만든다.
    * 해당 가이드는 반대로, 연관성이 적은 작업들은 서로 다른 함수로 분리해서 만든다라고 말하는 것이 더욱 적합할 수도 있다.
    * 계산기를 예로 들면, 계산에 관련된 작업을 하는 함수와 입출력과 관련된 작업을 하는 함수를 분리하는 것이 좋다.

이 외에도 다양한 설계 원칙들이 있지만 모든 것들을 지켜가면서 함수를 만들 수는 없다. 애초에 이러한 원칙들이 모든 상황에 부합하지도 않는다. 그저 이러한 내용들이 있다는 것을 최대한 염두에 두고 함수를 만들다보면 좋은 함수를 만드는 방법을 자연스레 체득하는 날이 올 것이다.  

좋은 함수를 만들기 위한 원칙들이 위와 같다면, 함수를 언제 만들어야 할까? 즉, 언제까지 하나의 함수 안에 코드를 작성하다가 별도의 함수로 분리해야 할까?  
이는 위의 내용보다는 비교적 쉽게 생각할 수 있다. 두 가지만 명심하자.  
1. 비슷한 작업이 반복되면 별도의 함수로 분리한다.
    * 이번 챕터 초기에 함수를 사용하지 않고 1부터 N까지의 자연수의 합과 1부터 M까지의 자연수의 합을 구해서 두 수의 합을 구하는 예시 상황을 보인 적이 있었다. 이 때 1부터 N 까지의 합이라는 비슷한 작업을 두 번 반복했다. 이런 상황처럼 비슷한 작업을 반복하는 상황이 생긴다면 무조건 함수를 나누는 것이 좋다.
2. 별개의 기능이라면 별도의 함수로 분리한다.
    * 하나의 함수가 하나의 목적 또는 기능을 수행하도록 만든다는 원칙을 생각하면 해당 분리는 자연스럽게 생각할 수 있다. 계산기 프로그램을 만들 때 계산하는 작업과 입출력 작업을 별도의 함수로 분리하는 것과 같다.

이 정도의 원칙들만 알고 있다면 앞으로 프로그래밍 경험이 쌓이면서 언제 함수를 새로 만들지, 어떠한 함수를 만들지에 대한 노하우가 생길 것이다.  
반대로 아무리 많은 원칙을 알고 있다고 하더라도 충분한 연습과 경험이 없다면 뜬구름만 잡을 수 밖에 없다. 프로그래밍의 내공을 쌓으려면 반복 숙달밖에 없으니 힘들더라도 충분한 시간을 투자하여 연습하도록 하자.  

## 함수 호출 메커니즘

함수 호출의 동작 원리 및 과정은 사용하는 운영체제나 아키텍처에 따라 다르고, C언어의 범주를 벗어나는 내용이 있기 때문에 정확히 알지 못하더라도 함수를 사용하는데에는 큰 지장이 없다. 그래도 동작 방식을 이해하고 있는 것이 바로 다음에 학습할 재귀 함수 같은 것들을 이해하는데 도움이 되므로 범용적인 내용을 위주로 설명할 것이다. 내용이 어렵게 느껴진다면 부담을 조금 덜고 이런 내용이 있다고 파악만 해도 괜찮다.  

우선 터미널 명령이나 윈도우 탐색기와 같은 곳에서 실행 파일을 실행시키면 하드디스크와 같은 외부저장장치에 있던 프로그램이 램과 같은 메인 메모리로 로드되어 실행을 시작한다. 메모리에 로드되는 과정은 조금 더 복잡하지만 우선 프로그램에서 필요한 모든 내용들이 메인 메모리에 올라온다고 가정하자. 이렇게 프로그램이 실행되어 메모리에 로드되고 동작하는 개체를 프로세스라고 한다.  

프로세스가 실행되려면 메모리에 어떤 내용들이 올라와야 할까? 우선 실행할 명령어들은 메모리에 올라와있어야 한다. 명령어라고 해서 특별한 것이 아니고 결국 ```1011001110100100..```와 같은 이진 값인데, 이러한 값을 CPU의 명령어 해석기(Decoder)가 해석하여 사칙 명령, 비교 명령, 점프 명령 등을 수행하는 것이다. 그렇다면 저런 이진 값이 메모리에 올라가 있는 것이므로, 명령어가 존재하고 있는 메모리의 주소(위치)가 있을 것이다. CPU 안에 있는 특별한 기억 장치(Program Counter 혹은 Instruction Pointer라고 부르는 레지스터)는 이 명령어의 주소를 저장하여 다음 번에 실행할 명령어를 메모리로부터 CPU로 가지고 올 수 있도록 만든다.  
예를 들어, 명령어 하나 당 고정적으로 4바이트를 차지한다고 했을 때 현재 수행 중인 명령어의 주소가 0x1000이라고 해보자. 일반적인 경우에는 저 특별한 기억 장치에 현재 명령어 주소에 4를 더해 0x1004를 저장한다. 만약 현재 명령어가 점프 명령이라면 점프 대상이 되는 명령어의 주소를 저장하면 된다. 또한 현재 명령어가 함수 호출 명령이라면 호출 대상이 되는 함수의 첫 번째 명령어의 주소를 저장하면 될 것이다. 반대로 함수가 종료된다면 해당 함수를 호출했던 명령어의 다음 명령어의 주소를 저장하면 되는 것이다.  
명령어들은 이렇게 모여서 메모리에 올라와있다가 필요에따라 CPU로 이동하여 실행되며, 메모리에 모여있는 명령어 영역을 프로세스의 코드 영역(Code Segment) 혹은 텍스트 영역(Text Segment)이라고 한다.  

그러면 프로세스 실행을 위해 코드 영역 외에 또 무엇이 필요할까? 당연히 변수와 같은 오브젝트들이 메모리에 올라와야 한다. 그 중에서 특별히 함수에서 할당하는 지역 변수같은 것들을 할당하기 위한 메모리 영역이 있는데, 이를 스택 영역(Stack Segment)이라고 한다.  
스택 영역에는 주로 함수 호출을 위한 정보와 지역 변수들이 할당되는데, 해당 영역은 함수의 호출 및 종료에 따라 자동으로 할당 및 해제를 수행하여 크기가 늘었다 줄었다를 반복한다.  
그렇다면 함수 하나가 호출될 때마다 스택에 어떤 내용들이 할당될까? 가장 먼저 생각할 수 있는건 해당 함수에서 선언한 변수들과 파라미터 변수들이다. 그런데 이것들은 해당 함수가 파라미터가 없으며, 어떠한 지역 변수도 할당하지 않으면 당연히 할당되지 않는다. 그러면 어떤 상황에서든 함수 호출 시 고정적으로 할당되는 오브젝트도 있을까? 최소한 한 가지 할당되는 것이 있는데, 함수가 호출을 마치면 복귀할 주소인 리턴 주소(return address)는 함수가 호출될 때마다 항상 할당된다. 즉, 함수 호출이 발생하면 코드 영역에 있는 함수 호출 명령어의 다음 명령어의 주소(리턴 주소)를 스택 영역에 저장해둔 다음, 해당 함수가 반환할 때 저장해뒀던 리턴 주소를 위에서 언급했던 Program Counter 레지스터에 로드하여 함수를 호출했던 위치로 복귀하는 것이다.  
왜 이런 형태로 동작하는 것일까? 이런 형태가 아니면 함수를 호출했던 곳으로 복귀할 수가 없다. 예를 들어 다음과 같은 코드가 있다고 가정해보자.  
```c
// 문장 하나 당 명령어 하나에 대응한다고 가정
void func()
{
    // 필요한 선언과 문장들
    i += 1;     // i 값 1 증가 명령, 명령어 주소 0x2000
    j += 2;     // j 값 2 증가 명령, 명령어 주소 0x2004
}

int main(void)
{
    // 필요한 선언과 문장들
    func();     // func 함수 호출 명령, 명령어 주소 0x1000
    a += 3;     // a 값 3 증가 명령, 명령어 주소 0x1004
    func();     // func 함수 호출 명령, 명령어 주소 0x1008
    b += 5;     // b 값 5 증가 명령, 명령어 주소 0x100C
}
```  
첫 번째 문장과 세 번째 문장에서 모두 똑같은 func 함수를 호출했다. 하지만 첫 번째 func 함수 호출 이 후에는 명령어 주소 0x1004로 복귀해야 하고, 두 번째 func 함수 호출 이 후에는 명령어 주소 0x100C로 복귀해야 한다. 결국 위 예시에서 실행되는 명령어 주소의 흐름은 0x1000 -> 0x2000 -> 0x2004 -> 0x1004 -> 0x1008 -> 0x2000 -> 0x2004 -> 0x100C 인 것이다. (함수 실행 준비를 위한 명령 등 숨겨진 것들은 이해를 위해 생략하였다.)  
이렇게 똑같은 함수를 호출하더라도 복귀 지점은 매번 달라진다. 다시 말해 함수를 호출할 때마다 복귀할 주소를 어딘가에 저장해둬야 정상적으로 복귀를 할 수 있다. 결국 매 함수 호출마다 필수적으로 필요한 정보는 복귀 주소이며, 이것을 스택에 저장하는 것이다. 이렇게 스택에는 새로운 함수가 호출될 때마다 복귀 주소, 지역 변수와 파라미터를 포함한 함수 호출에 필요한 정보들을 저장하는데 이 정보 단위를 스택 프레임이라고 한다.  

그런데 여태까지 이야기한 스택이라는 용어가 무엇일까? 스택은 특별한 형태로 데이터를 저장하고 관리하는 추상적 구조이다. 말로 설명하면 어렵지만 사실 굉장히 간단하다. ```stack``` 이라는 데이터 타입이 있다고 가정하고 ```stack s;``` 라고 데이터를 선언한 상황을 생각해보자. 이 스택이라는 자료형을 대상으로는 세 가지 연산을 지원하는데 '조회', '추가', '삭제'이다. 조회는 가장 최근에 추가한 데이터를 조회할 수 있고, 추가는 데이터를 순차적으로 추가할 수 있고, 삭제는 가장 최근에 추가한 데이터를 삭제할 수 있다. 조회 연산은 ```s.top()```, 추가 연산은 ```s.push(data)```, 삭제 연산은 ```s.pop()``` 으로 할 수 있다고 가정하면 다음 그림은 ```s.push(1); s.push(2); s.push(3); s.pop();``` 을 차례대로 수행한 모습이다.  
![stack](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%95%A8%EC%88%98/stack.png?raw=true)  
스택은 이렇게 '가장 최근에 들어간게 가장 먼저 나온다' 라는 성질을 가지고 있기 때문에 LIFO(Last In First Out) 구조라고도 불린다.  

위에서 언급했던 스택 영역도 이러한 스택의 성질을 그대로 가진다. 함수가 호출/종료될 때마다 스택 프레임이 LIFO 형태로 할당 및 해제된다. 이렇게 스택 영역에 현재 실행 중인 함수(서브루틴)에 관한 정보를 스택 프레임의 단위로 저장하는 데이터의 구조를 콜 스택(call stack)이라고 한다. 콜 스택의 동의어로 실행 스택(execution stack), 런타임 스택(runtime stack) 등 다양한 명칭이 있는데 그냥 줄여서 스택이라고 부르기도 한다. 일반적으로 프로세스의 스택이라고 하면 이 콜 스택을 이야기하는 것이다.  

여러 용어들이 무더기로 등장하여 조금 혼란스러울 것이다. 정리하면 프로그램이 실행되어 메모리에 로드되면 프로세스가 되는데, 프로세스 메모리에는 여러 영역이 있으며 그 중 코드 영역과 스택 영역에 대해 학습 하였다. 코드 영역에는 명령어들이 (주로 함수 단위로) 모여있는데 CPU가 이 명령어들을 특별한 저장 장치를 통해 로드하고 해석하여 실행한다. 스택 영역에는 현재 실행중인 함수에 관한 정보를 저장하는데 이 데이터의 구조를 통틀어 콜 스택이라고 한다. 그리고 콜 스택에 한 개의 함수당 할당되는 데이터 단위를 스택 프레임이라고 하며, 스택 프레임에는 복귀 주소가 항상 포함된다. 여기까지 내용을 이해했다면 다음과 같은 예시 코드에서 함수가 호출 및 종료할 때 콜 스택의 변화를 그림으로 확인해보자.  

```c
void aa()
{
    // statement
}

void ab()
{
    // statement
}

void a()
{
    aa();
    ab();
}

void bb()
{
    // statement
}

void b()
{
    bb();
}

int main()
{
    a();
    b();
    return 0;
}
```  

main 함수에서는 a 함수와 b 함수를 차례대로 호출하며, a 함수에서는 aa 함수와 ab 함수를, b 함수에서는 bb 함수를 호출하고 있다. 콜 스택의 변화는 다음과 같다.  

![call_stack](https://github.com/pr0gr4m/Hello-C-World/blob/main/img/%ED%95%A8%EC%88%98/call_stack.png?raw=true)

위 내용들을 이해했다면 함수 호출에 대한 동작 원리는 대강 이해한 것이다. 우선은 이 정도 내용만 이해하더라도 C언어 학습에 있어서 크게 부족함은 없을 것이다. 이보다 더욱 자세히 학습하고 싶다면 더 알아보기 파트에서 어셈블리 구현과 함께 살펴보도록 하자.  

## 재귀 함수