# 연산자와 식

C언어에서 식(expression)은 가장 중요한 요소 중 하나이다. C언에서 식이란 값을 계산하기 위한 연산자와 피연산자의 나열, 오브젝트, 함수, 사이드 이펙트 발생들이 조합되는 것을 의미한다. 사실 식에 대한 개념은 굉장히 쉽게 공부할 수도 있다. 필요한 개념을 배우지 않고, 잘못된 개념으로 학습한다면이라는 가정이 붙으면 그렇다. 여섯 살 아이에게 설명할 수 없다면 그 개념을 이해하지 못한 것이라는 아인슈타인의 어록에 숨어서 무조건 쉽게 설명한다면 좀 더 대중적으로 환영받는 책이 될 수 있겠지만, 해당 서적은 처음엔 조금 어렵게 느껴지더라도 이해하고 나면 정확한 개념들을 숙지할 수 있도록 하는 것을 지향하고 있다. 따라서 해당 챕터의 내용들에 어렵다고 느껴지는 내용들이 나오더라도 좌절하지 말자. 처음엔 어렵게 느껴지겠지만 극복하기만 하면 잘못된 코드를 분간하는 능력을 갖출 수 있을 것이다. 그러기 위해 연산자와 식을 본격적으로 공부하기 전 사전 지식들을 알아보자.

* 사이드 이펙트(side effect) : 오브젝트를 수정하거나, 파일을 수정하거나, volatile 오브젝트에 접근하거나, 앞의 세 행위 중 하나 이상을 수행하는 함수를 호출하여 프로그램의 상태가 변경되는 것을 말한다. 간단하게 변수 a에 새로운 값 3을 대입하는 것도 사이드 이펙트이다. ```printf``` 함수를 호출했을 때 화면에 문자열이 출력되는 것도 터미널 상태를 수정하는 사이드 이펙트이다.  
* 평가(Evaluation) : 식의 값을 계산하거나 사이드 이펙트가 시작하는 것을 의미한다. ```3 + 4``` 라는 식을 평가하면 ```7``` 이라는 결과 값이 나온다. 변수 ```a```에 3을 대입하는 ```a = 3``` 라는 식을 평가하면 ```3``` 이라는 결과 값이 나오면서 ```a```에 3을 대입하는 사이드 이펙트가 시작된다.
* 시퀀스(Sequence) : 문맥에 따라 나열이라는 의미 혹은 순서라는 의미를 가질 수 있다. 이스케이프 시퀀스나 문자 시퀀스에서 사용하는 시퀀스는 문자들이 나열된다는 의미이다. 평가에 대한 시퀀스라고 할 때는 순서를 의미한다. A와 B라는 두 평가가 있을 때, A가 B보다 전에 시퀀스된다라고 하면 A가 B보다 늦게 실행되는게 보장된다는 뜻이다. 반면 A와 B 두 평가의 순서가 보장되지 않을때는 A와 B가 시퀀스되지 않는다(unsequenced)라고 한다. (주로 A와 B가 동시에 실행될 수 있는 경우를 의미한다.) 마지막으로 A와 B의 평가가 동시에 수행되지 않는 것은 보장되지만 둘 중 어떤 것이 먼저 평가될지는 정해지지 않는 것을 비결정적인 시퀀스(indeterminately sequenced)라고 한다. 해당 개념이 어렵다면 식이나 평가라는 단어와 함께 시퀀스가 사용되는 경우 순서 보장을 의미한다는 것만 알아두자.
* 시퀀스 포인트(Sequence point) : 이 전에 평가한 식에서 발생한 사이드 이펙트가 모두 완료되는 지점을 의미한다. A와 B 사이에 시퀀스 포인트가 있다고 하면 A와 관련된 모든 연산과 사이드 이펙트에 대한 완료가 B에 관련된 연산과 사이드 이펙트보다 먼저 시퀀스된다는 것을 의미한다. C언어에 있는 시퀀스 포인트들을 여기서 설명해도 제대로 이해할 수 없으므로, 우선 문장을 종료하기 위한 ```;```가 시퀀스 포인트 역할을 한다고 생각하고 엄밀한 내용은 필요할 때 부록을 찾아보도록 하자.

사전적인 의미는 언제나 어렵다. 조금 쉽게 설명하면 변수에 저장되어 있는 값이 변경되는 것과 같이 프로그램의 상태가 변경되는 것을 사이드 이펙트라고 한다. 그리고 식을 평가하면 식에 포함되어 있는 연산을 수행하여 결과 값이 나온다. 이 때 연산 과정에서 사이드 이펙트가 존재한다면 평가 시 사이드 이펙트가 시작된다. 그리고 이 사이드 이펙트는 시퀀스 포인트 전 어디에서나 수행될 수 있으며, 시퀀스 포인트 다음으로 넘어가기 전에 완료가 보장되는 것이다.

위의 내용을 대략적으로 이해했다면 연산자와 식을 학습하기 위한 기본적인 사전 지식 준비는 완료되었다. 그런데 이 전 챕터에서 미정의 행위라던지 implemention-defined 라던지 하는 용어들이 자꾸 등장했던 것을 기억할 것이다. 앞으로도 해당 용어들이 자주 등장할 예정이므로, 이와 관련된 용어들도 살펴보도록 하자.

* 미정의 행위(undefined behavior) : 프로그램의 이식성을 해치거나 에러를 발생시키는 등 표준에서 정의되지 않은 행위를 하는 것이다. 미정의 행위를 실행하면 예측할 수 없는 결과를 초래하거나 컴파일 및 실행 중 종료 등의 결과를 초래할 수 있다.
* 미지정 행위(unspecified behavior) : 정의되지 않는 값을 사용하거나 정의되지 않은 행동을 하는 등 표준에서 두 개 이상의 결과를 초래할 수 있는 행위에 대해 결정하지 않은 행동을 하는 것이다.  
* implementation-defined behavior : 환경에 따라 특정 구현이 정의되어 있는 미지정 행위이다.  

쉽게 이야기해서 미정의 행위는 해당 코드의 결과가 어떻게 될 지 아예 정해지지 않은 행위이고, 미지정 행위는 해당 코드의 결과로 여러 결과 중 하나가 나올 수 있는 행위이며, implementation-defined behavior는 미지정 행위의 여러 결과 중 어떤 결과가 나올 것인지 실행 환경에 따라 결정이 되어 있는 행위를 의미한다.  
C23에서 정의한 200개 이상의 미정의 행위와 약 50개의 미지정 행위가 있다. 미정의 행위와 미지정 행위에 의존한 코드를 작성하는 것은 절대적으로 지양해야 한다.  
그렇다면 C언어 프로그램을 작성하기 위해서는 약 250개의 항목들을 전부 암기하고 있어야 할까? 물론 그렇지는 않다. 위 항목들을 살펴보다 보면 상식적인 프로그래머라면 생각이나 시도조차 하지 않을 항목들도 포함하고 있다. 하지만 중간중간 시도해봄직한 코드지만 미정의 행위의 항목에 포함되어 있는 경우도 있다. 그리고 이러한 코드가 인터넷 상에서 어째서 코드의 결과가 이렇게 되었는지 토론의 대상이 되고는 한다. 하지만 사실 이러한 토론들은 전부 의미가 없다. 미정의 행위의 결과는 정해져 있지 않고 언제든지 바뀔 수 있으며 심지어 미정의 행위로 인해서 컴퓨터가 폭발하더라도 이는 프로그래머의 잘못이기 때문이다.  
해당 서적에서는 이렇게 혼란을 줄 수 있는 미정의 행위나 미지정 행위들을 기피할 수 있도록 안내할 것이며, 거기에 더해 카네기 멜론 대학에서 발표한 미정의 행위와 미지정 행위를 피하는 안전한 프로그램 작성 가이드를 부록에서 소개할 것이다.  
참고로, 한 오브젝트에 대해 시퀀스 포인트 이 전에 서로 다른 사이드 이펙트가 발생하는 것과, 사이드 이펙트가 발생한 오브젝트를 같은 식의 다른 하위 식에서 사용하는 것은 대표적인 미정의 행위다. 예를 들어 ```i = ++i + 1```과 같은 식을 들 수 있는데, 해당 식의 결과 변수 ```i```에 어떤 값이 저장되는 지에 대한 토론이 종종 발생하지만 이는 미정의 행위이기 때문에 의미 없는 토론이다.

## 연산자와 구두점

C언어에서 같은 기호가 여러 역할을 수행한다는 것을 인지하지 못할 때 혼란을 겪고는 한다. 예를 들어 ```-``` 기호가 두 개의 피연산자를 가질 때 뺄셈 연산자가 되지만, 하나의 피연산자를 가지면 음수 기호 지정을 위한 단항 연산자가 된다. 좀 더 쉽게 표현하면 ```4 - 2```는 4 빼기 2를 의미하고, ```-3```은 마이너스 3을 의미한다. 이처럼 같은 기호가 상황에 따라 다른 의미와 역할을 가질 수 있다. 이러한 내용을 이해하기 위해서 우선 구두점이 무엇인지 알아야 한다.  

구두점(Punctuator)은 소스 코드에서 문법적(syntax), 의미적(semantic)으로 독립적인 기호를 뜻한다. 정의는 어렵지만 구두점의 종류를 보면 쉽게 이해할 수 있다. C언어에 있는 구두점은 다음과 같다.

```c
[ ] ( ) { } . ->
++ -- & * + - ~ !
/ % << >> < > <= >= == != ^ | && ||
? : :: ; ...
= *= /= %= += -= <<= >>= &= ^= |=
, # ##
<: :> <% %> %: %:%:
```

그리고 이 구두점은 문맥에 따라 연산자가 될 수도 있고, 단순히 문법적인 요소를 구분하기 위하여 사용할 수도 있다. 예를 들어 다음 예제에서 ```=``` 와 ```,``` 는 서로 다른 역할을 한다.

```c
int a = 3, b = 5;   // =와 ,가 문법 구분을 위한 구두점으로 쓰임

a = 5, b = 3;       // = 와 , 가 각각 대입 연산자와 컴마 연산자임
```

해당 내용을 잘 인지하고 있으면 추후에 배울 배열과 포인터 챕터가 악명과 달리 쉽게 다가올 수 있을 것이다.

## 산술 연산자

기본적인 더하기, 빼기, 곱하기, 나누기와 같은 산술 연산을 수행하기 위한 연산자이다. 다음과 같은 연산자들이 있다.

| 연산자 | 설명 |
|:-----:|:-----:|
| + | 더하기(Addition) 연산자 <br> 단항 양수(Unary Plus) 연산자 |
| - | 빼기 연산자(Subtraction) <br> 단항 음수(Unary Minus) 연산자 |
| * | 곱하기(Multiplication) 연산자 |
| / | 나누기(Division) 연산자 |
| % | 나머지(Remainder) 연산자 |

```+```와 ```-```는 항의 개수에 따라 다른 연산자가 될 수 있다. 예를 들어, ```+a```와 ```a + b``` 에서의 ```+```는 서로 다른 연산자이다.  
곱하기와 나누기는 ```×```와 ```÷``` 기호가 키보드로 입력하기 쉽지 않아서 ```*```와 ```/``` 기호를 대신 사용한다.  
나머지 연산의 결과는 나누기 연산을 했을 때 나머지 값이다. 예를 들어 ```12 % 5```의 결과는 12 나누기 5의 나머지인 2이며, ```16 % 4```의 결과는 16 나누기 4의 나머지인 0이다.  

여기까지는 초등학교 수학 시간에 배운 사칙 연산과 다르지 않아서 어렵지 않다. 하지만 주의해야할 점이 있다. 연산 결과 타입에 대해 신경쓰지 않으면 원하는 것과 다른 결과가 발생할 수 있다.  

연산 식의 결과 타입은 피연산자의 타입에 의해 결정된다. 단항 연산자와 같이 피연산자가 하나라면 피연산자의 타입이 곧 결과 타입이 된다. 사칙 연산들과 같이 피연산자가 두 개인 이항 연산자들은 조금 복잡하다. 두 피연산자의 타입이 같다면 해당 타입이 되고, 두 피연산자의 타입이 다르다면 최대한 값 손실이 잃어나지 않도록 결과 타입을 생성한다.  
예를 들어 3 + 4는 두 피연산자가 전부 정수 타입이기 때문에 결과도 정수 타입이 된다. 하지만 3.5 + 3의 피연산자는 하나가 실수이고 하나가 정수이다. 이 때 결과 타입이 정수라면 6.5를 표현할 수 없기 때문에 0.5라는 값이 버려지고 6이 될 것이다. 이러면 값 손실이 발생한다. 따라서 하나의 피연산자가 실수면 결과 타입은 실수 타입이 된다. 3.5 + 3의 경우 결과 값 6.5인 실수 타입이 되는 것이다.  
그런데 이 전 챕터에서 공부한것과 같이 정수 타입 내에도 여러 타입이 있고, 실수 타입 내에도 여러 타입이 있다. 연산 식의 결과 타입은 해당 타입들 중 손실이 최대한 발생하지 않는 타입이 되는 것이다. 결과가 정확히 어떤 타입이 되는지는 조금 복잡하므로, 해당 챕터의 후반부에서 알아보도록 하자.  

그렇다면 ```7 / 2```의 결과는 어떻게 될까? 사칙 연산 상으로 결과는 3.5여야 한다. 하지만 잘 보면 두 피연산자가 모두 똑같은 정수 타입이다. 이러면 결과 타입도 정수 타입이 될 수 밖에 없다. 따라서 ```7 / 2```의 결과는 3.5가 아닌 3이 된다. 만약 3.5라는 결과를 얻고 싶다면 두 피연산자중 적어도 하나를 실수 타입으로 지정해야 한다. ```7.0 / 2```, ```7 / 2.0```, ```7.0 / 2.0``` 과 같이 식을 쓰면 3.5라는 결과를 얻을 수 있다.  

이번엔 ```7.0 % 2.0```의 결과를 생각해보자. 실수의 나누기에서는 나머지가 발생하지 않는다. 그러면 실수 피연산자에 대한 나머지 연산은 항상 결과가 0이 나올까? 아쉽게도 그렇지는 않다. 나머지 연산자의 경우 두 피연산자가 모두 정수 타입만 올 수 있다. 나머지 연산자의 피연산자로 실수 타입이 오게 되면 컴파일 에러를 발생시킨다.  

음수의 나눗셈은 어떤 결과를 보일까? ```-10 / 6```은 -1일까 -2일까? ```-10 % 6```은 -4일까 2일까? C89를 사용한다면 이는 이번 챕터 초반에서 학습했던 Implementation-defined 이다. C99에서는 나누기의 결과가 0에 가까운 쪽으로 고정된다. 따라서 C99라면 나누기의 결과는 -1이며 나머지는 -4가 된다.  

여기까지 산술 연산자의 기본적인 내용을 살펴봤다. 그런데 사칙 연산에서도 그렇듯이, 여러 개의 연산자가 조합된 식을 만들 수도 있다. 예를 들어 ```3 + 5 * 4```와 같은 식을 만들 수 있다. 이 때 연산 순서가 어떻게 될까? 3과 5를 먼저 더하고 그 결과에 4를 곱할까 아니면 5와 4를 먼저 곱하고 그 결과에 3을 더할까?  
이렇게 복잡한 식에서 연산 순서를 결정하는 것이 연산자의 우선 순위(precedence)와 결합 방향(associativity)이다.  
우리가 일반적으로 사칙 연산을 할 때 곱하기와 나누기를 더하기와 빼기보다 먼저 수행한다. 이와 같이 곱하기, 나누기, 나머지 연산자가 더하기와 빼기 연산자보다 더 높은 우선순위를 갖는다. 그리고 단항 연산자는 곱하기, 나누기, 나머지 연산자보다 높은 우선순위를 갖는다. 즉, ```3 + 5 * -2```와 같은 식이 있으면 이는 ```3 + (5 * (-2))```와 같이 괄호를 친 식과 같다. 따라서 그 결과는 7이 된다.  
그러면 같은 우선순위의 연산자가 여러번 등장하면 어떻게 될까? ```5 - 3 - 1```은 ```5 - 3```을 먼저 수행할까 ```3 - 1```을 먼저 수행할까? 이를 결정하는 것이 결합 방향이다. 산술 연산자의 경우 왼쪽에서 오른쪽으로의 결합 방향을 갖는다. 즉, 연산자 우선순위가 같다면 왼쪽에 있는 연산자의 연산을 먼저 수행한다는 것이다. 이를 왼쪽 연산자가 우선한다고 하여 왼쪽 결합 방향(left associativity)이라고도 한다. 결론적으로 ```5 - 3 - 1```은 ```5 - 3```을 먼저 수행하고 ```2 - 1```을 수행하여 1이라는 결과를 갖는다.  

그러면 이제 예제를 작성하며 여태까지 배운 내용을 정리하도록 하자.

```c
// arithmetic_operator.c
#include <stdio.h>

int main(void)
{
    int num1 = 10, num2 = 3, num3 = 5;
    printf("num1 + num2 = %d\n", num1 + num2);
    printf("num1 - num2 = %d\n", num1 - num2);
    printf("num1 * num2 = %d\n", num1 * num2);
    printf("num1 / num2 = %d\n", num1 / num2);
    printf("num1 %% num2 = %d\n", num1 % num2);     // % 문자 출력을 위해서는 %% 로 작성해야 함
    printf("-num1 / num2 = %d\n", -num1 / num2);
    printf("-num1 %% num2 = %d\n", -num1 % num2);
    printf("num1 + num2 * num3 = %d\n", num1 + num2 * num3);
    printf("num1 - num2 - num3 = %d\n", num1 - num2 - num3);
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make arithmetic_operator
cc     arithmetic_operator.c   -o arithmetic_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./arithmetic_operator 
num1 + num2 = 13
num1 - num2 = 7
num1 * num2 = 30
num1 / num2 = 3
num1 % num2 = 1
-num1 / num2 = -3
-num1 % num2 = -1
num1 + num2 * num3 = 25
num1 - num2 - num3 = 2
```

## 대입 연산자

대입 연산자(Assignment Operator)는 변수에 값을 저장하기 위한 연산자이다. 가장 기본적인 형태의 대입 연산자는 다음과 같이 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장하는 것이다.

```c
i = 3;      // 변수 i에 값 3을 저장
j = 5;      // 변수 j에 값 5를 저장
```

수학에서 일반적으로 ```=``` 기호는 왼쪽 항과 오른쪽 항이 같다는 관계를 뜻한다. 하지만 C언어에서는 ```=```를 한 번 사용하면 변수에 값을 저장하는 대입 연산을 의미한다. 추후에 다시 이야기하겠지만 왼쪽 항과 오른쪽 항이 같은지를 확인하는 관계 연산을 위해서는 ```=``` 기호를 두번 연속으로 사용한 ```==``` 연산자를 사용한다.  

대입 연산자의 두 피연산자의 타입이 다른 경우는 어떻게 될까? 예를 들어서 다음과 같은 상황에서는 어떻게 될까?

```c
int i;
double f;

i = 3.14;
f = 5;
```

변수 ```i```는 ```int``` 타입이고, 대입하려는 값 ```3.14```는 ```double``` 타입이다. 또한, 변수 ```f```는 ```double``` 타입이고, 대입하려는 값 ```5```는 ```int``` 타입이다. 이렇게 대입 연산자에서 두 피연산자의 타입이 같지 않은 경우 왼쪽 피연산자의 타입에 맞춰진다. 즉, 실수 ```3.14```는 정수 ```3```으로 변환하여 변수 ```i```에 저장되며, 정수 ```5```는 실수 ```5.0```으로 변환하여 변수 ```f```에 저장된다.  

여기서 한 가지 쉽게 간과하는 중요한 사실이 있다. 대입 연산자도 __연산자__ 라는 사실이다. 따라서, 연산자의 결과 값이 있다. 이는 너무나도 당연하지만 의외로 쉽게 간과하는 사실이다. 대입 연산자의 결과 값은 대입한 이후의 왼쪽 피연산자의 값이다. 즉, 위 예시에서 ```i = 3.14```의 결과 값은 3이며, ```f = 5```의 결과 값은 5.0이다.  

이렇게 대입 연산자가 결과 값을 갖기 때문에 다음 예시처럼 대입 연산자를 연속해서 사용할 수 있으며(이를 체이닝-chaining-이라고 한다), 다른 연산자들과 조합해서 사용할 수도 있다.  

```c
int i, j, k;
i = j = k = 1;      // i, j, k 모두 1이 저장됨
j = 3 + (i = 2.5);  // i의 값은 2이며, j 값은 3 + 2인 5
```

산술 연산자에서도 이야기한 것처럼, 대입 연산자도 연산자이기 때문에 연산자 우선순위와 결합 방향을 갖는다. 대입 연산자는 모든 산술 연산자보다 낮은 우선 순위를 갖고, 결합 방향은 오른쪽에서 왼쪽 방향이다. 따라서 위 예제에서 ```i = j = k = 1```은 ```i = (j = (k = 1))```와 같은 의미이다. 그리고 더하기 연산자보다 대입 연산자의 우선순위가 낮아서 대입 연산자를 먼저 평가하기 위하여 괄호를 쳐준 것이다.  

> 대입 연산자를 다른 연산자와 조합하여 사용하면 코드를 해석하기 어려워지며 실수할 가능성도 높아지므로 실제 프로그램 작성 시에는 절대 이렇게 사용하면 안 된다.

이번 챕터를 시작하면서 오브젝트를 수정하는 모든 행위는 사이드 이펙트라고 했다. 그러면 대입 연산자를 사용하여 변수에 값을 저장하는 것도 사이드 이펙트일까? 당연히 그렇다. ```int```형 변수 ```i```가 있을 때 ```i = 3.5``` 라는 식이 있으면 결과 값은 3이고 사이드 이펙트로 변수 ```i```에 3이 저장되는 것이다. 대입 연산자가 단순히 변수에 값을 할당한다고 알고 있는 것이 아니라, 위와 같이 왼쪽 피연산자의 결과 값을 가지며 추가로 변수 값 저장이라는 사이드 이펙트를 발생시킨다고 알고 있으면 좀 더 C언어를 잘 이해할 수 있다.  

이번엔 대입 연산자의 피연산자에 대해 좀 더 생각해보자. 산술 연산자는 피연산자로 변수, 상수 혹은 다른 연산자들로 조합한 식 등이 올 수 있었다. ```3 + a```, ```b - 5```, ```a * b - 3 / b```와 같은 식들이 모두 유효했다. 대입 연산자는 어떨까? 대입 연산자는 기본적으로 변수에 값을 저장하기 위한 연산자라고 했다. 그런데 ```3 = 5``` 와 같이 사용할 수 있을까? 상수 챕터에서도 이야기했다시피 이렇게 상수를 변경하려고 시도할 수 없다. 즉, 대입 연산자의 왼쪽 피연산자에는 값을 변경할 수 있는 오브젝트만 올 수 있다. 이를 가변 lvalue라고 한다. 여기서 lvalue란 엄밀하게 이야기해서 잠재적으로 오브젝트를 지정할 수 있는 식을 뜻한다. 당장은 어렵기 때문에 변수같은 것들이라고 생각하자. lvalue 중에서 const 오브젝트는 한번 선언한 이 후 값을 변경할 수 없다. 이렇게 값을 변경할 수 없는 lvalue를 제외한 lvalue를 가변 lvalue라고 한다. 가변 lvalue가 될 수 있는 것들은 추후에 더욱 살펴보고, 지금은 변수만 올 수 있다고 생각하자. 결국 다음 예시들과 같이 가변 lvalue가 아닌 것을 대입 연산자의 왼쪽 피연산자로 사용할 수 없다.

```c
3 = i;          // 3은 lvalue가 아님
i + j = 0;      // i + j의 결과로 특정 오브젝트를 지정할 수 없으므로 lvalue가 아님 
-k = 3;         // -k의 결과로 특정 오브젝트를 지정할 수 없으므로 lvalue가 아님
```

위와 같이 가변 lvalue가 아닌 것을 대입 연산자의 왼쪽 피연산자로 사용하면 컴파일 에러가 발생할 것이다.

### 복합 대입 연산자

프로그래밍을 하다보면 변수의 값을 기존에 저장되어 있던 값을 기준으로 특정 값만큼 증가 혹은 감소시키는 경우가 굉장히 많다. 예를 들어 현재 hp가 300인데, 공격을 당해서 50의 데미지를 입은 경우 hp를 250로 감소시켜야 한다. 이런 상황을 다음과 같이 표현할 수 있다.

```c
int hp = 300;   // hp가 300
hp = hp - 50;   // hp가 50 감소한 250이 됨
```

위 예제를 다음과 같이 작성할 수도 있다.

```c
int hp = 300;   // hp가 300
hp -= 50;       // hp를 기존 값에서 50 감소시킴 -> 250이 됨
```

이렇게 기존의 변수 값을 기준으로 특정 값만큼 더하거나, 빼거나, 곱하거나, 나누는 등의 연산을 수행하여 변수의 값을 수정하는 연산자를 복합 대입(Compound Assignment) 연산자라고 한다. 더하기, 빼기, 곱하기, 나누기 기호가 대입 연산 기호의 왼쪽에 오는 것에 주의해야 한다. 더하기나 빼기 기호가 우측에 위치하면 아예 다른 의미가 된다.  

```c
hp -= 50;       // hp를 기존 값에서 50 감소시킴
hp =- 50;       // hp = -50 으로 해석되어 hp에 -50을 대입함
```

복합 대입 연산자는 대입 연산자와 이 전에 배운 산술 연산자 혹은 바로 후에 배울 비트 연산자들과 조합하여 만들 수 있다. 여태까지 배운 산술 연산자와 조합한 복합 대입 연산자들을 다시 설명하면 다음과 같다.

* ```a += b``` : 변수 ```a```와 ```b``` 값을 더해서 ```a```에 저장함
* ```a -= b``` : 변수 ```a```에 ```b``` 값을 빼서 ```a```에 저장함
* ```a *= b``` : 변수 ```a```와 ```b``` 값을 곱해서 ```a```에 저장함
* ```a /= b``` : 변수 ```a```를 ```b``` 값으로 나눠서 몫을 ```a```에 저장함
* ```a %= b``` : 변수 ```a```를 ```b``` 갑승로 나눠서 나머지를 ```a```에 저장함

> 참고로 간혹가다가 ```a = a + b```와 ```a += b```가 완전히 같다고 이야기하는 자료도 있지만 그렇지는 않다. C언어를 처음 공부한다면 지금은 이해할 수 없겠지만 ```a[i++] = a[i++] + b```와 ```a[i++] += b```는 엄연히 다르다. 일단은 저 둘이 완전히 동일한 것은 아니다라는 것만 확인하고 넘어가도록 하자.  

복합 대입 연산자도 대입 연산자의 일종이다. 따라서, 대입 연산자와 같은 연산자 우선 순위와 결합 방향을 갖는다. 뿐만 아니라, 왼쪽 피연산자에는 가변 lvalue만 올 수 있으며, 결과 값으로 왼쪽 피연산자의 대입 이 후 값을 가지며, 사이드 이펙트로 왼쪽 피연산자의 값이 변경된다는 것까지 전부 동일하다. 따라서 대입 연산자에서 봤던 체이닝도 똑같이 사용할 수 있다. 하지만 복합 대입 연산자를 연속으로 사용하는 것은 코드를 해석하기 어렵게 하므로 지양하는 것이 좋다.  

이번에도 예제를 통해서 배운 내용들을 정리해보도록 하자.

```c
// assignment_operator.c
#include <stdio.h>

int main(void)
{
    int i, j, k;

    i = j = k = 1;
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    j = 3 + (i = 2.5);  // 해당 식과 같은 사용은 권장하지 않음
    printf("i : %d, j : %d\n", i, j);

    k *= i;     // k는 기존에 1
    j /= i;     // j는 기존에 5
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    i += j += k;    // 복합 대입 연산자의 체이닝은 권장하지 않음
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make assignment_operator
cc     assignment_operator.c   -o assignment_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./assignment_operator 
i : 1, j : 1, k : 1 
i : 2, j : 5
i : 2, j : 2, k : 2 
i : 6, j : 4, k : 2 
```

## 증감 연산자

복합 대입 연산자를 학습할 때 변수의 값을 특정 값 만큼 증감시키는 작업을 자주 수행한다고 했다. 그 중에서도 특히 변수의 값을 1 증가시키거나 1 감소시키는 작업은 프로그래밍을 하면서 가장 많이 수행하는 작업 중 하나이다. C언어에서는 특별히 변수의 값을 1 증가시키거나 1 감소시키는 연산자를 다음과 같이 정의했다.

```c
++i;    // 변수 i의 값을 1 증가
i++;    // 변수 i의 값을 1 증가
--i;    // 변수 i의 값을 1 감소
i--;    // 변수 i의 값을 1 감소
```

위와 같이 + 기호를 두 번 연속으로 사용하여 증가 연산자를 표현하고, - 기호를 두 번 연속으로 사용하여 감소 연산자를 표현한다. 그리고 보다시피 증감 연산자는 한 개의 피연산자를 갖는다. 그런데 연산자가 피연산자의 왼쪽에 오기도 하고 오른쪽에 오기도 한다. 연산자의 위치가 달라져도 같은 연산일까? 그렇지 않다. 연산자의 위치에 따라 서로 다른 연산자가 된다. 그러면 둘은 무엇이 다를까? 여러가지 다른 점이 있지만 가장 다른 것은 바로 결과 값이다.

변수의 값이 변경되는 것은 모두 사이드 이펙트라고 했다. 증감 연산자를 사용해서 변수에 저장된 값이 1 증가하거나 1 감소하는 것 또한 모두 사이드 이펙트이다. 그렇다면 증감 연산자의 결과 값은 무엇일까? 연산자가 피연산자의 왼쪽에 오면 기존 피연산자에 1을 더하거나 뺀 값이 결과 값이 되고, 연산자가 피연산자의 오른쪽에 오면 기존 피연산자의 값이 결과 값이 된다. 다시 설명하면 다음과 같다.

* ```++i``` : 결과 값은 i + 1이며, 사이드 이펙트로 변수 i의 값이 1 증가함
* ```i++``` : 결과 값은 i이며, 사이드 이펙트로 변수 i의 값이 1 증가함
* ```--i``` : 결과 값은 i - 1이며, 사이드 이펙트로 변수 i의 값이 1 감소함
* ```i--``` : 결과 값은 i이며, 사이드 이펙트로 변수 i의 값이 1 감소함

결과 값의 차이가 어떤 차이를 만들어낼까? 다음과 같은 예시를 생각해보자.

```c
int i = 1, j = 1;
int a, b;

a = i++;    // i++의 결과 값은 i이므로 a = 1 이 됨
b = ++j;    // ++j의 결과 값은 j + 1이므로 b = 1 + 1이 됨
```

이렇게 연산자가 피연산자의 왼쪽에 오는 경우를 전위 증가(Prefix Increment) 연산자 혹은 전위 감소(Prefix Decrement) 연산자라고 하고, 연산자가 피연산자의 오른쪽에 오는 경우를 후위 증가(Postfix Increment) 연산자 혹은 후위 감소(Postfix Decrement) 연산자라고 한다.  

증감 연산자는 사이드 이펙트로 변수의 값을 1 증가 혹은 감소 시킨다고 했다. 따라서 다음과 같은 상황이 연출된다.

```c
int i = 1;
int a, b;

a = i++;    // i++의 결과 값은 i이므로 a = 1이 됨
// 사이드 이펙트로 변수 i에 저장된 값이 1 증가함
b = ++i;    // ++i의 결과 값은 i + 1이므로 b = 2 + 1이 됨
// 사이드 이펙트로 변수 i에 저장된 값이 1 증가함

// 최종적으로 a는 1, b는 3, i는 3이 됨
```

조금 헷갈리지만 해당 연산자를 여러번 사용해보면 어렵지 않게 적응할 수 있을 것이다.  
그런데 변수 i의 값이 증가하거나 감소하는 것이 사이드 이펙트라는 것을 왜 자꾸 강조하는 것일까?  
```++i```는 값이 먼저 증가하고 ```i++```는 값이 나중에 증가한다 처럼 해석하면 안 되는 것일까?  
절대 그러면 안 된다. 하나의 오브젝트에 대한 사이드 이펙트는 꼭 시퀀스 되어야 한다. 다시 말해서 어떤 변수에 대한 사이드 이펙트가 발생했다면 다음 시퀀스 포인트를 만나기 전까지는 해당 변수에 대해 사이드 이펙트가 다시 발생하면 안 된다. 개념적으로 보면 굉장히 어려운데, 다음과 같은 예시를 생각하면 된다.

```c
b = (a = 5) + (a = 3);      // a에 값을 변경하는 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생했음
```

이렇게 사이드 이펙트가 시퀀스 되지 않는 상황은 대표적인 미정의 행위이다. 뿐만 아니라 사이드 이펙트가 수행되는 시점은 시퀀스 포인트 이 전 어디서나 가능하다. 그렇기 때문에 어떤 변수에 대해 사이드 이펙트가 발생했다면 다음 시퀀스 포인트를 만나기 전까지 해당 변수의 값이 무엇일지 알 수 없으므로 해당 변수를 다시 사용해서도 안 된다. 따라서 다음과 같은 식들은 모두 미정의 행위이다.

```c
i = i++;            // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생
j = i++ + ++i;      // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생
i = ++i + i++;      // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 세 번 발생
j = i++ + i + 1;    // i에 대한 사이드 이펙트가 발생한 후 시퀀스 포인트 이 전에 i를 다시 사용, 두 번째 i 값이 증가된 상태인지 알 수 없음
```

위와 같은 식들의 결과 변수 ```i```나 ```j``` 값이 무엇이 되는지 유추하는 것은 의미 없는 행위이다. 이러한 코드는 지양을 넘어서 절대로 작성해서는 안 된다. 물론 위와 같은 코드를 작성한다고 해서 프로그램이 동작하지 않는 것은 아니지만, 어느 날 갑자기 컴퓨터의 기분이 나빠져서 CPU가 폭발한다고 하더라도 이는 전적으로 프로그래머의 잘못임을 인지해야 한다.  
반면 다음과 같은 식은 위와 같은 미정의 행위 문제가 없다.  

```c
k = i++ + ++j;      // i, j, k 모두 사이드 이펙트가 한 번씩 발생
```

하지만 위와 같이 코드를 작성하면 이를 보는 동료 개발자가 코드를 해석하기 어려워질 것이다. 따라서 위와 같이 증감 연산자를 복잡하게 조합하여 사용하는 것은 되도록 지양하는 것이 좋다.  

여태까지 증감 연산자의 결과 값과 사이드 이펙트에 대해서 학습했다. 그러면 해당 연산자의 우선 순위와 결합 방향은 어떻게 될까? 그리고 피연산자에는 어떤 요소가 올 수 있을까?  
우선 후위 증감 연산자는 여태까지 배운 모든 연산자 중에 가장 우선 순위가 높다. 식을 괄호로 묶는 것 외에는 모든 연산자 중 가장 높은 우선 순위를 갖는다. 그리고 결합 방향은 왼쪽에서 오른쪽 방향이다.  
전위 증감 연산자는 후위 증감 연산자보다 우선 순위가 낮고, 일반적인 산술 연산자보다 우선 순위가 높다. 단항 양수/음수 연산자와 같은 우선 순위를 가지며, 결합 방향은 오른쪽에서 왼쪽 방향이다.  

얼핏 보면 ```++i```가 ```i++``` 보다 높은 우선 순위를 갖는 것처럼 보일 수 있다. 이는 ```++i```가 변수를 먼저 증가시키고, ```i++```가 변수를 나중에 증가시킨다는 잘못된 개념에서 유추하는 대표적인 오개념이다. 다시 이야기 하지만 변수의 증가는 사이드 이펙트이기 때문에 증가 시점은 해당 연산자가 평가된 이 후 시퀀스 포인트 이 전 어디서나 발생할 수 있다. 두 연산자의 변수 증가 시점은 같아도 되고, ```i++```가 ```++i```보다 먼저 증가가 발생해도 상관 없다. 단지 ```i++```의 결과 값은 ```i```이며, ```++i```의 결과 값은 ```i + 1```라는 것을 잘 인지해야 한다.  

그러면 증감 연산자는 변수의 값을 변경하는 사이드 이펙트가 있으므로 대입 연산자와 같이 피연산자로 가변 lvalue만 올 수 있을까? 그렇게 유추했다면 추론 능력이 굉장히 뛰어난 독자일 것이다. 증감 연산자는 피연산자로 가변 lvalue만 올 수 있다. ```3++```와 같이 사용할 수 없다. 그러면 증감 연산자는 대입 연산자처럼 체이닝을 할 수 있을까? 즉, ```++(++i)```와 같이 사용할 수 있을까? 만약 증감 연산자의 결과가 가변 lvalue라면 사용할 수 있을 것이고 그렇지 않다면 사용할 수 없을 것이다.  
C언어에서는 후위 증감 연산자와 전위 증감 연산자 모두 결과 값이 lvalue가 아니다. 따라서 위와 같이 사용할 수 없다. 그런데 C++언어의 경우 후위 증감 연산자의 결과는 lvalue가 아니지만 전위 증감 연산자의 결과는 lvalue이다. 따라서 C에서는 불가능한 체이닝이 C++에서는 전위 증감 연산자에 한정하여 사용할 수 있다. 물론 사용 가능하다고 하더라도 시퀀스 포인트 이 전에 사이드 이펙트가 여러 번 발생하는 것이므로 이러한 코드를 작성하면 안 된다.  

> 참고로 정수 변수 뿐만 아니라 실수 변수에도 증감 연산자를 사용할 수 있으며 이번 챕터의 설명이 그대로 적용된다. 하지만 실수 변수에 증감 연산자를 사용하는 경우는 굉장히 드물다.

역시 이번에도 예제를 통해서 배운 내용들을 정리해보도록 하자.

```c
// inc_dec_operator.c
#include <stdio.h>

int main(void)
{
    int i, j, k;
    
    i = 1;  // i를 1로 초기화
    printf("i : %d\n", ++i);    // ++i의 결과 값은 i + 1
    printf("i : %d\n", i);      // 이 전에 i 값이 증가했음
    
    i = 1;  // i를 1로 초기화
    printf("i : %d\n", i++);    // i++의 결과 값은 i
    printf("i : %d\n", i);      // 이 전에 i 값이 증가했음

    i = j = 1;  // i와 j를 1로 초기화
    k = i++ + ++j;  // i와 j는 1 증가, k = i + (j + 1)와 같은 결과 값
    printf("i : %d, j : %d, k : %d\n", i, j, k);

    i = j = 3;  // i와 j를 3으로 초기화
    k = --i * 3 + 4 * j--;  // i와 j는 1 감소, k = (i - 1) * 3 + 4 * j와 같은 결과 값
    printf("i : %d, j : %d, k : %d\n", i, j, k);

    return 0;
}
```

실행 하기 전에 결과 값을 꼭 예측해보자. 실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make inc_dec_operator
cc     inc_dec_operator.c   -o inc_dec_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./inc_dec_operator 
i : 2
i : 2
i : 1
i : 2
i : 2, j : 2, k : 3
i : 2, j : 2, k : 18
```

실행 결과와 주석을 보고 이해가지 않는 부분이 있다면 이번 챕터를 다시 한번 천천히 읽어보기를 권장한다.

## 관계 연산자와 동등 연산자

관계 연산자(Relational Operator)는 다음과 같이 두 피연산자의 대소 관계를 비교한다.  

```c
a < b;      // a가 b보다 작으면 참
a <= b;     // a가 b보다 작거나 같으면 참
a > b;      // a가 b보다 크면 참
a >= b;     // a가 b보다 크거나 같으면 참
```

관계 연산자도 연산자이므로 결과 값이 있다. 대소 관계가 참이라면 ```int``` 타입의 정수 1이 결과 값이 되고, 거짓이라면 ```int``` 타입의 정수 0이 결과 값이 된다.  
C언어에서 값 0은 거짓을 의미하고, 그 외의 값들은 참을 의미한다. 1, -1, 100 모두 참 값이 되는데, 보통 1을 참 값의 대표로 사용한다.  
즉, ```a < b``` 라는 식에서 변수 ```a```에 저장된 값이 변수 ```b```에 저장된 값보다 작다면 참을 뜻하는 1이 결과가 되고, 그렇지 않다면 거짓을 뜻하는 0이 결과가 된다.  

동등 연산자(Equality Operator)는 관계 연산자와 유사하게 두 피연산자가 동등한지 비교한다.

```c
a == b;     // a와 b가 같으면 참
a != b;     // a와 b가 다르면 참
```

동등 연산자도 마찬가지로 동등 관계가 참이라면 ```int``` 타입의 정수 1이 결과 값이 되고, 거짓이라면 ```int``` 타입의 정수 0이 결과 값이 된다.  

참고로 관계 연산자는 산술 연산자보다 낮고 대입 연산자보다 높은 우선순위를 갖는다. 동등 연산자는 관계 연산자보다 낮고 대입 연산자보다 높은 우선순위를 갖는다. 그리고 둘 다 왼쪽에서 오른쪽으로의 결합 방향을 갖는다.  

관계 연산자와 동등 연산자는 선택문이나 반복문의 제어식에서 주로 사용한다. '만약 hp가 100보다 적다면 사용자에게 알린다' 와 같은 상황에서 사용하기 적합하다. 지금은 예제를 통해 단순히 결과 값을 확인하도록 하자.  

```c
// relational_operator.c
#include <stdio.h>

int main(void)
{
    int a = 3, b = 5;
    printf("a < b : %d\n", a < b);      // a가 b보다 작으면 참
    printf("a <= 3 : %d\n", a <= 3);    // a가 3보다 작거나 같으면 참
    printf("a > b : %d\n", a > b);      // a가 b보다 크면 참
    printf("a >= 3 : %d\n", a >= 3);    // a가 3보다 크거나 같으면 참
    printf("a == b : %d\n", a == b);    // a와 b가 같으면 참
    printf("a != b : %d\n", a != b);    // a와 b가 다르면 참
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make relational_operator
cc     relational_operator.c   -o relational_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./relational_operator 
a < b : 1
a <= 3 : 1
a > b : 0
a >= 3 : 1
a == b : 0
a != b : 1
```

## 논리 연산자

논리 연산자(Logical Operator)에는 논리 AND 연산자, 논리 OR 연산자, 논리 NOT 연산자가 있다. 보통 해당 연산자들을 이야기할 때는 번역하지 않고 영어를 그대로 사용한다.  
논리 AND 연산자는 ```&&```이며, 두 피연산자가 모두 참일 경우 참이 된다. 논리 OR 연산자는 ```||```이며, 두 피연산자 중 적어도 하나가 참이면 참이 된다. 논리 NOT 연산자는 ```!```이며 하나의 피연산자를 가지고, 해당 피연산자가 참이면 거짓, 거짓이면 참이 된다. 표로 표현하면 다음과 같다.  

| AND 연산자 \\ 우측 피연산자 <br> 좌측 피연산자  \\ | 참 | 거짓 |
|:----:|:----:|:-----:|
| 참 | 참 | 거짓 |
| 거짓 | 거짓 | 거짓 |

| OR 연산자 \\ 우측 피연산자 <br> 좌측 피연산자  \\ | 참 | 거짓 |
|:----:|:----:|:-----:|
| 참 | 참 | 참 |
| 거짓 | 참 | 거짓 |

| NOT 연산자 | 참 | 거짓 |
|:----:|:----:|:-----:|
| 적용 결과 | 거짓 | 참 |

논리 연산자의 결과 값은 관계 연산자와 마찬가지로 참이라면 ```int``` 타입의 정수 1이 결과 값이 되고, 거짓이라면 ```int``` 타입의 정수 0이 결과 값이 된다.  
즉, ```3 && 1``` 은 두 피연산자가 모두 참이므로 결과 값이 1이며, ```3 && 0``` 은 피연산자에 거짓의 값인 0이 있으므로 결과 값이 0이다. ```3 || 0```은 피연산자 중 하나가 참이므로 결과 값이 1이며, ```0 || 0```은 두 피연산자가 모두 거짓이므로 결과 값이 0이다. ```!0```은 참이므로 결과 값이 1이며, ```!1```은 거짓이므로 결과 값이 0이다. 0에 논리 NOT 연산자를 적용하면 결과 값은 1이 되고, 0 외의 값(1, 3, -1 등)에 논리 NOT 연산자를 적용하면 결과 값은 항상 0이 된다.  

논리 AND 연산자와 논리 OR 연산자는 알아둬야 할 두 가지 사실이 있다. 우선 논리 AND 연산자와 논리 OR 연산자는 시퀀스 포인트라는 점이다. 따라서 다음과 같은 식을 쓸 수 있다.  
```c
++i && ++i;     // && 연산자가 시퀀스 포인트이므로 두 사이드 이펙트가 시퀀스됨
i++ && i;       // && 연산자가 시퀀스 포인트이므로 두 번째 i가 증가된 상태라는 것이 보장됨
```

다음으로 알아야 할 사실은 논리 AND 연산자와 논리 OR 연산자는 왼쪽 피연산자가 항상 오른쪽 피연산자보다 먼저 평가(evaluation)되며, 왼쪽 피연산자의 결과에 따라 오른쪽 피연산자의 평가를 생략할 수도 있다는 것이다.  
개념이 조금 어렵기 때문에 예시를 통해 이야기하자.  
```a && b``` 라는 식이 있으면 항상 ```a```가 참인지 먼저 판단하고 참이 맞다면 ```b```가 참인지를 판단한다. 이 때 ```a```가 만약 거짓이라면 ```b```가 참인지 거짓인지와 상관 없이 논리 연산자의 결과는 항상 거짓이 되므로 ```b```에 대한 평가를 생략한다.  
```a || b``` 라는 식이 있으면 마찬가지로 항상 ```a```가 참인지 먼저 판단한다. 이 때 ```a```가 참이라면 ```b```가 참인지 거짓인지와 상관 없이 논리 연산자의 결과는 항상 참이 되므로 ```b```에 대한 평가를 생략한다.  
즉, 논리 AND 연산자는 왼쪽 피연산자가 참인 경우만 오른쪽 피연산자가 평가되고, 논리 OR 연산자는 왼쪽 피연산자가 거짓인 경우만 오른쪽 피연산자가 평가된다. 논리 AND 연산자는 왼쪽 피연산자가 거짓이면 결과는 어차피 거짓이며, 논리 OR 연산자는 왼쪽 피연산자가 참이면 결과는 어차피 참이기 때문에 오른쪽 피연산자를 평가할 필요가 없는 것이다.  
이러한 사실 때문에 다음과 같은 놀라운 현상이 발생할 수 있다.  
```c
i = 0;
i++ && i++;     // 왼쪽 피연산자 i++의 결과 값이 0이므로 거짓 -> 오른쪽 피연산자를 평가하지 않음
i == 1;         // i의 값은 1이 됨 -> i가 1 증가함

i = 1;
i++ && i++;     // 왼쪽 피연산자 i++의 결과 값이 1이므로 참 -> 오른쪽 피연산자도 평가함
i == 3;         // i의 값은 3이 됨 -> i가 2 증가함
```

분명 ```i++ && i++``` 라는 식을 똑같이 사용했는데, 변수 ```i```의 초기 값에 따라 1이 증가할수도 2가 증가할 수도 있는 것을 볼 수 있다. 이렇게 왼쪽 피연산자의 결과에 따라 오른쪽 피연산자의 평가를 생략하는 것을 Short-Circuit Evaluation이라고 한다.  
추후에 다시 이야기 하겠지만 함수 호출 또한 연산의 일종이다. 따라서 함수 호출과 다른 연산자를 조합하여 사용할 수도 있다. 만약 함수 호출을 논리 연산자와 함께 사용한다면 Short-Circuit Evaluation에 의해 경우에 따라 함수를 호출하거나 호출하지 않는 코드를 만들 수도 있다. 예를 들어 ```a && printf("Hello World!\n")``` 라고 하면 변수 ```a```가 참일 때만 ```printf``` 함수가 호출될 것이다.  

논리 연산자는 관계 연산자나 동등 연산자와 함께 선택문과 반복문에서 주로 사용된다. 따라서 지금은 예제를 통해 간단한 결과 값과 위에서 언급한 두 가지 특수한 사실을 확인하도록 하자.

```c
// logical_operator.c
#include <stdio.h>

int main(void)
{
    int a = 3, b = 0;
    printf("a && b : %d\n", a && b);
    printf("a || b : %d\n", a || b);
    printf("!a : %d, !b : %d\n", !a, !b);   // 참은 거짓으로, 거짓은 참으로

    int i = 0;
    printf("i++ && i++ : %d\n", i++ && i++);    // 좌측 피연산자 i++의 결과가 0이므로 거짓, 우측 피연산자 평가 생략
    printf("i : %d\n", i);      // i가 1 증가했음
    printf("i++ && i++ : %d\n", i++ && i++);    // 좌측 피연산자 i++의 결과가 1이므로 참, 우측 피연산자 평가 함
    printf("i : %d\n", i);      // i가 2 증가했음

    i = 0;
    i && printf("Hello World 1\n");     // i가 0(거짓)이므로 우측 피연산자 평가 생략
    i = 1;
    i && printf("Hello World 2\n");     // i가 1(참)이므로 우측 피연산자 평가 함

    i = 0;
    i || printf("Hello World 3\n");     // i가 0(거짓)이므로 우측 피연산자 평가 함
    i = 1;
    i || printf("Hello World 4\n");     // i가 1(참)이므로 우측 피연산자 평가 생략

    return 0;
}
```

이번 예제도 실행 전에 결과를 예측해보기 바란다. 실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make logical_operator
cc     logical_operator.c   -o logical_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./logical_operator 
a && b : 0
a || b : 1
!a : 0, !b : 1
i++ && i++ : 0
i : 1
i++ && i++ : 1
i : 3
Hello World 2
Hello World 3
```

> 논리 연산자가 시퀀스 포인트라는 사실과 Short-Circuit Evaluation을 보장한다는 사실로 인해 위와 같은 코드를 작성할 수는 있다. 하지만 이러한 코드는 가독성을 떨어트릴 수 있기 때문에 짧은 코드를 작성해야 하는 일부 상황을 제외하고는 지양하는 것이 좋다.

## 비트 연산자

비트 연산자(Bitwise Operator)는 정수 피연산자에 대해 비트 단위의 조작을 수행하는 연산이다. 비트 연산은 상대적으로 사람보다 컴퓨터에게 가까운 연산이다. 비트 단위의 연산이기 때문에 연산 과정을 항상 이진수로 접근해야 한다. 이러한 성질때문에 비트 연산자를 처음 접하면 다른 연산자보다 이해하기 어려워하는 경우가 많으며, 해당 연산자를 어디에 사용해야할지 의문을 표하기도 한다.  
비트 연산은 속성 정보를 표현하거나, 데이터의 유무를 표현하거나, 데이터의 암복호화를 수행하거나, 빠른 속도의 연산이 필요할 때 주로 사용하며, 이 외에도 다양한 사용처가 있다. 그리고 비트 연산자도 계속 사용하다보면 자연스레 익숙해진다. 특히나 주로 사용하는 패턴이 정해져 있기 때문에 더욱 쉽게 익숙해질 수 있다. 그러니 아래에서 소개하는 연산자들이 어렵게 느껴진다면 해당 절을 너무 오래 붙잡고 있기 보다는 이 후 단원들을 공부하면서 중간중간 꾸준히 비트 연산자를 사용하며 천천히 친숙해지는 것이 효율적이다. 그러니 이번 절은 조금 가벼운 마음으로 학습하도록 하자.  

> 모든 비트 연산자는 피연산자로 정수만 올 수 있다. 또한, 비트 연산자들은 산술 연산자와 마찬가지로 대입 연산자와 조합하여 복합 대입 연산자로 사용할 수 있다.

### 비트 NOT 연산자

비트 NOT 연산자는 ```~``` 기호를 사용하며, 다른 비트 연산자들과 달리 하나의 피연산자를 갖는다. 이진수 피연산자의 각 비트를 0은 1로, 1은 0으로 변경한다. 0을 1로, 1은 0으로 변경하는 행위를 토글(toggle)이라고도 한다.  

예를 들어 1바이트로 표현한 10은 이진수로 ```0b00001010```이다. 여기에 ```~10```와 같이 비트 NOT 연산을 적용하여 각 비트들을 토글하면 ```0b11110101```이 된다.  

다음 예제를 통해 비트 NOT 연산자의 결과를 확인해보도록 하자.  

```c
// bitwise_not.c
#include <stdio.h>

int main(void)
{
    signed char n1 = 10;    // 0b00001010
    signed char n2 = -128;  // 0b10000000
    signed char n3 = -1;    // 0b11111111
    signed char n4 = 0;     // 0b00000000

    printf("~n1 : %d\n", ~n1);  // 0b11110101
    printf("~n2 : %d\n", ~n2);  // 0b01111111
    printf("~n3 : %d\n", ~n3);  // 0b00000000
    printf("~n4 : %d\n", ~n4);  // 0b11111111

    return 0;
}
```

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make bitwise_not
cc     bitwise_not.c   -o bitwise_not
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./bitwise_not 
~n1 : -11
~n2 : 127
~n3 : 0
~n4 : -1
```

챕터3에서 음의 정수 표현법을 학습했다면 결과를 이해하는데 어려움이 없을 것이다. 혹시라도 각 이진 값의 출력 결과가 이해되지 않는다면 음의 정수 표현법을 다시 학습하도록 하자.  

비트 NOT 연산을 적용하면 모든 비트가 토글되는 것이므로, 피연산자의 1의 보수를 구한 것이 된다. 따라서 어떤 값과 해당 값에 비트 NOT 연산을 적용한 값을 더하면 항상 모든 비트가 1인 -1이 된다.  

```c
printf("%d \n", 10 + ~10);          // 0b11111111111111111111111111111111 : -1
printf("%d \n", -100 + ~(-100));    // 0b11111111111111111111111111111111 : -1
printf("%d \n", 0 + ~0);            // 0b11111111111111111111111111111111 : -1
```

직접 위와 같은 예제를 작성하여 결과를 확인해보기 바란다.  

### 비트 쉬프트 연산자

비트 쉬프트(Bitwise Shift) 연산자는 ```<<``` 와 ```>>``` 기호를 사용한다. 왼쪽 피연산자로 사용된 이진수의 각 자리 수를 오른쪽 피연산자 값 만큼 왼쪽 혹은 오른쪽으로 이동시킨다.  

1바이트로 표현한 10은 이진수로 ```0b00001010```이다. 여기에 ```10 << 1```와 같이 왼쪽 쉬프트를 1만큼 적용하면 비트가 한 칸씩 움직여서 ```0b00010100```(20)이 되고, ```10 << 2```와 같이 왼쪽 쉬프트를 2만큼 적용하면 비트가 두 칸씩 움직여서 ```0b00101000```(40)이 된다. 반대로 ```10 >> 1```와 같이 오른쪽 쉬프트를 1만큼 적용하면 비트가 한 칸씩 움직여서 ```0b00000101```(5)이 되고, ```10 >> 2```와 같이 오른쪽 쉬프트를 2만큼 적용하면 비트가 두 칸씩 움직여서 ```0b00000010```(2)이 된다.  

쉬프트 연산의 결과로 비트 1이 표현할 수 있는 값의 범위를 넘어가면 해당 비트는 버려지게 된다. 예를 들어 1바이트로 값을 표현한다고 할 때, ```0b11000000 << 1```의 결과는 ```0b10000000``` 이며, ```0b00000011 >> 1```의 결과는 ```0b00000001```이다.  
```<<``` 연산의 결과 비트가 왼쪽으로 쉬프트 되었을 때 오른쪽 비트들은 0으로 채워진다.  
```>>```의 경우 조금 복잡하다. 왼쪽 피연산자가 ```unsigned``` 타입이거나, ```signed``` 타입이지만 가장 왼쪽의 비트(MSB)가 0일 경우 비트가 오른쪽으로 쉬프트 되었을 때 왼쪽 비트가 마찬가지로 0으로 채워진다.  
그런데 왼쪽 피연산자가 ```signed``` 타입이면서 가장 왼쪽의 비트(MSB)가 1일 경우 기존 피연산자는 음수를 의미한다. 이 때 해당 정수가 오른쪽으로 쉬프트 되었을 때 왼쪽 비트가 0으로 채워지면 부호를 나타내기 위한 가장 왼쪽의 비트가 1에서 0으로 변경되어 음수에서 양수로 변경된다. 따라서 위와 같은 경우 부호를 유지하려면 왼쪽 비트를 1로 채워야 한다. 즉, 피연산자 -128에 우측 쉬프트 연산을 적용할 때, 왼쪽 비트를 0으로 채운다면 ```0b10000000 >> 1```의 결과가 ```0b01000000```인 64가 되고, 왼쪽 비트를 1로 채운다면 ```0b10000000 >> 1```의 결과가 ```0b11000000```인 -64가 되는 것이다.  
독자분들은 위와 같은 상황에서 왼쪽 비트를 0으로 채우는 것과 1로 채우는 것 중 어떤 것이 옳다고 생각하는가? 사실 이는 Implementation-defined behavior이다. 우리가 실습을 진행하고 있는 WSL 환경에서는 왼쪽 비트가 1로 채워진다. 하지만 다른 어떤 환경에서는 왼쪽 비트가 0으로 채워질 수도 있다. 따라서 음수 정수에 대해 오른쪽 쉬프트 연산을 수행하려고 한다면 미리 해당 환경에서의 동작 방식을 확인해야 한다.  

비트 쉬프트 연산자의 결과를 보다 보면 한 가지 사실을 유추할 수 있다. ```<<``` 연산은 왼쪽으로 한 번 쉬프트 할 때마다 2씩 곱하는 것과 같으며, ```>>``` 연산은 오른쪽으로 한 번 쉬프트 할 때마다 2씩 나누는 것과 같다는 것이다.  
위에서 ```10 << 1```의 결과는 20이었고, ```10 << 2```의 결과는 40이었다. 또한 ```10 >> 1```의 결과는 5였고, ```10 >> 2```의 결과는 2였다. 나머지를 버리는 정수 나눗셈의 성질을 생각한다면 각각 곱하기 2, 곱하기 4, 나누기 2, 나누기 4와 같다는 것을 알 수 있다.  
사실 이는 십진수로 바꿔서 생각하면 너무나도 당연한 성질이다. 십진수 12를 십진수 상에서 왼쪽으로 한 칸 쉬프트 하면 120이 될 것이며, 두 칸 쉬프트 하면 1200이 될 것이다. 이는 각각 10을 곱한 것, 100을 곱한 것과 같다. 마찬가지로 십진수 365를 십진수 상에서 오른쪽으로 한 칸 쉬프트 하면 36이며, 두 칸 쉬프트 하면 3이다. 이는 각각 10을 나눈 몫, 100을 나눈 몫과 같다. 이와 같은 성질을 이진수로 적용한다고 생각하면 어렵지 않게 이해할 수 있는 성질이다.  
이를 일반화한다면 ```E1 << E2```의 결과는 $E1 × 2^{E2}$ 와 같으며, ```E1 >> E2```의 결과는 $E1 ÷ 2^{E2}$ 와 같다고 할 수 있다. 단, ```E1 >> E2```에서 ```E1```가 음수 정수인 경우에는 위에서 언급한 바와 같이 구현에 따라 다를 수 있다.  

참고로 컴퓨터의 입장에서 곱하기와 나누기는 더하기와 빼기에 비해 수행하기 굉장히 어려운 연산이다. 그런데 쉬프트 연산은 더하기와 빼기만큼이나 수행하기 쉬운 연산이다. 따라서, C언어로 곱하기나 나누기 연산을 수행하는 코드를 작성하면 컴파일러는 프로그램의 효율을 위하여 최대한 이를 쉬프트 연산과 더하기 및 빼기 연산의 조합으로 변경하도록 최적화를 시도할 것이다.  
예를 들어 ```a * 8```은 ```a << 3```으로 변경하고, ```a * 9```는 ```(a << 3) + a```로 변경하려고 시도할 것이다. 그렇다고 모든 경우에 위와 같이 최적화할 수 있는 것은 아니다. ```a * 79```와 같은 경우엔 쉬프트 연산과 더하기를 사용하도록 변경한다면 ```(a << 6) + (a << 3) + (a << 2) + (a << 1) + a```가 될 것이다. 이런 경우엔 굳이 변경하지 않고 곱하기 명령을 수행하는 것이 나을 수 있다.  
물론, 변경이 용이한 상황이라고 해서 모든 컴파일러가 항상 위와 같은 최적화를 수행해주는 것은 아니다. 컴파일러의 종류나 버전에 따라서, 아키텍처에 따라서, 컴파일러 최적화 옵션에 따라서 위와 같은 최적화를 수행하지 않을 수도 있다. 그러므로 성능이 중요한 상황에서 잦은 곱하기와 나누기 연산을 수행해야 할 때 위와 같이 쉬프트 연산으로 변환하는 것이 효율적이라고 판단되면 쉬프트 연산을 사용하는 것이 좋다.  

그러면 예제를 통해서 위에서 학습한 비트 쉬프트 연산자의 결과들을 확인하도록 하자.  

```c
// bitwise_shift.c
#include <stdio.h>
#include <limits.h>     // INT_MIN을 위해 사용

int main(void)
{
    int n1 = 10;
    int n2 = INT_MIN;   // MSB가 1이고 나머지가 0인 이진수

    printf("n1 : %d\n", n1);
    printf("n1 << 1 : %d\n", n1 << 1);
    printf("n1 << 2 : %d\n", n1 << 2);
    printf("n1 << 3 : %d\n", n1 << 3);
    printf("n1 << 4 : %d\n", n1 << 4);
    printf("n1 << 5 : %d\n", n1 << 5);
    printf("n1 << 6 : %d\n", n1 << 6);
    printf("n1 >> 1 : %d\n", n1 >> 1);
    printf("n1 >> 2 : %d\n", n1 >> 2);
    printf("n1 >> 3 : %d\n", n1 >> 3);
    printf("n1 >> 4 : %d\n", n1 >> 4);

    printf("n2 : %d\n", n2);
    printf("n2 >> 1 : %d\n", n2 >> 1);
    printf("n2 >> 2 : %d\n", n2 >> 2);
    printf("n2 >> 3 : %d\n", n2 >> 3);
    printf("n2 >> 4 : %d\n", n2 >> 4);

    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make bitwise_shift
cc     bitwise_shift.c   -o bitwise_shift
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./bitwise_shift 
n1 : 10
n1 << 1 : 20
n1 << 2 : 40
n1 << 3 : 80
n1 << 4 : 160
n1 << 5 : 320
n1 << 6 : 640
n1 >> 1 : 5
n1 >> 2 : 2
n1 >> 3 : 1
n1 >> 4 : 0
n2 : -2147483648
n2 >> 1 : -1073741824
n2 >> 2 : -536870912
n2 >> 3 : -268435456
n2 >> 4 : -134217728
```

```<<``` 연산의 결과로 2씩 곱해지는 것과, ```>>``` 연산의 결과로 2씩 나눠지는 것을 볼 수 있다. 또한, 해당 환경에서는 음수 정수에 ```>>``` 연산을 수행하면 왼쪽 비트가 1로 채워진다는 것을 확인할 수 있다.  

### 비트 AND 연산자

비트 AND 연산자는 ```&``` 기호를 사용한다. 두 피연산자의 각 비트가 모두 1인 자리는 1, 그 외의 자리는 0 인 정수를 결과 값으로 가진다. 예를 들어 ```0b10101010 & 0b10011001```의 연산은 다음과 같다.

$AND$  
$10101010_{2}$  
$10011001_{2}$  
$----$  
$10001000_{2}$  

두 피연산자의 이진수 각 자리가 둘 다 1인 경우에 해당 자리가 1이 되고, 그 외의 경우는 0이 되는 것을 볼 수 있다.  

비트 AND 연산자는 주로 어떤 정수의 특정 비트가 1인지 확인할 때와, 어떤 정수의 특정 비트를 0으로 만들 때 사용한다.  

어떤 정수의 특정 비트가 1인지 확인하기 위해서 이진수로 표현하면 ```0b0001010```이 되는 정수 10에 대해 생각해보자. 오른쪽에서 네 번째 비트가 1인지 확인하고 싶을 때 ```10 & (1 << 3)```의 결과가 참이라면(0이 아니라면) 네 번째 비트가 1이고, 거짓이라면 네 번째 비트가 0이다. 이를 일반화하여 정수 E의 오른쪽에서 n 번째 비트가 1인지 확인하고 싶을 때는 ```E & (1 << n - 1)```의 결과가 0이 아닌지 확인하면 된다.  
```(1 << n - 1)```의 결과는 오른쪽에서 n번째 비트가 1이고 나머지는 0인 정수이다. 해당 정수와 검사하고 싶은 정수에 대해 AND 연산을 수행하면 오른쪽에서 n번째 비트를 제외하고는 무조건 0이 될 것이다. 오른쪽에서 n번째 비트는 검사하고 싶은 정수의 해당 비트가 1이라면 1이 될 것이고, 0이라면 0이 될 것이다. 따라서, 검사할 정수의 오른쪽에서 n번째 비트가 0이면 모든 비트가 0인 값(0)이 될 것이며, 오른쪽에서 n번째 비트가 1이면 해당 비트가 1인 값(0이 아닌 값)이 될 것이다. 이해가 잘 되지 않는다면 손으로 천천히 계산해보자.  

어떤 정수의 특정 비트를 0으로 만드는 작업도 유사하다. 정수 10의 오른쪽에서 네 번째 비트를 0으로 만든 값을 구하고 싶다면 ```10 & ~(1 << 3)```으로 계산할 수 있다. 이를 일반화하여 정수 E의 오른쪽에서 n번째 비트를 0으로 만든 값을 구하고 싶다면 ```E & ~(1 << n - 1)```로 계산할 수 있다.  
이 전과 마찬가지로 ```(1 << n - 1)```의 결과는 오른쪽에서 n번째 비트가 1이고 나머지는 0인 정수이다. 여기에서 비트 NOT 연산을 수행한 ```~(1 << n - 1)```의 결과는 오른쪽에서 n번째 비트가 0이고 나머지는 1인 정수이다. 해당 값을 대상 정수와 AND 연산을 수행하면 오른쪽에서 n번째 비트는 0이 되고 나머지 비트는 기존 정수의 값들이 그대로 보존된다. 대상 정수의 오른쪽에서 n번째 비트가 기존에 1이라면 0으로 바뀌고, 기존에 0이었으면 그대로 0이 되는 것이다. 이번에도 이해가 잘 되지 않는다면 손으로 단계별로 계산해보자.  

예제를 통해서 위의 내용들을 확인해보도록 하자.  

```c
// bitwise_and.c
#include <stdio.h>

int main(void)
{
    int a = 0b10101010;     // 170
    int b = 0b10011001;     // 153

    printf("%d \n", a & b);     // 0b10001000
    printf("\n");

    int n = 10;     // 0b1010
    printf("%d\n", n & (1 << 0));   // 첫 번째 비트가 1이면 0이 아님
    printf("%d\n", n & (1 << 1));   // 두 번째 비트가 1이면 0이 아님
    printf("%d\n", n & (1 << 2));   // 세 번째 비트가 1이면 0이 아님
    printf("%d\n", n & (1 << 3));   // 네 번째 비트가 1이면 0이 아님
    printf("%d\n", n & (1 << 4));   // 다섯 번째 비트가 1이면 0이 아님
    printf("\n");

    // 아래 연산 결과 n에 저장된 값이 변경되는 것은 아님
    printf("%d\n", n & ~(1 << 0));  // 첫 번째 비트를 0으로 만듦
    printf("%d\n", n & ~(1 << 1));  // 두 번째 비트를 0으로 만듦
    printf("%d\n", n & ~(1 << 2));  // 세 번째 비트를 0으로 만듦
    printf("%d\n", n & ~(1 << 3));  // 네 번째 비트를 0으로 만듦
    printf("%d\n", n & ~(1 << 4));  // 다섯 번째 비트를 0으로 만듦
    printf("\n");

    // 복합 대입 연산자를 사용하여 특정 비트를 0으로 만든 값을 기존 n에 저장
    n &= ~(1 << 1);     // 두 번째 비트를 0으로 만든 값을 n에 저장
    printf("%d\n", n);
    n &= ~(1 << 3);     // 네 번째 비트를 0으로 만든 값을 n에 저장
    printf("%d\n", n);
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make bitwise_and
cc     bitwise_and.c   -o bitwise_and
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./bitwise_and 
136 

0
2
0
8
0

10
8
10
2
10

8
0
```

주석에서 설명한대로 실행 결과와 같이 비트 연산의 결과 기존 피연산자로 사용한 변수의 값이 변경되는 것은 아니다. 변수의 값을 변경하고 싶다면 예제의 마지막 연산들과 같이 복합 대입 연산자를 사용할 수 있다.  

### 비트 OR 연산자

비트 AND 연산자는 ```|``` 기호를 사용한다. 두 피연산자의 각 비트가 모두 0인 자리는 0, 그 외의 자리는 1 인 정수를 결과 값으로 가진다. 예를 들어 ```0b10101010 | 0b10011001```의 연산은 다음과 같다.

$OR$  
$10101010_{2}$  
$10011001_{2}$  
$----$  
$10111011_{2}$  

두 피연산자의 이진수 각 자리가 둘 다 0인 경우에 해당 자리가 0이 되고, 그 외의 경우는 1이 되는 것을 볼 수 있다.  

비트 OR 연산자는 비트 AND 연산자와 반대로 주로 어떤 정수의 특정 비트를 1로 만들 때 사용한다.  

마찬가지로 정수 10의 오른쪽에서 세 번째 비트를 1로 만든 값을 구하고 싶다면 ```10 | (1 << 2)```로 계산할 수 있다. 이를 일반화하여 정수 E의 오른쪽에서 n번째 비트를 1로 만든 값을 구하고 싶다면 ```E | (1 << n - 1)```로 계산할 수 있다.  
이 전에 말한 것과 같이 ```(1 << n - 1)```의 결과는 오른쪽에서 n번째 비트가 1이고 나머지는 0인 정수이다. 해당 정수와 대상 정수에 비트 OR 연산을 수행하면 오른쪽에서 n번째 비트는 무조건 1이 되며, 나머지 비트는 기존 대상 정수의 값들이 그대로 보존된다.  

이번에도 예제를 통해서 해당 내용을 확인해보도록 하자.

```c
// bitwise_or.c
#include <stdio.h>

int main(void)
{
    int a = 0b10101010;     // 170
    int b = 0b10011001;     // 153

    printf("%d \n", a | b);
    printf("\n");

    int n = 10;     // 0b1010
    printf("%d\n", n | (1 << 0));   // 첫 번째 비트를 1로 만듦
    printf("%d\n", n | (1 << 1));   // 두 번째 비트를 1로 만듦
    printf("%d\n", n | (1 << 2));   // 세 번째 비트를 1로 만듦
    printf("%d\n", n | (1 << 3));   // 네 번째 비트를 1로 만듦
    printf("%d\n", n | (1 << 4));   // 다섯 번째 비트를 1로 만듦
    printf("\n");

    // 복합 대입 연산자를 사용하여 특정 비트를 1로 만든 값을 기존 n에 저장
    n |= (1 << 0);  // 첫 번째 비트를 1로 만든 값을 n에 저장
    printf("%d\n", n);
    n |= (1 << 2);
    printf("%d\n", n);
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make bitwise_or
cc     bitwise_or.c   -o bitwise_or
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./bitwise_or 
187 

11
10
14
10
26

11
15
```

### 비트 XOR 연산자

비트 XOR 연산자는 ```^``` 기호를 사용한다. 두 피연산자의 각 비트가 같은 자리는 0, 다른 자리는 1 인 정수를 결과 값으로 가진다. 예를 들어 ```0b10101010 | 0b10011001```의 연산은 다음과 같다.  

$XOR$  
$10101010_{2}$  
$10011001_{2}$  
$----$  
$00110011_{2}$  

두 피연산자의 이진수 각 자리가 다르면 0이 되고, 같으면 1이 되는 것을 볼 수 있다. 다시 말해, 이진수 각 자리에 비트 1이 홀수 개면 결과가 1, 비트 1이 짝수 개면 결과가 0이 된다.  

비트 XOR 연산자는 주로 데이터에 암복호화를 수행할 때 사용한다. 암호화(Encryption)는 어떤 데이터를 특정한 사람을 제외하고는 읽어볼 수 없도록 조작하는 것을 의미하며, 복호화(Decryption)는 암호화한 데이터를 원본 데이터로 되돌리는 것을 의미한다.  
비트 XOR 연산은 데이터를 암복호화 하는 가장 간단하고 쉬운 방법이다. 암복호화에는 다양한 종류가 있으며, 실제 암복호화 수행 시 XOR 연산만 사용하는 경우는 사실상 없지만 XOR 연산은 보통 다른 암복호화 방식의 기초가 된다. XOR로 어떻게 데이터를 암복호화하는지 살펴보자.  

좋아하는 이성(편의상 빈이라고 부르겠다)에게 고백 편지를 쓰려고 한다. 편지의 내용은 "LOVE"라는 문자열로, 아스키 코드로 나타내면 널문자를 제외하고 76 79 86 69 이다. 그런데 편지의 내용을 빈을 제외한 사람들이 알아듣지 못하도록 하고 싶다. 이 때 XOR 연산을 통해 편지의 내용을 안전하게 숨길 수 있다. 문자열의 각 문자 코드와 10이라는 값을 XOR해보자. 70 69 92 79 이다. 이는 아스키 코드상 "FE\O"라는 문자열이 되는데, 이것만 보고는 무슨 말인지 알 수 없다. 그러니 안심하고 "FE\O" 라는 문자열이 담긴 편지를 빈에게 전달하자. 혹시라도 중간에 다른 누군가가 편지를 읽어도 내용을 알 수 없을 것이다.  
편지를 받은 빈은 처음에 무슨 말인지 알 수 없다. 하지만 빈에게 편지의 내용을 10과 XOR 연산해보라고 하면 마법처럼 원본 코드였던 76 79 86 69가 복원된다. 이렇게 "LOVE"라는 문자열에 감동한 빈은 당신과의 결혼을 결심했다.   
참고로 위와 같은 상황에서 암호화 및 복호화에 사용한 값(10)을 암호 키라고 하며, 암호화와 복호화에 같은 암호 키를 사용하는 알고리즘을 대칭 키 암호라고 한다.  

예제를 통해 XOR의 마법을 체험해보도록 하자.

```c
// bitwise_xor.c
#include <stdio.h>

int main(void)
{
    int a = 0b10101010;     // 170
    int b = 0b10011001;     // 153

    printf("%d \n", a ^ b);
    printf("\n");

    char ch1 = 'L', ch2 = 'O', ch3 = 'V', ch4 = 'E';
    printf("%c%c%c%c\n", ch1, ch2, ch3, ch4);
    
    // 복합 대입 연산자를 사용하여 기존 값을 암호화
    ch1 ^= 10;
    ch2 ^= 10;
    ch3 ^= 10;
    ch4 ^= 10;
    printf("%c%c%c%c\n", ch1, ch2, ch3, ch4);

    // 복합 대입 연산자를 사용하여 변경된 값을 복호화
    ch1 ^= 10;
    ch2 ^= 10;
    ch3 ^= 10;
    ch4 ^= 10;
    printf("%c%c%c%c\n", ch1, ch2, ch3, ch4);

    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make bitwise_xor
cc     bitwise_xor.c   -o bitwise_xor
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./bitwise_xor 
51 

LOVE
FE\O
LOVE
```

> XOR 연산으로 이 외에도 다양한 마법을 부릴 수 있다. 대표적으로 두 정수 변수에 저장된 값을 서로 바꿀 수 있는데, 이러한 내용도 추후에 다시 알아보도록 하자.

여태까지 비트 연산자들에 대해 학습했다. 그런데 비트 AND, OR, XOR 연산자는 산술 연산자와 비교하여 신경써야 하는 내용이 있다. 바로 연산자의 우선 순위이다.  
산술 연산자를 관계 연산자나 동등 연산자와 같이 사용한다고 가정해보자. ```a + 3 == 5```와 같은 식은 변수 ```a```에 3을 더한 값이 5와 같은지 판단한다. ```+``` 연산자의 우선순위가 ```==``` 연산자의 우선순위보다 높기 때문에 굉장히 자연스럽게 읽을 수 있다.  
이번엔 비트 OR 연산자를 동등 연산자와 같이 사용한다고 가정해보자. ```a | 3 == 5```가 어떻게 평가될까? 프로그래머는 아마도 변수 ```a```와 3을 비트 OR 연산한 결과가 5와 같은지 판단하려고 했을 것이다. 하지만 안타깝게도 위 식의 결과는 뜬금없이 변수 ```a``` 된다. 왜냐면 ```|``` 연산자의 우선순위가 ```==``` 연산자의 우선순위보다 낮기 때문이다.  
원래 위의 식의 의도를 괄호를 통해 표현하면 ```(a | 3) == 5``` 이었을 것이다. 하지만 ```==``` 연산자의 우선 순위가 더 높기 때문에 실제로 ```a | (3 == 5)```로 평가된다. ```3 == 5```의 결과는 0(거짓)이므로, 위 식은 ```a | 0```이 되어 결국 변수 ```a```에 저장되어 있던 값이 된다.  

비트 AND, OR, XOR 연산자는 관계 연산자, 동등 연산자보다 우선 순위가 낮다. 대체 왜 이렇게 만들었을까? 이 문제에는 C언어의 역사가 얽혀있다.  
관계 연산자나 동등 연산자는 자주 논리 연산자와 함께 사용된다. 예를 들어, ```a == 5 && b == 3```는 변수 ```a```는 5이고, 변수 ```b```는 3인지 판단한다. ```a == 1 || b == 1```은 변수 ```a```가 1이거나, 변수 ```b```가 1인지 판단한다. 논리 연산자가 관계 연산자, 동등 연산자보다 우선 순위가 낮기 때문에 자연스럽게 위와 같이 쓸 수 있다.  
그런데 C언어의 초기에는 ```&&``` 연산자와 ```||``` 연산자가 존재하지 않았다. 대신, ```&``` 연산과 ```|``` 연산이 경우에 따라 다르게 해석되었다. 일반적인 연산 식에서는 비트 AND, 비트 OR 연산자로 해석되었고, 논리적인 제어가 필요한 식(주로 곧 배울 ```if``` 문의 제어식)에서는 논리 AND, 논리 OR 연산자로 해석되었다. ```&``` 연산자와 ```|``` 연산자가 제어 식에서는 논리 연산자로 사용되었기 때문에 당시에 해당 연산자의 우선 순위가 관계 연산자나 동등 연산자보다 낮아야 했다.  
그런데 C언어가 발전하면서 ```&&``` 연산자와 ```||``` 연산자가 새로 생겼고 이들이 논리 연산자를 담당하게 되었다. 기존에 사용하던 ```&``` 연산자와 ```|``` 연산자는 오직 비트 연산에만 사용하게 되었다. 그러면 이 때 비트 연산자의 우선순위를 관계연산자나 동등연산자보다 높이도록 변경했으면 되는 문제가 아니었을까? 아쉽게도 이미 기존에 작성한 코드들이 문제였다. 갑자기 연산자 우선순위가 변경되면 기존에는 잘 동작하던 코드들에 문제가 생길 수 있다. 이러한 문제로 비트 AND, OR, XOR 연산자는 그대로 관계 연산자나 동등 연산자보다 낮은 우선순위를 가지게 되었고, 새로운 논리 연산자들은 이 비트 연산자들보다 더 낮은 우선 순위를 가지게 되었다.  

그러면 C언어에서 코드를 작성할 때 위와 같은 내용들에 대해서 어떻게 유의할 수 있을까? 곧 있으면 연산자 우선순위 정리 절에서 다시 이야기하겠지만 복잡한 식은 괄호를 통해서 연산 순서를 지정해주는 것이 좋다. 특히나 관계 및 동등 연산자가 쓰이는 식에서 비트 연산자를 사용한다면 괄호를 필수적으로 사용해줘야 한다. 이는 실수하기 쉬운 내용이니 주의하도록 하자.  

## sizeof 연산자

sizeof 연산자는 피연산자의 크기를 계산하는 연산자이다. 아래 예시와 같이 사용할 수 있는데, 주석에 있는 결과는 ```int``` 타입이 4바이트이고, ```double``` 타입이 8바이트인 시스템에서의 결과 값이다.  

```c
// int 타입은 4바이트, double 타입은 8바이트인 시스템이라고 가정
char c;
int i;
double f;

sizeof(char);       // 1
sizeof(int);        // 4
sizeof(double);     // 8

sizeof c;           // 1
sizeof i;           // 4
sizeof f;           // 8
sizeof(c);           // 1
sizeof(i);           // 4
sizeof(f);           // 8

sizeof 5;           // 5는 int 타입으로 4
sizeof 3.14;        // 3.14는 double 타입이므로 8
sizeof(5);          // 마찬가지로 4
sizeof(3.14);       // 마찬가지로 8
```

```sizeof``` 연산자의 피연산자로는 식이나 타입 정보가 올 수 있다. 피연산자로 타입 정보가 올 때는 ```sizeof(int)```와 같이 피연산자를 항상 괄호로 감싸줘야 한다. 피연산자로 식이 온다는 것은 ```sizeof```의 피연산자로 여태까지 배운 연산자들을 조합하여 만든 식을 쓸 수 있다는 것이다. 하지만 여러 연산자들을 조합하여 만든 복잡한 식을 사용하는 경우는 드물고, 보통 위 예시와 같이 변수나 상수같은 것들을 단독으로 사용한다.  

위 예시에서 보는 것과 같이 피연산자로 식이 오는 경우엔 피연산자를 괄호로 감싸주지 않아도 된다. 하지만 모든 식은 원래 괄호로 자신을 감싸줄 수 있다. 예를 들어서 ```3 + 5 * 2```라는 식이 있을 때, ```a = 3 + 5 * 2```와 같이 사용할 수도 있고, ```a = (3 + 5 * 2)```와 같이 사용할 수도 있다. 이와 동일하게 ```sizeof```의 피연산자로 ```sizeof i```와 같이 사용할 수도 있고 ```sizeof(i)```와 같이 사용할 수도 있다. 일반적으로 ```sizeof``` 연산자의 피연산자는 가독성을 위해서 항상 괄호로 감싸주고는 한다.  
그렇다면 그냥 ```sizeof```는 항상 피연산자에 괄호를 사용한다고 가르치면 될 것을 왜 이렇게 복잡하게 설명하느냐고 따질 수도 있을 것이다. 하지만 위와 같은 사실로 인해 피연산자로 타입이 올 때는 식이 올 때와 달리 형태가 고정된다.  
예를 들어, ```(3 + 5 * 2)```와 ```(((3 + 5 * 2)))```는 같은 식으로 평가되기 때문에 ```sizeof(((3 + 5 * 2)))```와 같이 쓸 수도 있다. 하지만 ```sizeof((int))```와 같이 사용할 수는 없다. 물론, ```sizeof int```와 같이 사용할 수도 없다. 피연산자로 타입이 오는 경우엔 오로지 하나의 괄호만 사용되어야 한다.  

피연산자로 식이 오는 경우 한 가지 중요한 사실이 있다. 바로 식이 평가되지 않는다는 것이다. 해당 설명으로 바로 이해가 가면 불세출의 천재일 것이므로, 쉽게 예시를 보자.  

```c
int i = 0;
i++;        // 평가 됨
printf("%d \n", i);     // 이 전 문장에서 i가 증가하여 1

i = 0;
sizeof(i++);        // i++가 평가되지 않음
printf("%d \n", i);     // 이 전 문장에서 i가 증가하지 않아서 0
```

이 외에도 논리 연산자를 설명할 때 잠시 함수 호출 또한 연산자라고 했으므로, 다음과 같은 상황을 생각할 수도 있다.  

```c
sizeof(printf("Hello"));
```

위와 같은 문장을 실행하면 어떻게 될까? 우선 ```sizeof```의 피연산자는 평가되지 않는다고 했다. 따라서, ```printf``` 함수는 호출되지 않고 Hello는 출력되지 않는다. 그러면 ```sizeof```의 결과 값은 무엇일까? 바로 ```printf``` 함수의 반환 타입의 크기가 된다. 반환 타입이 무엇인지는 함수 챕터에서 다시 설명하겠지만, 우리가 여태까지 작성한 ```main``` 함수의 반환 타입이 ```int``` 였던 것처럼 ```printf``` 함수에도 무엇인가 반환 타입이 있다고 생각하면 된다. 위와 같이 ```sizeof``` 연산자의 피연산자로 함수 호출을 하는 경우 피연산자가 평가되지 않기 때문에 실제로 함수 호출이 발생하지는 않고, 해당 함수의 반환 타입의 크기를 결과 값으로 가지게 된다. 물론 이는 ```sizeof``` 연산자의 피연산자가 평가되지 않는 다는 것을 알리기 위한 예제이며, 실제 프로그램에서 피연산자로 함수 호출을 사용하지는 않는다.  

어째서 위와 같은 상황이 발생할까? ```sizeof``` 연산자는 런타임이 아닌 컴파일 타임에 피연산자의 타입을 추론하여 그 크기를 계산한다. 따라서 런타임(실행 시간)에 피연산자의 내용을 평가할 필요가 없는 것이다. 한 가지 예외가 있는데 피연산자로 가변 길이 배열이 사용될 때이다. 가변 길이 배열은 추후에 배울 것이지만 사용을 지양하는 것이 좋으므로, 크게 신경 쓸 필요는 없다. 아무튼 중요한 것은 ```sizeof```의 피연산자가 평가되지 않는다는 것이다. 그런데 이 사실을 모르는 동료 개발자가 ```sizeof``` 연산자의 피연산자로 사이드 이펙트가 발생하는 복잡한 식을 사용한 코드를 보면 어떻게 생각할까? 굉장한 혼란을 초래할 것이다. 따라서 ```sizeof``` 연산자의 피연산자에는 복잡한 식을 지양하고 단일 변수나 단일 상수와 같은 간단한 식만 사용하는 것이 좋다.  

```sizeof``` 연산자가 피연산자의 크기를 구한다는 것은 알았다. 그러면 피연산자로 어떤 타입이나 어떤 식이든 올 수 있을까? 그렇지 않다. ```sizeof``` 연산자가 컴파일 타임에 타입의 크기를 계산한다고 하였다. 하지만 ```sizeof``` 연산자가 사용된 당시에 피연산자 타입의 크기를 결정할 수 없는 경우는 어떻게 될까? 이런 경우는 미정의 행위가 된다. 타입의 크기가 아직 결정되지 않은 타입을 불완전한(incomplete) 타입이라고 하는데, 이에 대한 내용은 주로 배열이나 구조체나 공용체 단원에서 배울 것이다. 참고로, ```main``` 함수의 인자로 사용하고 있는 ```void```도 불완전한 타입 중 하나이다. 이러한 타입들은 ```sizeof```의 피연산자로 사용하면 안 된다.  

> 추가로 ```sizeof``` 연산자의 피연산자에 배열, 구조체, 공용체가 오는 경우 해당 오브젝트의 크기를 산출하는데 이는 해당 챕터에서 다시 알아보도록 한다.

참고로 ```sizeof``` 연산자의 결과는 실행 환경에 따라 다르다. 변수 챕터의 정수 타입 지정자 파트에서 설명한 것과 같이 타입들의 크기가 실행 환경에 따라 다르기 때문이다. 오로지 ```char```, ```unsigned char```, ```signed char``` 타입만이 ```sizeof``` 연산의 결과가 1로 정해져 있다.  

이제 예제를 통해 위 내용들을 점검하도록 하자.

```c
// sizeof_operator.c
#include <stdio.h>

int main(void)
{
    char c;
    int i;
    double f;

    printf("sizeof(char) : %ld \n", sizeof(char));
    printf("sizeof(int) : %ld \n", sizeof(int));
    printf("sizeof(double) : %ld \n", sizeof(double));

    printf("sizeof(c) : %ld \n", sizeof(c));
    printf("sizeof(i) : %ld \n", sizeof(i));
    printf("sizeof(f) : %ld \n", sizeof(f));

    printf("sizeof(5) : %ld \n", sizeof(5));
    printf("sizoef(3.14) : %ld \n", sizeof(3.14));

    i = 0;
    i++;
    printf("i : %d \n", i);

    i = 0;
    sizeof(i++);        // 평가 되지 않음
    printf("i : %d \n", i);
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make sizeof_operator
cc     sizeof_operator.c   -o sizeof_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./sizeof_operator 
sizeof(char) : 1 
sizeof(int) : 4 
sizeof(double) : 8 
sizeof(c) : 1 
sizeof(i) : 4 
sizeof(f) : 8 
sizeof(5) : 4 
sizoef(3.14) : 8 
i : 1 
i : 0 
```

## 조건 연산자

조건 연산자(Conditional Operator)는 조건에 따라 다른 결과 값을 산출할 때 사용하는 연산자이다. 조견 연산자는 세 개의 피연산자를 가지기 때문에 삼항 연산자라고도 불리며, 다음과 같은 형태로 사용한다.  

```c
expression ? expression : expression
```

위와 같이 ```? :``` 기호를 사용한다. 첫 번째 피연산자의 식의 결과 값이 0이 아닌 경우(참인 경우) 두 번째 식을 평가하여 그 결과 값을 가지며, 첫 번째 피연산자의 식의 결과 값이 0인 경우(거짓인 경우) 세 번째 식을 평가하여 그 결과 값을 가진다. 예시를 들면 다음과 같다.  

```c
int i = 0, j = 0, k, a;

k = a ? i++ : ++j;  // a가 0이 아닌 경우 i++가 평가되며 a가 0인 경우 ++j가 평가된다.
                    // k의 값은 a가 0이 아닌 경우 i++의 결과 값인 0, a가 0인 경우 ++j의 결과 값인 1이 된다.
// a가 0이 아닌 경우 i만 1이 되며, a가 0인 경우 j만 1이 됨
```

조건 연산자의 사용에 주의할 점은 무엇이 있을까? 우선 첫 번째 피연산자가 0인지 아닌지에 따라 두 번째 피연산자와 세 번째 피연산자의 식 중 하나만 평가된다. 그 외에는 피연산자들의 타입에 대해서만 신경쓰면 된다.  
우선 첫 번째 피연산자가 0인지 아닌지에 따라 결과가 정해진다고 했다. 그러려면 첫 번째 피연산자는 0이거나 0이 아닌 값으로 평가가 가능한 식이어야 한다. 따라서 aggregate 타입이 아닌 scalar 타입이어야 한다. aggregate 타입과 scalar 타입은 추후에 배울 개념이므로 지금 알아들을 수가 없다. 하지만 걱정하지 않아도 된다. 조건 연산자의 첫 번째 피연산자에는 주로 사용하는 패턴이 있으므로, 해당 패턴만 알아도 사용하는데 무리가 없다. 첫 번째 피연산자로 단일 변수이거나 관계 연산자, 동등 연산자, 논리 연산자를 사용하여 만든 조건을 나타내는 식을 주로 사용한다. 예를 들어 ```a > 3 ? <참일 경우 평가할 식> : <거짓일 경우 평가할 식>``` 과 같이 사용한다. 위와 같이 사용하면 첫 번째 피연산자로 사용된 식이 참인지 거짓인지에 따라 평가할 식이 자연스럽게 결정된다.  
그리고 확인할 부분은 두 번째 피연산자와 세 번째 피연산자의 타입이다. 두 피연산자의 타입이 호환이 되어야 한다. ```k = <조건식> ? a : b;```와 같이 사용할 때 ```a``` 와 ```b```의 타입이 호환되지 않으면 ```k```에 대입할 값의 타입이 올바른지 판단할 수 없을 것이다. 엄밀하게 이야기하면 두 번째 피연산자와 세 번째 피연산자가 둘 다 산술(arithmetic) 타입이거나, 둘 다 같은 구조체/공용체 타입이거나, 둘 다 ```void``` 타입이거나, 둘 다 포인터 타입이거나 등의 조건이 있다. 하지만 이러한 내용은 C언어의 문법을 이미 알고 있어야 이해할 수 있다. 지금은 단순히 두 번째 피연산자와 세 번째 피연산자의 식의 결과가 호환할 수 있는 타입이어야 한다고 생각하자.  
마지막으로 조건 연산자의 ```?```는 시퀀스 포인트이다. 즉, 첫 번째 피연산자 식과 두 번째 혹은 세 번째 피연산자의 식은 시퀀스된다. 예를 들어 ```i++ ? ++i : i += 2``` 와 같이 사용할 수 있다. 물론, 두 번째 피연산자 식과 세 번째 피연산자의 식은 둘 중 하나만 평가되므로 같은 오브젝트에 대한 사이드 이펙트가 발생해도 무관하다.  

참고로 조건 연산자를 사용하여 작성한 코드는 대부분 선택문 챕터에서 배울 ```if-else``` 문으로 변경하여 작성할 수 있다. 대부분의 경우 ```if-else``` 문을 사용하여 코드를 작성하는 것이 조건 연산자를 사용하는 것보다 가독성이 좋기 때문에 ```if-else``` 문을 선호하는 편이다. 조건 연산자는 코드를 짧게 작성하는 것이 필요한 경우 주로 사용된다.  

다음 예제를 통해 조건 연산자의 동작을 확인하도록 하자.

```c
// conditional_operator.c
#include <stdio.h>

int main(void)
{
    int a = 0;
    int i = 0, j = 0;
    int r1, r2;

    r1 = a < 10 ? i++ : ++j;    // a가 10보다 작다면 i++가 평가되고, 10보다 같거나 크면 ++j가 평가됨
    printf("r1 : %d, i : %d, j : %d\n", r1, i, j);

    r2 = a >= 10 ? i++ : ++j;   // a가 10보다 크거나 같으면 i++가 평가되고, 작으면 ++j가 평가됨
    printf("r2 : %d, i : %d, j : %d\n", r2, i, j);

    return 0;
}
```

실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make conditional_operator
cc     conditional_operator.c   -o conditional_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./conditional_operator 
r1 : 0, i : 1, j : 0
r2 : 1, i : 1, j : 1
```

## 기타 연산자

여태까지 C언어에서 사용하는 대부분의 연산자들을 학습했다. 아직 C언어에서 지원하는 연산자들이 몇 가지 더 있는데, 이들은 사용법이 굉장히 쉽거나, 추후에 배울 개념들을 알아야해서 지금 당장 학습할 수 없다. 해당 파트에서는 이러한 연산자들에 대해 간단하게 설명하고 넘어갈 것이며, 관련된 챕터에서 다시 학습할 예정이다.   

### 타입 캐스트 연산자

피연산자의 결과 값을 특정한 타입으로 변환하는 연산자이다. 다음과 같이 사용한다.  

```c
(type-name)expression
```

괄호에 변환하고 싶은 타입의 이름을 작성하면 된다. 예를 들어 ```(int)3.14```는 ```double``` 타입의 값 ```3.14```를 ```int``` 타입으로 변환하여 ```3```으로 만든다. ```(double)5```는 ```int``` 타입의 값 ```5```를 ```double``` 타입으로 변환하여 ```5.0```으로 만든다.  

이렇게 타입 캐스트 연산자를 사용하여 타입을 변환하는 경우를 명시적 타입 변환(Explicit Type Conversion) 혹은 명시적 형변환 이라고 한다.  
그런데 산술 연산자를 학습할 때 두 피연산자의 타입이 같지 않은 경우 손실이 최소화하는 방향으로 타입 변환이 발생한다고 하였다. C언어에서는 명시적으로 타입을 변환하지 않아도 이와 비슷한 다양한 상황에서 타입 변환이 발생한다. 이러한 타입 변환을 암시적 타입 변환(Implicit Type Conversion) 혹은 암시적 형변환 이라고 한다.  

### 컴마 연산자

컴마 연산자는 한 문장에서 여러 식을 분리하여 평가할 때 사용된다. 설명은 다소 어려울 수 있으나 사용은 굉장히 간단한다. ```a = 5, b = 3```과 같이 사용하면 된다. 컴마 연산자의 결과 값은 오른쪽 피연산자의 결과 값이 된다. 예시의 경우 컴마 연산자의 최종 결과 값은 ```b = 3```의 결과 값인 3이 된다.  
컴마 연산자는 시퀀스 포인트이며 왼 쪽의 피연산자 식이 먼저 평가되는 것이 보장된다. 따라서, ```a = 3, a + 2```와 같은 식을 사용할 수 있으며 해당 식의 결과 값은 5가 된다.  

우리가 여태까지 ```printf``` 함수에서 인자를 구분하기 위하여 사용한 ```,```는 컴마 연산자일까? 그것은 아니다. 함수 인자를 구분하기 위한 ```,```는 연산자가 아니라 구분을 위한 구두점일 뿐이다. 따라서 함수의 각 인자가 시퀀스된다고 생각하면 안 된다.  
함수 인자를 구분하기 위하여 ```,```를 사용하면 이는 컴마 연산자가 아닌 단순한 구두점이 된다고 했다. 그러면 함수 인자로는 컴마 연산자를 사용할 수 없을까? 한 가지 방법이 있다. 바로 괄호를 사용하여 식을 표현하는 것이다. 예를 들어서 ```printf("%d", (a = 3, a + 2))``` 라고 했을 때 ```"%d"```와 두 번째 인자를 구분하기 위한 ```,```는 구두점이며, ```(a = 3, a + 2)```에 있는 ```,```는 컴마 연산자이다. 따라서 위의 경우 변수 ```a```에 3이 대입된 후 ```a + 2```의 결과인 5가 출력될 것이다. 물론, 가독성 문제로 위와 같이 코드를 작성하지는 않는다.  
함수의 인자 외에도 어떠한 리스트의 아이템을 구분하기 위하여 ```,```가 사용되는 경우 이는 컴마 연산자가 아니다. 대표적으로 선언에서 변수를 구분하기 위하여 사용하는 ```,```는 컴마 연산자가 아니다.  

> 선언의 경우 ```,```가 컴마 연산자가 아니라 구분자이지만 선언자와 이니셜라이저의 끝이 시퀀스 포인트이다. 따라서 각 변수의 선언은 시퀀스된다.  

### 그 외

연산자이지만 추후에 배울 포인터나 구조체와 같은 개념들을 학습해야 이해할 수 있는 연산자들이다. 해당 연산자들의 구체적인 사용법은 관련된 챕터에서 학습할 예정이다. 아래와 같은 요소들도 연산자라는 것만 알고 있으면 된다.  

* 배열 첨자 연산자 : ```[]```
* 함수 호출 연산자 : ```()```
* 멤버 연산자 : ```.```, ```->```
* alignof 연산자 : ```alignof()```
* 주소 연산자 : ```&```
* 역참조 연산자 : ```*```
* 복합 리터럴 : ```(type){list}```

> 함수 호출과 연산자를 별도의 문법 요소로 생각하는 경우가 많으며 실제로 함수 호출을 하나의 문장(statement)으로 취급하는 언어도 있다. 하지만 C언어에서는 함수 호출도 연산자이다.  

## 식의 평가

### 연산자 우선순위

| 순위(Precedence) | 연산자(Operator) | 설명 | 결합 방향(Associativity) |
|:-----:|:-----|:--------|:---------|
| 1 | ```(expression)``` | 식 괄호 | |
| 2 | ```[]``` <br> ```()``` <br> ```.``` <br> ```->``` <br> ```++``` ```--``` <br> ```(type){list}``` | 배열 첨자 연산자 <br> 함수 호출 연산자 <br> 멤버 접근 연산자 <br> 멤버 포인터 접근 연산자 <br> 후위 증감 연산자 <br> 복합 리터럴 | Left-to-right |
| 3 | ```++``` ```--``` <br> ```+``` ```-``` <br> ```!``` <br> ```~``` <br> ```*``` <br> ```&``` <br> ```sizeof``` <br> ```alignof``` | 전위 증감 연산자 <br> 단항 부호 연산자 <br> 논리 NOT 연산자 <br> 비트 NOT 연산자 <br> 역참조 연산자 <br> 주소 연산자 <br> sizeof 연산자 <br> 정렬 요청 연산자 | Right-to-left |
| 4 | ```(type)``` | 타입 캐스트 연산자 | Right-to-left |
| 5 | ```*``` ```/``` ```%``` | 곱하기, 나누기, 나머지 연산자 | Left-to-right |
| 6 | ```+``` ```-``` | 더하기, 빼기 연산자 | Left-to-right |
| 7 | ```<<``` ```>>``` | 비트 쉬프트 연산자 | Left-to-right |
| 8 | ```<``` ```<=``` ```>``` ```>=``` | 관계 연산자 | Left-to-right |
| 9 | ```==``` ```!=``` | 동등 연산자 | Left-to-right |
| 10 | ```&``` | 비트 AND 연산자 | Left-to-right |
| 11 | ```^``` | 비트 XOR 연산자 | Left-to-right |
| 12 | ```\|``` | 비트 OR 연산자 | Left-to-right |
| 13 | ```&&``` | 논리 AND 연산자 | Left-to-right |
| 14 | ```\|\|``` | 논리 OR 연산자 | Left-to-right |
| 15 | ```? :``` | 조건 연산자 | Right-to-left |
| 16 | ```=``` <br> ```+=``` ```-=``` <br> ```*=``` ```/=``` ```%=``` <br> ```<<=``` ```>>=``` <br> ```&=``` ```^=``` ```\|=``` | 대입 연산자 <br> 더하기, 빼기 복합 대입 연산자 <br> 곱하기, 나누기, 나머지 복합 대입 연산자 <br> 비트 쉬프트 복합 대입 연산자 <br> 비트 AND, XOR, OR 복합 대입 연산자 | Right-to-left |
| 17 | ```,``` | 컴마 연산자 | Left-to-right |

### 하위 식 평가

## 식 문장

