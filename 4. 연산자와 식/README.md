# 연산자와 식

C언어에서 식(expression)은 가장 중요한 요소 중 하나이다. C언에서 식이란 값을 계산하기 위한 연산자와 피연산자의 나열, 오브젝트, 함수, 사이드 이펙트 발생들이 조합되는 것을 의미한다. 사실 식에 대한 개념은 굉장히 쉽게 공부할 수도 있다. 필요한 개념을 배우지 않고, 잘못된 개념으로 학습한다면이라는 가정이 붙으면 그렇다. 여섯 살 아이에게 설명할 수 없다면 그 개념을 이해하지 못한 것이라는 아인슈타인의 어록에 숨어서 무조건 쉽게 설명한다면 좀 더 대중적으로 환영받는 책이 될 수 있겠지만, 해당 서적은 처음엔 조금 어렵게 느껴지더라도 이해하고 나면 정확한 개념들을 숙지할 수 있도록 하는 것을 지향하고 있다. 따라서 해당 챕터의 내용들에 어렵다고 느껴지는 내용들이 나오더라도 좌절하지 말자. 처음엔 어렵게 느껴지겠지만 극복하기만 하면 잘못된 코드를 분간하는 능력을 갖출 수 있을 것이다. 그러기 위해 연산자와 식을 본격적으로 공부하기 전 사전 지식들을 알아보자.

* 사이드 이펙트(side effect) : 오브젝트를 수정하거나, 파일을 수정하거나, volatile 오브젝트에 접근하거나, 앞의 세 행위 중 하나 이상을 수행하는 함수를 호출하여 프로그램의 상태가 변경되는 것을 말한다. 간단하게 변수 a에 새로운 값 3을 대입하는 것도 사이드 이펙트이다. ```printf``` 함수를 호출했을 때 화면에 문자열이 출력되는 것도 터미널 상태를 수정하는 사이드 이펙트이다.  
* 평가(Evaluation) : 식의 값을 계산하거나 사이드 이펙트가 시작하는 것을 의미한다. ```3 + 4``` 라는 식을 평가하면 ```7``` 이라는 결과 값이 나온다. 변수 ```a```에 3을 대입하는 ```a = 3``` 라는 식을 평가하면 ```3``` 이라는 결과 값이 나오면서 ```a```에 3을 대입하는 사이드 이펙트가 시작된다.
* 시퀀스(Sequence) : 문맥에 따라 나열이라는 의미 혹은 순서라는 의미를 가질 수 있다. 이스케이프 시퀀스나 문자 시퀀스에서 사용하는 시퀀스는 문자들이 나열된다는 의미이다. 평가에 대한 시퀀스라고 할 때는 순서를 의미한다. A와 B라는 두 평가가 있을 때, A가 B보다 전에 시퀀스된다라고 하면 A가 B보다 늦게 실행되는게 보장된다는 뜻이다. 반면 A와 B 두 평가의 순서가 보장되지 않을때는 A와 B가 시퀀스되지 않는다(unsequenced)라고 한다. (주로 A와 B가 동시에 실행될 수 있는 경우를 의미한다.) 마지막으로 A와 B의 평가가 동시에 수행되지 않는 것은 보장되지만 둘 중 어떤 것이 먼저 평가될지는 정해지지 않는 것을 비결정적인 시퀀스(indeterminately sequenced)라고 한다. 해당 개념이 어렵다면 식이나 평가라는 단어와 함께 시퀀스가 사용되는 경우 순서 보장을 의미한다는 것만 알아두자.
* 시퀀스 포인트(Sequence point) : 이 전에 평가한 식에서 발생한 사이드 이펙트가 모두 완료되는 지점을 의미한다. A와 B 사이에 시퀀스 포인트가 있다고 하면 A와 관련된 모든 연산과 사이드 이펙트에 대한 완료가 B에 관련된 연산과 사이드 이펙트보다 먼저 시퀀스된다는 것을 의미한다. C언어에 있는 시퀀스 포인트들을 여기서 설명해도 제대로 이해할 수 없으므로, 우선 문장을 종료하기 위한 ```;```가 시퀀스 포인트 역할을 한다고 생각하고 엄밀한 내용은 필요할 때 부록을 찾아보도록 하자.

사전적인 의미는 언제나 어렵다. 조금 쉽게 설명하면 변수에 저장되어 있는 값이 변경되는 것과 같이 프로그램의 상태가 변경되는 것을 사이드 이펙트라고 한다. 그리고 식을 평가하면 식에 포함되어 있는 연산을 수행하여 결과 값이 나온다. 이 때 연산 과정에서 사이드 이펙트가 존재한다면 평가 시 사이드 이펙트가 시작된다. 그리고 이 사이드 이펙트는 시퀀스 포인트 전 어디에서나 수행될 수 있으며, 시퀀스 포인트 다음으로 넘어가기 전에 완료가 보장되는 것이다.

위의 내용을 대략적으로 이해했다면 연산자와 식을 학습하기 위한 기본적인 사전 지식 준비는 완료되었다. 그런데 이 전 챕터에서 미정의 행위라던지 implemention-defined 라던지 하는 용어들이 자꾸 등장했던 것을 기억할 것이다. 앞으로도 해당 용어들이 자주 등장할 예정이므로, 이와 관련된 용어들도 살펴보도록 하자.

* 미정의 행위(undefined behavior) : 프로그램의 이식성을 해치거나 에러를 발생시키는 등 표준에서 정의되지 않은 행위를 하는 것이다. 미정의 행위를 실행하면 예측할 수 없는 결과를 초래하거나 컴파일 및 실행 중 종료 등의 결과를 초래할 수 있다.
* 미지정 행위(unspecified behavior) : 정의되지 않는 값을 사용하거나 정의되지 않은 행동을 하는 등 표준에서 두 개 이상의 결과를 초래할 수 있는 행위에 대해 결정하지 않은 행동을 하는 것이다.  
* implementation-defined behavior : 환경에 따라 특정 구현이 정의되어 있는 미지정 행위이다.  

쉽게 이야기해서 미정의 행위는 해당 코드의 결과가 어떻게 될 지 아예 정해지지 않은 행위이고, 미지정 행위는 해당 코드의 결과로 여러 결과 중 하나가 나올 수 있는 행위이며, implementation-defined behavior는 미지정 행위의 여러 결과 중 어떤 결과가 나올 것인지 실행 환경에 따라 결정이 되어 있는 행위를 의미한다.  
C23에서 정의한 200개 이상의 미정의 행위와 약 50개의 미지정 행위가 있다. 미정의 행위와 미지정 행위에 의존한 코드를 작성하는 것은 절대적으로 지양해야 한다.  
그렇다면 C언어 프로그램을 작성하기 위해서는 약 250개의 항목들을 전부 암기하고 있어야 할까? 물론 그렇지는 않다. 위 항목들을 살펴보다 보면 상식적인 프로그래머라면 생각이나 시도조차 하지 않을 항목들도 포함하고 있다. 하지만 중간중간 시도해봄직한 코드지만 미정의 행위의 항목에 포함되어 있는 경우도 있다. 그리고 이러한 코드가 인터넷 상에서 어째서 코드의 결과가 이렇게 되었는지 토론의 대상이 되고는 한다. 하지만 사실 이러한 토론들은 전부 의미가 없다. 미정의 행위의 결과는 정해져 있지 않고 언제든지 바뀔 수 있으며 심지어 미정의 행위로 인해서 컴퓨터가 폭발하더라도 이는 프로그래머의 잘못이기 때문이다.  
해당 서적에서는 이렇게 혼란을 줄 수 있는 미정의 행위나 미지정 행위들을 기피할 수 있도록 안내할 것이며, 거기에 더해 카네기 멜론 대학에서 발표한 미정의 행위와 미지정 행위를 피하는 안전한 프로그램 작성 가이드를 부록에서 소개할 것이다.  
참고로, 한 오브젝트에 대해 시퀀스 포인트 이 전에 서로 다른 사이드 이펙트가 발생하는 것과, 사이드 이펙트가 발생한 오브젝트를 같은 식의 다른 하위 식에서 사용하는 것은 대표적인 미정의 행위다. 예를 들어 ```i = ++i + 1```과 같은 식을 들 수 있는데, 해당 식의 결과 변수 ```i```에 어떤 값이 저장되는 지에 대한 토론이 종종 발생하지만 이는 미정의 행위이기 때문에 의미 없는 토론이다.

## 연산자와 구두점

C언어에서 같은 기호가 여러 역할을 수행한다는 것을 인지하지 못할 때 혼란을 겪고는 한다. 예를 들어 ```-``` 기호가 두 개의 피연산자를 가질 때 뺄셈 연산자가 되지만, 하나의 피연산자를 가지면 음수 기호 지정을 위한 단항 연산자가 된다. 좀 더 쉽게 표현하면 ```4 - 2```는 4 빼기 2를 의미하고, ```-3```은 마이너스 3을 의미한다. 이처럼 같은 기호가 상황에 따라 다른 의미와 역할을 가질 수 있다. 이러한 내용을 이해하기 위해서 우선 구두점이 무엇인지 알아야 한다.  

구두점(Punctuator)은 소스 코드에서 문법적(syntax), 의미적(semantic)으로 독립적인 기호를 뜻한다. 정의는 어렵지만 구두점의 종류를 보면 쉽게 이해할 수 있다. C언어에 있는 구두점은 다음과 같다.

```c
[ ] ( ) { } . ->
++ -- & * + - ~ !
/ % << >> < > <= >= == != ^ | && ||
? : :: ; ...
= *= /= %= += -= <<= >>= &= ^= |=
, # ##
<: :> <% %> %: %:%:
```

그리고 이 구두점은 문맥에 따라 연산자가 될 수도 있고, 단순히 문법적인 요소를 구분하기 위하여 사용할 수도 있다. 예를 들어 다음 예제에서 ```=``` 와 ```,``` 는 서로 다른 역할을 한다.

```c
int a = 3, b = 5;   // =와 ,가 문법 구분을 위한 구두점으로 쓰임

a = 5, b = 3;       // = 와 , 가 각각 대입 연산자와 컴마 연산자임
```

해당 내용을 잘 인지하고 있으면 추후에 배울 배열과 포인터 챕터가 악명과 달리 쉽게 다가올 수 있을 것이다.

## 산술 연산자

기본적인 더하기, 빼기, 곱하기, 나누기와 같은 산술 연산을 수행하기 위한 연산자이다. 다음과 같은 연산자들이 있다.

| 연산자 | 설명 |
|:-----:|:-----:|
| + | 더하기(Addition) 연산자 <br> 단항 양수(Unary Plus) 연산자 |
| - | 빼기 연산자(Subtraction) <br> 단항 음수(Unary Minus) 연산자 |
| * | 곱하기(Multiplication) 연산자 |
| / | 나누기(Division) 연산자 |
| % | 나머지(Remainder) 연산자 |

```+```와 ```-```는 항의 개수에 따라 다른 연산자가 될 수 있다. 예를 들어, ```+a```와 ```a + b``` 에서의 ```+```는 서로 다른 연산자이다.  
곱하기와 나누기는 ```×```와 ```÷``` 기호가 키보드로 입력하기 쉽지 않아서 ```*```와 ```/``` 기호를 대신 사용한다.  
나머지 연산의 결과는 나누기 연산을 했을 때 나머지 값이다. 예를 들어 ```12 % 5```의 결과는 12 나누기 5의 나머지인 2이며, ```16 % 4```의 결과는 16 나누기 4의 나머지인 0이다.  

여기까지는 초등학교 수학 시간에 배운 사칙 연산과 다르지 않아서 어렵지 않다. 하지만 주의해야할 점이 있다. 연산 결과 타입에 대해 신경쓰지 않으면 원하는 것과 다른 결과가 발생할 수 있다.  

연산 식의 결과 타입은 피연산자의 타입에 의해 결정된다. 단항 연산자와 같이 피연산자가 하나라면 피연산자의 타입이 곧 결과 타입이 된다. 사칙 연산들과 같이 피연산자가 두 개인 이항 연산자들은 조금 복잡하다. 두 피연산자의 타입이 같다면 해당 타입이 되고, 두 피연산자의 타입이 다르다면 최대한 값 손실이 잃어나지 않도록 결과 타입을 생성한다.  
예를 들어 3 + 4는 두 피연산자가 전부 정수 타입이기 때문에 결과도 정수 타입이 된다. 하지만 3.5 + 3의 피연산자는 하나가 실수이고 하나가 정수이다. 이 때 결과 타입이 정수라면 6.5를 표현할 수 없기 때문에 0.5라는 값이 버려지고 6이 될 것이다. 이러면 값 손실이 발생한다. 따라서 하나의 피연산자가 실수면 결과 타입은 실수 타입이 된다. 3.5 + 3의 경우 결과 값 6.5인 실수 타입이 되는 것이다.  
그런데 이 전 챕터에서 공부한것과 같이 정수 타입 내에도 여러 타입이 있고, 실수 타입 내에도 여러 타입이 있다. 연산 식의 결과 타입은 해당 타입들 중 손실이 최대한 발생하지 않는 타입이 되는 것이다. 결과가 정확히 어떤 타입이 되는지는 조금 복잡하므로, 해당 챕터의 후반부에서 알아보도록 하자.  

그렇다면 ```7 / 2```의 결과는 어떻게 될까? 사칙 연산 상으로 결과는 3.5여야 한다. 하지만 잘 보면 두 피연산자가 모두 똑같은 정수 타입이다. 이러면 결과 타입도 정수 타입이 될 수 밖에 없다. 따라서 ```7 / 2```의 결과는 3.5가 아닌 3이 된다. 만약 3.5라는 결과를 얻고 싶다면 두 피연산자중 적어도 하나를 실수 타입으로 지정해야 한다. ```7.0 / 2```, ```7 / 2.0```, ```7.0 / 2.0``` 과 같이 식을 쓰면 3.5라는 결과를 얻을 수 있다.  

이번엔 ```7.0 % 2.0```의 결과를 생각해보자. 실수의 나누기에서는 나머지가 발생하지 않는다. 그러면 실수 피연산자에 대한 나머지 연산은 항상 결과가 0이 나올까? 아쉽게도 그렇지는 않다. 나머지 연산자의 경우 두 피연산자가 모두 정수 타입만 올 수 있다. 나머지 연산자의 피연산자로 실수 타입이 오게 되면 컴파일 에러를 발생시킨다.  

음수의 나눗셈은 어떤 결과를 보일까? ```-10 / 6```은 -1일까 -2일까? ```-10 % 6```은 -4일까 2일까? C89를 사용한다면 이는 이번 챕터 초반에서 학습했던 Implementation-defined 이다. C99에서는 나누기의 결과가 0에 가까운 쪽으로 고정된다. 따라서 C99라면 나누기의 결과는 -1이며 나머지는 -4가 된다.  

여기까지 산술 연산자의 기본적인 내용을 살펴봤다. 그런데 사칙 연산에서도 그렇듯이, 여러 개의 연산자가 조합된 식을 만들 수도 있다. 예를 들어 ```3 + 5 * 4```와 같은 식을 만들 수 있다. 이 때 연산 순서가 어떻게 될까? 3과 5를 먼저 더하고 그 결과에 4를 곱할까 아니면 5와 4를 먼저 곱하고 그 결과에 3을 더할까?  
이렇게 복잡한 식에서 연산 순서를 결정하는 것이 연산자의 우선 순위(precedence)와 결합 방향(associativity)이다.  
우리가 일반적으로 사칙 연산을 할 때 곱하기와 나누기를 더하기와 빼기보다 먼저 수행한다. 이와 같이 곱하기, 나누기, 나머지 연산자가 더하기와 빼기 연산자보다 더 높은 우선순위를 갖는다. 그리고 단항 연산자는 곱하기, 나누기, 나머지 연산자보다 높은 우선순위를 갖는다. 즉, ```3 + 5 * -2```와 같은 식이 있으면 이는 ```3 + (5 * (-2))```와 같이 괄호를 친 식과 같다. 따라서 그 결과는 7이 된다.  
그러면 같은 우선순위의 연산자가 여러번 등장하면 어떻게 될까? ```5 - 3 - 1```은 ```5 - 3```을 먼저 수행할까 ```3 - 1```을 먼저 수행할까? 이를 결정하는 것이 결합 방향이다. 산술 연산자의 경우 왼쪽에서 오른쪽으로의 결합 방향을 갖는다. 즉, 연산자 우선순위가 같다면 왼쪽에 있는 연산자의 연산을 먼저 수행한다는 것이다. 이를 왼쪽 연산자가 우선한다고 하여 왼쪽 결합 방향(left associativity)이라고도 한다. 결론적으로 ```5 - 3 - 1```은 ```5 - 3```을 먼저 수행하고 ```2 - 1```을 수행하여 1이라는 결과를 갖는다.  

그러면 이제 예제를 작성하며 여태까지 배운 내용을 정리하도록 하자.

```c
// arithmetic_operator.c
#include <stdio.h>

int main(void)
{
    int num1 = 10, num2 = 3, num3 = 5;
    printf("num1 + num2 = %d\n", num1 + num2);
    printf("num1 - num2 = %d\n", num1 - num2);
    printf("num1 * num2 = %d\n", num1 * num2);
    printf("num1 / num2 = %d\n", num1 / num2);
    printf("num1 %% num2 = %d\n", num1 % num2);     // % 문자 출력을 위해서는 %% 로 작성해야 함
    printf("-num1 / num2 = %d\n", -num1 / num2);
    printf("-num1 %% num2 = %d\n", -num1 % num2);
    printf("num1 + num2 * num3 = %d\n", num1 + num2 * num3);
    printf("num1 - num2 - num3 = %d\n", num1 - num2 - num3);
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make arithmetic_operator
cc     arithmetic_operator.c   -o arithmetic_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./arithmetic_operator 
num1 + num2 = 13
num1 - num2 = 7
num1 * num2 = 30
num1 / num2 = 3
num1 % num2 = 1
-num1 / num2 = -3
-num1 % num2 = -1
num1 + num2 * num3 = 25
num1 - num2 - num3 = 2
```

## 대입 연산자

대입 연산자(Assignment Operator)는 변수에 값을 저장하기 위한 연산자이다. 가장 기본적인 형태의 대입 연산자는 다음과 같이 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장하는 것이다.

```c
i = 3;      // 변수 i에 값 3을 저장
j = 5;      // 변수 j에 값 5를 저장
```

수학에서 일반적으로 ```=``` 기호는 왼쪽 항과 오른쪽 항이 같다는 관계를 뜻한다. 하지만 C언어에서는 ```=```를 한 번 사용하면 변수에 값을 저장하는 대입 연산을 의미한다. 추후에 다시 이야기하겠지만 왼쪽 항과 오른쪽 항이 같은지를 확인하는 관계 연산을 위해서는 ```=``` 기호를 두번 연속으로 사용한 ```==``` 연산자를 사용한다.  

대입 연산자의 두 피연산자의 타입이 다른 경우는 어떻게 될까? 예를 들어서 다음과 같은 상황에서는 어떻게 될까?

```c
int i;
double f;

i = 3.14;
f = 5;
```

변수 ```i```는 ```int``` 타입이고, 대입하려는 값 ```3.14```는 ```double``` 타입이다. 또한, 변수 ```f```는 ```double``` 타입이고, 대입하려는 값 ```5```는 ```int``` 타입이다. 이렇게 대입 연산자에서 두 피연산자의 타입이 같지 않은 경우 왼쪽 피연산자의 타입에 맞춰진다. 즉, 실수 ```3.14```는 정수 ```3```으로 변환하여 변수 ```i```에 저장되며, 정수 ```5```는 실수 ```5.0```으로 변환하여 변수 ```f```에 저장된다.  

여기서 한 가지 쉽게 간과하는 중요한 사실이 있다. 대입 연산자도 __연산자__ 라는 사실이다. 따라서, 연산자의 결과 값이 있다. 이는 너무나도 당연하지만 의외로 쉽게 간과하는 사실이다. 대입 연산자의 결과 값은 대입한 이후의 왼쪽 피연산자의 값이다. 즉, 위 예시에서 ```i = 3.14```의 결과 값은 3이며, ```f = 5```의 결과 값은 5.0이다.  

이렇게 대입 연산자가 결과 값을 갖기 때문에 다음 예시처럼 대입 연산자를 연속해서 사용할 수 있으며(이를 체이닝-chaining-이라고 한다), 다른 연산자들과 조합해서 사용할 수도 있다.  

```c
int i, j, k;
i = j = k = 1;      // i, j, k 모두 1이 저장됨
j = 3 + (i = 2.5);  // i의 값은 2이며, j 값은 3 + 2인 5
```

산술 연산자에서도 이야기한 것처럼, 대입 연산자도 연산자이기 때문에 연산자 우선순위와 결합 방향을 갖는다. 대입 연산자는 모든 산술 연산자보다 낮은 우선 순위를 갖고, 결합 방향은 오른쪽에서 왼쪽 방향이다. 따라서 위 예제에서 ```i = j = k = 1```은 ```i = (j = (k = 1))```와 같은 의미이다. 그리고 더하기 연산자보다 대입 연산자의 우선순위가 낮아서 대입 연산자를 먼저 평가하기 위하여 괄호를 쳐준 것이다.  

> 대입 연산자를 다른 연산자와 조합하여 사용하면 코드를 해석하기 어려워지며 실수할 가능성도 높아지므로 실제 프로그램 작성 시에는 절대 이렇게 사용하면 안 된다.

이번 챕터를 시작하면서 오브젝트를 수정하는 모든 행위는 사이드 이펙트라고 했다. 그러면 대입 연산자를 사용하여 변수에 값을 저장하는 것도 사이드 이펙트일까? 당연히 그렇다. ```int```형 변수 ```i```가 있을 때 ```i = 3.5``` 라는 식이 있으면 결과 값은 3이고 사이드 이펙트로 변수 ```i```에 3이 저장되는 것이다. 대입 연산자가 단순히 변수에 값을 할당한다고 알고 있는 것이 아니라, 위와 같이 왼쪽 피연산자의 결과 값을 가지며 추가로 변수 값 저장이라는 사이드 이펙트를 발생시킨다고 알고 있으면 좀 더 C언어를 잘 이해할 수 있다.  

이번엔 대입 연산자의 피연산자에 대해 좀 더 생각해보자. 산술 연산자는 피연산자로 변수, 상수 혹은 다른 연산자들로 조합한 식 등이 올 수 있었다. ```3 + a```, ```b - 5```, ```a * b - 3 / b```와 같은 식들이 모두 유효했다. 대입 연산자는 어떨까? 대입 연산자는 기본적으로 변수에 값을 저장하기 위한 연산자라고 했다. 그런데 ```3 = 5``` 와 같이 사용할 수 있을까? 상수 챕터에서도 이야기했다시피 이렇게 상수를 변경하려고 시도할 수 없다. 즉, 대입 연산자의 왼쪽 피연산자에는 값을 변경할 수 있는 오브젝트만 올 수 있다. 이를 가변 lvalue라고 한다. 여기서 lvalue란 엄밀하게 이야기해서 잠재적으로 오브젝트를 지정할 수 있는 식을 뜻한다. 당장은 어렵기 때문에 변수같은 것들이라고 생각하자. lvalue 중에서 const 오브젝트는 한번 선언한 이 후 값을 변경할 수 없다. 이렇게 값을 변경할 수 없는 lvalue를 제외한 lvalue를 가변 lvalue라고 한다. 가변 lvalue가 될 수 있는 것들은 추후에 더욱 살펴보고, 지금은 변수만 올 수 있다고 생각하자. 결국 다음 예시들과 같이 가변 lvalue가 아닌 것을 대입 연산자의 왼쪽 피연산자로 사용할 수 없다.

```c
3 = i;          // 3은 lvalue가 아님
i + j = 0;      // i + j의 결과로 특정 오브젝트를 지정할 수 없으므로 lvalue가 아님 
-k = 3;         // -k의 결과로 특정 오브젝트를 지정할 수 없으므로 lvalue가 아님
```

위와 같이 가변 lvalue가 아닌 것을 대입 연산자의 왼쪽 피연산자로 사용하면 컴파일 에러가 발생할 것이다.

### 복합 대입 연산자

프로그래밍을 하다보면 변수의 값을 기존에 저장되어 있던 값을 기준으로 특정 값만큼 증가 혹은 감소시키는 경우가 굉장히 많다. 예를 들어 현재 hp가 300인데, 공격을 당해서 50의 데미지를 입은 경우 hp를 250로 감소시켜야 한다. 이런 상황을 다음과 같이 표현할 수 있다.

```c
int hp = 300;   // hp가 300
hp = hp - 50;   // hp가 50 감소한 250이 됨
```

위 예제를 다음과 같이 작성할 수도 있다.

```c
int hp = 300;   // hp가 300
hp -= 50;       // hp를 기존 값에서 50 감소시킴 -> 250이 됨
```

이렇게 기존의 변수 값을 기준으로 특정 값만큼 더하거나, 빼거나, 곱하거나, 나누는 등의 연산을 수행하여 변수의 값을 수정하는 연산자를 복합 대입(Compound Assignment) 연산자라고 한다. 더하기, 빼기, 곱하기, 나누기 기호가 대입 연산 기호의 왼쪽에 오는 것에 주의해야 한다. 더하기나 빼기 기호가 우측에 위치하면 아예 다른 의미가 된다.  

```c
hp -= 50;       // hp를 기존 값에서 50 감소시킴
hp =- 50;       // hp = -50 으로 해석되어 hp에 -50을 대입함
```

복합 대입 연산자는 대입 연산자와 이 전에 배운 산술 연산자 혹은 바로 후에 배울 비트 연산자들과 조합하여 만들 수 있다. 여태까지 배운 산술 연산자와 조합한 복합 대입 연산자들을 다시 설명하면 다음과 같다.

* ```a += b``` : 변수 ```a```와 ```b``` 값을 더해서 ```a```에 저장함
* ```a -= b``` : 변수 ```a```에 ```b``` 값을 빼서 ```a```에 저장함
* ```a *= b``` : 변수 ```a```와 ```b``` 값을 곱해서 ```a```에 저장함
* ```a /= b``` : 변수 ```a```를 ```b``` 값으로 나눠서 몫을 ```a```에 저장함
* ```a %= b``` : 변수 ```a```를 ```b``` 갑승로 나눠서 나머지를 ```a```에 저장함

> 참고로 간혹가다가 ```a = a + b```와 ```a += b```가 완전히 같다고 이야기하는 자료도 있지만 그렇지는 않다. C언어를 처음 공부한다면 지금은 이해할 수 없겠지만 ```a[i++] = a[i++] + b```와 ```a[i++] += b```는 엄연히 다르다. 일단은 저 둘이 완전히 동일한 것은 아니다라는 것만 확인하고 넘어가도록 하자.  

복합 대입 연산자도 대입 연산자의 일종이다. 따라서, 대입 연산자와 같은 연산자 우선 순위와 결합 방향을 갖는다. 뿐만 아니라, 왼쪽 피연산자에는 가변 lvalue만 올 수 있으며, 결과 값으로 왼쪽 피연산자의 대입 이 후 값을 가지며, 사이드 이펙트로 왼쪽 피연산자의 값이 변경된다는 것까지 전부 동일하다. 따라서 대입 연산자에서 봤던 체이닝도 똑같이 사용할 수 있다. 하지만 복합 대입 연산자를 연속으로 사용하는 것은 코드를 해석하기 어렵게 하므로 지양하는 것이 좋다.  

이번에도 예제를 통해서 배운 내용들을 정리해보도록 하자.

```c
// assignment_operator.c
#include <stdio.h>

int main(void)
{
    int i, j, k;

    i = j = k = 1;
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    j = 3 + (i = 2.5);  // 해당 식과 같은 사용은 권장하지 않음
    printf("i : %d, j : %d\n", i, j);

    k *= i;     // k는 기존에 1
    j /= i;     // j는 기존에 5
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    i += j += k;    // 복합 대입 연산자의 체이닝은 권장하지 않음
    printf("i : %d, j : %d, k : %d \n", i, j, k);

    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make assignment_operator
cc     assignment_operator.c   -o assignment_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./assignment_operator 
i : 1, j : 1, k : 1 
i : 2, j : 5
i : 2, j : 2, k : 2 
i : 6, j : 4, k : 2 
```

## 증감 연산자

복합 대입 연산자를 학습할 때 변수의 값을 특정 값 만큼 증감시키는 작업을 자주 수행한다고 했다. 그 중에서도 특히 변수의 값을 1 증가시키거나 1 감소시키는 작업은 프로그래밍을 하면서 가장 많이 수행하는 작업 중 하나이다. C언어에서는 특별히 변수의 값을 1 증가시키거나 1 감소시키는 연산자를 다음과 같이 정의했다.

```c
++i;    // 변수 i의 값을 1 증가
i++;    // 변수 i의 값을 1 증가
--i;    // 변수 i의 값을 1 감소
i--;    // 변수 i의 값을 1 감소
```

위와 같이 + 기호를 두 번 연속으로 사용하여 증가 연산자를 표현하고, - 기호를 두 번 연속으로 사용하여 감소 연산자를 표현한다. 그리고 보다시피 증감 연산자는 한 개의 피연산자를 갖는다. 그런데 연산자가 피연산자의 왼쪽에 오기도 하고 오른쪽에 오기도 한다. 연산자의 위치가 달라져도 같은 연산일까? 그렇지 않다. 연산자의 위치에 따라 서로 다른 연산자가 된다. 그러면 둘은 무엇이 다를까? 여러가지 다른 점이 있지만 가장 다른 것은 바로 결과 값이다.

변수의 값이 변경되는 것은 모두 사이드 이펙트라고 했다. 증감 연산자를 사용해서 변수에 저장된 값이 1 증가하거나 1 감소하는 것 또한 모두 사이드 이펙트이다. 그렇다면 증감 연산자의 결과 값은 무엇일까? 연산자가 피연산자의 왼쪽에 오면 기존 피연산자에 1을 더하거나 뺀 값이 결과 값이 되고, 연산자가 피연산자의 오른쪽에 오면 기존 피연산자의 값이 결과 값이 된다. 다시 설명하면 다음과 같다.

* ```++i``` : 결과 값은 i + 1이며, 사이드 이펙트로 변수 i의 값이 1 증가함
* ```i++``` : 결과 값은 i이며, 사이드 이펙트로 변수 i의 값이 1 증가함
* ```--i``` : 결과 값은 i - 1이며, 사이드 이펙트로 변수 i의 값이 1 감소함
* ```i--``` : 결과 값은 i이며, 사이드 이펙트로 변수 i의 값이 1 감소함

결과 값의 차이가 어떤 차이를 만들어낼까? 다음과 같은 예시를 생각해보자.

```c
int i = 1, j = 1;
int a, b;

a = i++;    // i++의 결과 값은 i이므로 a = 1 이 됨
b = ++j;    // ++j의 결과 값은 j + 1이므로 b = 1 + 1이 됨
```

이렇게 연산자가 피연산자의 왼쪽에 오는 경우를 전위 증가(Prefix Increment) 연산자 혹은 전위 감소(Prefix Decrement) 연산자라고 하고, 연산자가 피연산자의 오른쪽에 오는 경우를 후위 증가(Postfix Increment) 연산자 혹은 후위 감소(Postfix Decrement) 연산자라고 한다.  

증감 연산자는 사이드 이펙트로 변수의 값을 1 증가 혹은 감소 시킨다고 했다. 따라서 다음과 같은 상황이 연출된다.

```c
int i = 1;
int a, b;

a = i++;    // i++의 결과 값은 i이므로 a = 1이 됨
// 사이드 이펙트로 변수 i에 저장된 값이 1 증가함
b = ++i;    // ++i의 결과 값은 i + 1이므로 b = 2 + 1이 됨
// 사이드 이펙트로 변수 i에 저장된 값이 1 증가함

// 최종적으로 a는 1, b는 3, i는 3이 됨
```

조금 헷갈리지만 해당 연산자를 여러번 사용해보면 어렵지 않게 적응할 수 있을 것이다.  
그런데 변수 i의 값이 증가하거나 감소하는 것이 사이드 이펙트라는 것을 왜 자꾸 강조하는 것일까?  
```++i```는 값이 먼저 증가하고 ```i++```는 값이 나중에 증가한다 처럼 해석하면 안 되는 것일까?  
절대 그러면 안 된다. 하나의 오브젝트에 대한 사이드 이펙트는 꼭 시퀀스 되어야 한다. 다시 말해서 어떤 변수에 대한 사이드 이펙트가 발생했다면 다음 시퀀스 포인트를 만나기 전까지는 해당 변수에 대해 사이드 이펙트가 다시 발생하면 안 된다. 개념적으로 보면 굉장히 어려운데, 다음과 같은 예시를 생각하면 된다.

```c
b = (a = 5) + (a = 3);      // a에 값을 변경하는 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생했음
```

이렇게 사이드 이펙트가 시퀀스 되지 않는 상황은 대표적인 미정의 행위이다. 따라서 다음과 같은 식들은 모두 미정의 행위이다.

```c
i = i++;        // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생
j = i++ + ++i;  // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 두 번 발생
i = ++i + i++;  // i에 대한 사이드 이펙트가 시퀀스 포인트 이 전에 세 번 발생
```

위와 같은 식들의 결과 변수 ```i```나 ```j``` 값이 무엇이 되는지 유추하는 것은 의미 없는 행위이다. 이러한 코드는 지양을 넘어서 절대로 작성해서는 안 된다. 물론 위와 같은 코드를 작성한다고 해서 프로그램이 동작하지 않는 것은 아니지만, 어느 날 갑자기 컴퓨터의 기분이 나빠져서 위와 같은 코드를 만났을 때 CPU가 폭발한다고 하더라도 이는 전적으로 프로그래머의 잘못임을 인지해야 한다.  
반면 다음과 같은 식은 위와 같은 미정의 행위 문제가 없다.  

```c
k = i++ + ++j;      // i, j, k 모두 사이드 이펙트가 한 번씩 발생
```

하지만 위와 같이 코드를 작성하면 이를 보는 동료 개발자가 코드를 해석하기 어려워질 것이다. 따라서 위와 같이 증감 연산자를 복잡하게 조합하여 사용하는 것은 되도록 지양하는 것이 좋다.  

여태까지 증감 연산자의 결과 값과 사이드 이펙트에 대해서 학습했다. 그러면 해당 연산자의 우선 순위와 결합 방향은 어떻게 될까? 그리고 피연산자에는 어떤 요소가 올 수 있을까?  
우선 후위 증감 연산자는 여태까지 배운 모든 연산자 중에 가장 우선 순위가 높다. 식을 괄호로 묶는 것 외에는 모든 연산자 중 가장 높은 우선 순위를 갖는다. 그리고 결합 방향은 왼쪽에서 오른쪽 방향이다.  
전위 증감 연산자는 후위 증감 연산자보다 우선 순위가 낮고, 일반적인 산술 연산자보다 우선 순위가 높다. 단항 양수/음수 연산자와 같은 우선 순위를 가지며, 결합 방향은 오른쪽에서 왼쪽 방향이다.  

얼핏 보면 ```++i```가 ```i++``` 보다 높은 우선 순위를 갖는 것처럼 보일 수 있다. 이는 ```++i```가 변수를 먼저 증가시키고, ```i++```가 변수를 나중에 증가시킨다는 잘못된 개념에서 유추하는 대표적인 오개념이다. 다시 이야기 하지만 변수의 증가는 사이드 이펙트이기 때문에 증가 시점은 해당 연산자가 평가된 이 후 시퀀스 포인트 이 전 어디서나 발생할 수 있다. 두 연산자의 변수 증가 시점은 같아도 되고, ```i++```가 ```++i```보다 먼저 증가가 발생해도 상관 없다. 단지 ```i++```의 결과 값은 ```i```이며, ```++i```의 결과 값은 ```i + 1```라는 것을 잘 인지해야 한다.  

그러면 증감 연산자는 변수의 값을 변경하는 사이드 이펙트가 있으므로 대입 연산자와 같이 피연산자로 가변 lvalue만 올 수 있을까? 그렇게 유추했다면 추론 능력이 굉장히 뛰어난 독자일 것이다. 증감 연산자는 피연산자로 가변 lvalue만 올 수 있다. ```3++```와 같이 사용할 수 없다. 그러면 증감 연산자는 대입 연산자처럼 체이닝을 할 수 있을까? 즉, ```++(++i)```와 같이 사용할 수 있을까? 만약 증감 연산자의 결과가 가변 lvalue라면 사용할 수 있을 것이고 그렇지 않다면 사용할 수 없을 것이다.  
C언어에서는 후위 증감 연산자와 전위 증감 연산자 모두 결과 값이 lvalue가 아니다. 따라서 위와 같이 사용할 수 없다. 그런데 C++언어의 경우 후위 증감 연산자의 결과는 lvalue가 아니지만 전위 증감 연산자의 결과는 lvalue이다. 따라서 C에서는 불가능한 체이닝이 C++에서는 전위 증감 연산자에 한정하여 사용할 수 있다. 물론 사용 가능하다고 하더라도 시퀀스 포인트 이 전에 사이드 이펙트가 여러 번 발생하는 것이므로 이러한 코드를 작성하면 안 된다.  

> 참고로 정수 변수 뿐만 아니라 실수 변수에도 증감 연산자를 사용할 수 있으며 이번 챕터의 설명이 그대로 적용된다. 하지만 실수 변수에 증감 연산자를 사용하는 경우는 굉장히 드물다.

역시 이번에도 예제를 통해서 배운 내용들을 정리해보도록 하자.

```c
// inc_dec_operator.c
#include <stdio.h>

int main(void)
{
    int i, j, k;
    
    i = 1;  // i를 1로 초기화
    printf("i : %d\n", ++i);    // ++i의 결과 값은 i + 1
    printf("i : %d\n", i);      // 이 전에 i 값이 증가했음
    
    i = 1;  // i를 1로 초기화
    printf("i : %d\n", i++);    // i++의 결과 값은 i
    printf("i : %d\n", i);      // 이 전에 i 값이 증가했음

    i = j = 1;  // i와 j를 1로 초기화
    k = i++ + ++j;  // i와 j는 1 증가, k = i + (j + 1)와 같은 결과 값
    printf("i : %d, j : %d, k : %d\n", i, j, k);

    i = j = 3;  // i와 j를 3으로 초기화
    k = --i * 3 + 4 * j--;  // i와 j는 1 감소, k = (i - 1) * 3 + 4 * j와 같은 결과 값
    printf("i : %d, j : %d, k : %d\n", i, j, k);

    return 0;
}
```

실행 하기 전에 결과 값을 꼭 예측해보자. 실행 결과는 다음과 같다.  

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make inc_dec_operator
cc     inc_dec_operator.c   -o inc_dec_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./inc_dec_operator 
i : 2
i : 2
i : 1
i : 2
i : 2, j : 2, k : 3
i : 2, j : 2, k : 18
```

실행 결과와 주석을 보고 이해가지 않는 부분이 있다면 이번 챕터를 다시 한번 천천히 읽어보기를 권장한다.

## 관계 연산자와 동등 연산자

관계 연산자(Relational Operator)는 다음과 같이 두 피연산자의 대소 관계를 비교한다.  

```c
a < b;      // a가 b보다 작으면 참
a <= b;     // a가 b보다 작거나 같으면 참
a > b;      // a가 b보다 크면 참
a >= b;     // a가 b보다 크거나 같으면 참
```

관계 연산자도 연산자이므로 결과 값이 있다. 대소 관계가 참이라면 ```int``` 타입의 정수 1이 결과 값이 되고, 거짓이라면 ```int``` 타입의 정수 0이 결과 값이 된다.  
C언어에서 값 0은 거짓을 의미하고, 그 외의 값들은 참을 의미한다. 1, -1, 100 모두 참 값이 되는데, 보통 1을 참 값의 대표로 사용한다.  
즉, ```a < b``` 라는 식에서 변수 ```a```에 저장된 값이 변수 ```b```에 저장된 값보다 작다면 참을 뜻하는 1이 결과가 되고, 그렇지 않다면 거짓을 뜻하는 0이 결과가 된다.  

동등 연산자(Equality Operator)는 관계 연산자와 유사하게 두 피연산자가 동등한지 비교한다.

```c
a == b;     // a와 b가 같으면 참
a != b;     // a와 b가 다르면 참
```

동등 연산자도 마찬가지로 동등 관계가 참이라면 ```int``` 타입의 정수 1이 결과 값이 되고, 거짓이라면 ```int``` 타입의 정수 0이 결과 값이 된다.  

참고로 관계 연산자는 산술 연산자보다 낮고 대입 연산자보다 높은 우선순위를 갖는다. 동등 연산자는 관계 연산자보다 낮고 대입 연산자보다 높은 우선순위를 갖는다. 그리고 둘 다 왼쪽에서 오른쪽으로의 결합 방향을 갖는다.  

관계 연산자와 동등 연산자는 선택문이나 반복문의 제어식에서 주로 사용한다. '만약 hp가 100보다 적다면 사용자에게 알린다' 와 같은 상황에서 사용하기 적합하다. 지금은 예제를 통해 단순히 결과 값을 확인하도록 하자.  

```c
// relational_operator.c
#include <stdio.h>

int main(void)
{
    int a = 3, b = 5;
    printf("a < b : %d\n", a < b);      // a가 b보다 작으면 참
    printf("a <= 3 : %d\n", a <= 3);    // a가 3보다 작거나 같으면 참
    printf("a > b : %d\n", a > b);      // a가 b보다 크면 참
    printf("a >= 3 : %d\n", a >= 3);    // a가 3보다 크거나 같으면 참
    printf("a == b : %d\n", a == b);    // a와 b가 같으면 참
    printf("a != b : %d\n", a != b);    // a와 b가 다르면 참
    return 0;
}
```

실행 결과는 다음과 같다.

```bash
pr0gr4m@DESKTOP-IRB9MN5:~/src$ make relational_operator
cc     relational_operator.c   -o relational_operator
pr0gr4m@DESKTOP-IRB9MN5:~/src$ ./relational_operator 
a < b : 1
a <= 3 : 1
a > b : 0
a >= 3 : 1
a == b : 0
a != b : 1
```

## 논리 연산자



## 비트 연산자

## 기타 연산자