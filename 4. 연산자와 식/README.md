# 연산자와 식

C언어에서 식(expression)은 가장 중요한 요소 중 하나이다. C언에서 식이란 값을 계산하기 위한 연산자와 피연산자의 나열, 오브젝트, 함수, 사이드 이펙트 발생들이 조합되는 것을 의미한다. 사실 식에 대한 개념은 굉장히 쉽게 공부할 수도 있다. 필요한 개념을 배우지 않고, 잘못된 개념으로 학습한다면이라는 가정이 붙으면 그렇다. 여섯 살 아이에게 설명할 수 없다면 그 개념을 이해하지 못한 것이라는 아인슈타인의 어록에 숨어서 무조건 쉽게 설명한다면 좀 더 대중적으로 환영받는 책이 될 수 있겠지만, 해당 서적은 처음엔 조금 어렵게 느껴지더라도 이해하고 나면 정확한 개념들을 숙지할 수 있도록 하는 것을 지향하고 있다. 따라서 해당 챕터의 내용들에 어렵다고 느껴지는 내용들이 나오더라도 좌절하지 말자. 처음엔 어렵게 느껴지겠지만 극복하기만 하면 잘못된 코드를 분간하는 능력을 갖출 수 있을 것이다. 그러기 위해 연산자와 식을 본격적으로 공부하기 전 사전 지식들을 알아보자.

* 사이드 이펙트(side effect) : 오브젝트를 수정하거나, 파일을 수정하거나, volatile 오브젝트에 접근하거나, 앞의 세 행위 중 하나 이상을 수행하는 함수를 호출하여 프로그램의 상태가 변경되는 것을 말한다. 간단하게 변수 a에 새로운 값 3을 대입하는 것도 사이드 이펙트이다. ```printf``` 함수를 호출했을 때 화면에 문자열이 출력되는 것도 터미널 상태를 수정하는 사이드 이펙트이다.  
* 평가(Evaluation) : 식의 값을 계산하거나 사이드 이펙트가 시작하는 것을 의미한다. ```3 + 4``` 라는 식을 평가하면 ```7``` 이라는 결과 값이 나온다. 변수 ```a```에 3을 대입하는 ```a = 3``` 라는 식을 평가하면 ```3``` 이라는 결과 값이 나오면서 ```a```에 3을 대입하는 사이드 이펙트가 시작된다.
* 시퀀스(Sequence) : 문맥에 따라 나열이라는 의미 혹은 순서라는 의미를 가질 수 있다. 이스케이프 시퀀스나 문자 시퀀스에서 사용하는 시퀀스는 문자들이 나열된다는 의미이다. 평가에 대한 시퀀스라고 할 때는 순서를 의미한다. A와 B라는 두 평가가 있을 때, A가 B보다 전에 시퀀스된다라고 하면 A가 B보다 늦게 실행되는게 보장된다는 뜻이다. 반면 A와 B 두 평가의 순서가 보장되지 않을때는 A와 B가 시퀀스되지 않는다(unsequenced)라고 한다. (주로 A와 B가 동시에 실행될 수 있는 경우를 의미한다.) 마지막으로 A와 B의 평가가 동시에 수행되지 않는 것은 보장되지만 둘 중 어떤 것이 먼저 평가될지는 정해지지 않는 것을 비결정적인 시퀀스(indeterminately sequenced)라고 한다. 해당 개념이 어렵다면 식이나 평가라는 단어와 함께 시퀀스가 사용되는 경우 순서 보장을 의미한다는 것만 알아두자.
* 시퀀스 포인트(Sequence point) : 이 전에 평가한 식에서 발생한 사이드 이펙트가 모두 완료되는 지점을 의미한다. A와 B 사이에 시퀀스 포인트가 있다고 하면 A와 관련된 모든 연산과 사이드 이펙트에 대한 완료가 B에 관련된 연산과 사이드 이펙트보다 먼저 시퀀스된다는 것을 의미한다. C언어에는 다음과 같은 시퀀스 포인트들이 있다. 하지만 지금 해당 내용들을 제대로 이해할 수 없으므로, 우선 문장을 종료하기 위한 ```;``` 은 시퀀스 포인트 역할을 한다고 생각하고 엄밀한 내용은 필요할 때 다시 찾아보도록 하자.
    * 함수 호출 시 함수 시작 전. 예를 들어 ```f(a++, b++)```라는 식이 있으면 변수 ```a```와 ```b```에 있는 값이 함수 ```f```가 시작되기 전에 1 증가되는 것이 보장된다. 단, 인자 구분자는 컴마 연산자가 아니기 때문에 ```a```와 ```b``` 중 어떤 것이 먼저 증가될지는 보장되지 않는다. 마찬가지로, ```f(a++) + g(b++)``` 라는 식이 있을 때 변수 ```a```가 함수 ```f``` 시작 전에 1 증가 되는 것이 보장되며, 변수 ```b```가 함수 ```g``` 시작 전에 1 증가 되는 것이 보장되지만, 둘 중 어떤 함수가 먼저 호출될지와 ```a```와 ```b``` 중 무엇이 먼저 증가될지는 보장되지 않는다.
    * 논리연산자 ```&&```, ```||```와 컴마 연산자 ```,```. 예를 들어 ```a = 3, b = 5``` 라는 식이 있으면 변수 ```a```에 3이 저장되는 사이드 이펙트가 ```b = 5``` 평가 전에 완료되는 것이 보장된다.
    * 조건연산자 ```? :```. 예를 들어 ```++a == 3 ? b = 5 : c = 1``` 라는 식이 있으면 변수 ```a``` 값이 1 증가하는 사이드 이펙트가 ```b = 5```나 ```c = 1``` 식이 평가 전에 완료되는 것이 보장된다.
    * 완전 식(full expression)의 종료 지점. 완전 식이란 다른 식이나 선언자의 부분(part)이 되지 않는 식을 의미한다. 완전 식의 종류는 다음과 같다.
        * 식 문장(expression statement)의 식(expression)
        * 선택문(selection statement, ```if, switch``` 등)의 제어 식(controlling expression)
        * ```while, do``` 문의 제어 식
        * ```for``` 문의 각 내부 식
        * ```return``` 문의 식
        * 변수에 대한 선언자. 예를 들어 ```int x = 2, y = 3``` 라는 선언에서 ```x = 2, y = 3```는 ```x = 2```라는 선언자와 ```y = 3```라는 선언자가 ```,``` 구두점으로 구분된 초기화 선언자 리스트이다. 각 선언자는 시퀀스 포인트이므로 변수 ```x```에 2가 대입되는 사이드 이펙트가 ```y = 3``` 선언자가 평가되기 전에 완료되는 것이 보장된다.
        * 복합 리터럴의 일부가 아닌 이니셜라이저. 예를 들어 ```int x = y++``` 라는 선언에서 이니셜라이저 ```y++```는 시퀀스 포인트이다. 따라서 변수 ```x```의 값이 변경되기 전에 변수 ```y```의 값이 1 증가하는 것이 보장된다. (하지만 ```y++```의 평가 결과 값은 ```y```이므로, ```x```에는 값이 증가하기 전의 ```y``` 값이 대입된다.)
    * 라이브러리 함수의 반환 직전
    * 비교 함수 호출 직전과 직후
    * 그 외 포맷 지정자와 관련된 시퀀스 포인트가 하나 더 있지만 오히려 혼동을 가중할 수 있기에 해당 서적에서는 생략한다.

사전적인 의미는 언제나 어렵다. 조금 쉽게 설명하면 변수에 저장되어 있는 값이 변경되는 것과 같이 프로그램의 상태가 변경되는 것을 사이드 이펙트라고 한다. 그리고 식을 평가하면 식에 포함되어 있는 연산을 수행하여 결과 값이 나온다. 이 때 연산 과정에서 사이드 이펙트가 존재한다면 평가 시 사이드 이펙트가 시작된다. 그리고 이 사이드 이펙트는 시퀀스 포인트 전 어디에서나 수행될 수 있으며, 시퀀스 포인트 다음으로 넘어가기 전에 완료가 보장되는 것이다.

위의 내용을 대략적으로 이해했다면 연산자와 식을 학습하기 위한 기본적인 사전 지식 준비는 완료되었다. 그런데 이 전 챕터에서 미정의 행위라던지 implemention-defined 라던지 하는 용어들이 자꾸 등장했던 것을 기억할 것이다. 앞으로도 해당 용어들이 자주 등장할 예정이므로, 이와 관련된 용어들도 살펴보도록 하자.

* 미정의 행위(undefined behavior) : 프로그램의 이식성을 해치거나 에러를 발생시키는 등 표준에서 정의되지 않은 행위를 하는 것이다. 미정의 행위를 실행하면 예측할 수 없는 결과를 초래하거나 컴파일 및 실행 중 종료 등의 결과를 초래할 수 있다.
* 미지정 행위(unspecified behavior) : 정의되지 않는 값을 사용하거나 정의되지 않은 행동을 하는 등 표준에서 두 개 이상의 결과를 초래할 수 있는 행위에 대해 결정하지 않은 행동을 하는 것이다.  
* implementation-defined behavior : 환경에 따라 특정 구현이 정의되어 있는 미지정 행위이다.  

쉽게 이야기해서 미정의 행위는 해당 코드의 결과가 어떻게 될 지 아예 정해지지 않은 행위이고, 미지정 행위는 해당 코드의 결과로 여러 결과 중 하나가 나올 수 있는 행위이며, implementation-defined behavior는 미지정 행위의 여러 결과 중 어떤 결과가 나올 것인지 실행 환경에 따라 결정이 되어 있는 행위를 의미한다. C23에서 정의한 200개 이상의 미정의 행위와 약 50개의 미지정 행위가 있다. 미정의 행위와 미지정 행위에 의존한 코드를 작성하는 것은 절대적으로 지양해야 한다. 그렇다면 C언어 프로그램을 작성하기 위해서는 약 250개의 항목들을 전부 암기하고 있어야 할까? 물론 그렇지는 않다. 위 항목들을 살펴보다 보면 상식적인 프로그래머라면 생각이나 시도조차 하지 않을 항목들도 포함하고 있다. 하지만 중간중간 시도해봄직한 코드지만 미정의 행위의 항목에 포함되어 있는 경우도 있다. 이러한 코드가 인터넷 상에서 어째서 코드의 결과가 이렇게 되었는지 토론의 대상이 되고는 한다. 하지만 사실 이러한 토론들은 전부 의미가 없다. 미정의 행위의 결과는 정해져 있지 않고 언제든지 바뀔 수 있으며 심지어 미정의 행위로 인해서 컴퓨터가 폭발하더라도 이는 프로그래머의 잘못이기 때문이다. 해당 서적에서는 이렇게 혼란을 줄 수 있는 미정의 행위나 미지정 행위들을 기피할 수 있도록 안내할 것이며, 거기에 더해 카네기 멜론 대학에서 발표한 미정의 행위와 미지정 행위를 피하는 안전한 프로그램 작성 가이드를 부록에서 소개할 것이다. 참고로, 한 오브젝트에 대해 시퀀스 포인트 이 전에 서로 다른 사이드 이펙트가 발생하는 것과, 사이드 이펙트가 발생한 오브젝트를 같은 식의 다른 하위 식에서 사용하는 것은 대표적인 미정의 행위다. 예를 들어 ```i = ++i + 1```과 같은 식을 들 수 있는데, 해당 식의 결과 변수 ```i```에 어떤 값이 저장되는 지에 대한 토론이 종종 발생하지만 이는 미정의 행위이기 때문에 의미 없는 토론이다.

## 연산자와 구두점

